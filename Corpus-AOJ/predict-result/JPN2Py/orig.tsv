i に 1 を加え た 値 、 j に 1 を加え た 値 を出力する	print ( i + 1 , j + 1 )	print ( i + 1 , j + 1 ) <eos>
stack _ A の 長さが 1 と 等しい とき 、 <blk> 0 を出力する </blk>	if len ( stack_A ) == 1 : <blk> print ( 0 ) </blk>	if len ( stack_A ) == 1 : <blk> print ( 0 ) </blk> <eos>
0 を re t の 128 番目 にする	ret [ 128 ] = 0	ret [ 128 ] = 0 <eos>
side 2 . __ next __ ( ) を展開し 、 それぞれ q 1 、 q 2 とする	q1 , q2 = side2 . __next__ ( )	q1 , q2 = <unk> . <unk> ( ) <eos>
0 、 255 、 255 を R 、 G 、 B とする	R , G , B = 0 , 255 , 255	R , G , G = 0 , 255 , 255 <eos>
k の 文字列を k s とする	ks = str ( k )	ks = str ( k ) <eos>
f の i 番目の とき 、 <blk> an s を 1 だけ 増加 させる </blk>	if f [ i ] : <blk> ans += 1 </blk>	if f [ i ] : <blk> ans += 1 </blk> <eos>
p _ cal を total _ cal とする	total_cal = p_cal	max_total_cal_par_doll = <unk> <eos>
p as の i 番目の 順序 数 が 65 以上 かつ p as の i 番目の 順序 数 が 9 0 以下の とき 、	if ord ( pas [ i ] ) >= 65 and ord ( pas [ i ] ) <= 90 :	if ord ( pas [ i ] ) >= ord ( pas [ i ] ) and ord ( pas [ i ] ) <= 90 : <eos>
0 を dist の start 番目 にする	dist [ start ] = 0	dist [ start ] = 0 <eos>
p o ly g on s の 2 個 までの コン ビ ネ ーション を 順に p 1 、 p 2 として 、 繰 り 返す	for p1 , p2 in combinations ( polygons , 2 ) :	for p1 , p2 in combinations ( itertools . combinations ( ps ) , 2 ) : <eos>
入力された 文字列のリスト を out とする	out = list ( input ( ) )	out = list ( input ( ) ) <eos>
an s の 長さが r に 2 を加え た 値 より小さい とき 、 <blk> an s を '0' に r に 2 を加え た 値 から an s の 長さ を 引 いた 値を 掛け た 値 だけ 増加 させる </blk>	if len ( ans ) < r + 2 : <blk> ans += '0' * ( r + 2 - len ( ans ) ) </blk>	if len ( ans ) < 2 + r * 2 : <blk> ans += '0' + s [ r - 2 ] * len ( ans ) </blk> <eos>
M の i に 1 を加え た 値 番目の 末尾に j を追加する	M [ i + 1 ] . append ( j )	M [ i + 1 ] . append ( j ) <eos>
A を ソート する	A . sort ( )	A . sort ( ) <eos>
p 、 d を a の i 番目の 1 番目 、 a の i 番目の 2 番目 とする	a [ i ] [ 1 ] , a [ i ] [ 2 ] = p , d	a [ i ] [ 1 ] , a [ i ] [ 2 ] = p , d [ i ] <eos>
board の x 番目の y 番目 を 1 だけ 増加 させる	board [ x ] [ y ] += 1	board [ x ] [ y ] += 1 <eos>
pro d s の 末尾に cross を追加する	prods . append ( cross )	prods . append ( cross ) <eos>
( 0 、 100 ) からなる 列 を h ok et s u _ 2 とする	hoketsu_2 = [ 0 , 100 ]	hoketsu_2 = [ 0 , 100 ] <eos>
t P の j に 1 を加え た 値 番目 を t p j だけ 減 少 させる	tP [ j + 1 ] -= tpj	tP [ j + 1 ] -= t <eos>
N の i 番目 を x とする	x = N [ i ]	x = N [ i ] <eos>
r 0 の i 番目 を 1 だけ 増加 させる	r0 [ i ] += 1	r0 [ i ] += 1 <eos>
C の y 1 番目の i 番目 が " . " と 等しくない とき 、	if C [ y1 ] [ i ] != "." :	if C [ y1 ] [ i ] != "." : <eos>
0 から N 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 入力された 文字列の 整数値 の 列 を C os t とする	Cost = [ int ( input ( ) ) for i in range ( N ) ]	C = [ int ( input ( ) ) for i in range ( N ) ] <eos>
入力された 文字列 の浮動小数点数 を a とする	a = float ( input ( ) )	a = float ( input ( ) ) <eos>
( x _ a から x _ d を 引 いた 値 、 y _ a から y _ d を 引 いた 値 ) からなる 列 を da とする	da = [ x_a - x_d , y_a - y_d ]	<unk> = [ x_d - x_c , y_d - <unk> ] <eos>
He a p の 末尾に ( i 、 A の i 番目 、 A の parent 番目 、 right 、 left ) からなる 列 を追加する	Heap . append ( [ i , A [ i ] , A [ parent ] , right , left ] )	Heap . append ( [ i , A [ i ] , A [ left , right ] ] ) <eos>
M ( message ) を message とする	message = M ( message )	message = M ( message ) <eos>
0 から num の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( num ) ) :	for i in range ( len ( num ) ) : <eos>
a を x 0 で 割 った 余 り にする	a % = x0	a % = x0 <eos>
d p の i から 1 を 引 いた 値 番目の 、 つまり 先頭から 4 番目 までの 部分 列 の 総 和 を mod で 割 った 余 り を d p の i 番目の 2 番目 にする	dp [ i ] [ 2 ] = sum ( dp [ i - 1 ] [ : 4 ] ) % mod	dp [ i ] [ 4 ] = sum ( dp [ i - 1 ] [ : 4 ] ) % mod <eos>
c が ' R ' と 等しい とき 、	if c == 'R' :	if c == 'R' : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を追加して 、 つまり 整数 を拡張する	str . extend ( input ( ) . split ( ) )	str . extend ( input ( ) . split ( ) ) <eos>
P の s 番目 を返す	return P [ s ]	return P [ s ] <eos>
h が 0 と 等 し く かつ w が 0 と 等しい とき 、	if h == 0 and w == 0 :	if h == 0 and w == 0 : <eos>
input ( ) . split ( ) の各要素 に int を 適用 した 列 を ソート した 列 の 逆 順 を 展開 して を出力する	print ( * sorted ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] )	print ( * sorted ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] ) <eos>
42 80 を a とする	a = 4280	a = 4280 <eos>
r r から n 未 満 までの 数 列 を 順に r 2 として 、 繰 り 返す	for r2 in range ( rr , n ) :	for r2 in range ( r , n ) : <eos>
空 列 を go al とする	goal = [ ]	goal = [ ] <eos>
d d を 順に d x 、 d y として 、 繰 り 返す	for dx , dy in dd :	for dx , dy , dy in dd : <eos>
( 0 ) からなる 列 の 8 回 分 の 列 、 ( 0 ) からなる 列 の 8 回 分 の 列 を s r 、 s c とする	sr , sc = [ 0 ] * 8 , [ 0 ] * 8	s , c = [ 0 ] * 8 , [ 0 ] * 8 <eos>
change ( l st ) を l st とする	lst = change ( lst )	lst = change ( lst ) <eos>
e 、 c を a で 割 った 商 の 最大 値を e とする	e = max ( e , c // a )	e = max ( e , c // a ) <eos>
S の各要素 に 整数 を 適用 した 列 のリスト を S とする	S = list ( map ( int , S ) )	S = list ( map ( int , S ) ) <eos>
first を i _ in s とする	i_ins = first	i_ins = first <eos>
an s の 末尾に ( i 、 j ) の 組 を追加する	ans . append ( ( i , j ) )	ans . append ( ( i , j ) ) <eos>
w を パラメータ として w の 1 番目 を返す 関数を キー として f req を ソート した 列 を f req とする	freq = sorted ( freq , key = lambda w : w [ 1 ] )	freq = sorted ( freq , key = lambda w : w [ 1 ] ) <eos>
0 から N 未 満 までの 数 列 の各要素 を i と し 、 u の i 番目 でない ときの P S の i 番目の 列 を T とする	T = [ PS [ i ] for i in range ( N ) if not u [ i ] ]	S = [ S [ i ] for i in range ( N ) if T [ i ] ] <eos>
base s を 1 だけ 増加 させる	bases += 1	bases += 1 <eos>
0 から 1 を v だけ 左 シフト した 値 未 満 までの 数 列 を 順に bits として 、 繰 り 返す	for bits in range ( 1 << v ) :	for bits in range ( 1 << v ) : <eos>
m が 0 より大きい とき 、 <blk> 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を b とする </blk>	if m > 0 : <blk> b = list ( map ( int , input ( ) . split ( ) ) ) </blk>	if m > 0 : <blk> b = list ( map ( int , input ( ) . split ( ) ) </blk> <eos>
逆 順に 0 から 10 未 満 までの 数 列 の各要素 を j と し 、 input ( ) の 整数値 の 列 を ソート した 列 の 、 つまり 先頭から 3 番目 までの 部分 列 の 総 和 を s の i 番目 にする	s [ i ] = sum ( sorted ( [ int ( input ( ) ) for j in range ( 10 ) ] , reverse = True ) [ : 3 ] )	s [ : 3 ] = sorted ( sum ( [ int ( input ( ) for j in range ( 10 ) ] ) ) ) <eos>
p a per の x に 1 を加え た 値 番目の y から 1 を 引 いた 値 番目 を 1 だけ 増加 させる	paper [ x + 1 ] [ y - 1 ] += 1	paper [ x + 1 ] [ y - 1 ] += 1 <eos>
a が b と 等しい かどうか が c と 等しい かどうか が 0 と 等しい とき 、	if a == b == c == 0 :	if a == b == c == 0 : <eos>
t . show _ keys ( )	t . show_keys ( )	t . <unk> ( keys ) <eos>
空 列 、 空 列 を S 、 L 2 とする	S , L2 = [ ] , [ ]	S2 , S2 = [ ] , [ ] <eos>
is _ prime ( a ) の とき 、 <blk> res を 1 だけ 増加 させる </blk>	if is_prime ( a ) : <blk> res += 1 </blk>	if is_prime ( a ) : <blk> res += 1 </blk> <eos>
1 から k に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , k + 1 ) :	for i in range ( 1 , k + 1 ) : <eos>
ch a ir s の逆 順 、 1 に 番号 付 した 組 の 列 を 順に i 、 c として 、 繰 り 返す	for i , c in enumerate ( chairs [ : : - 1 ] , 1 ) :	for i , c , c in enumerate ( chairs [ : : - 1 ] ) : <eos>
q . popleft ( ) を x とする	x = q . popleft ( )	x = q . popleft ( ) <eos>
a c を 1 だけ 増加 させる	ac += 1	ac += 1 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ m 、 f 、 b とする	m , f , b = map ( int , input ( ) . split ( ) )	m , f , b = map ( int , input ( ) . split ( ) ) <eos>
que の 末尾に ( to 、 dist に 1 を加え た 値 ) の 組 を追加する	que . append ( ( to , dist + 1 ) )	que . append ( ( to , dist + 1 ) ) <eos>
d y 0 が 0 より小さい とき 、	if dy0 < 0 :	if dx0 < 0 : <eos>
input _ ed ge の t n 2 番目 で ないとき 、	if not input_edge [ tn2 ] :	if not input_edge [ n2 ] : <eos>
m の 、 つまり 先頭から x に 1 を加え た 値 までの 部分 列 を 削 除 する	del m [ 0 : x + 1 ]	del m [ : x + 1 ] <eos>
を 間 に入れ て factor s を 連結 した 文字列 を出力する	print ( " " . join ( factors ) )	print ( " " . join ( factors ( factors ) ) ) <eos>
m の n 乗 に対する 10 の 9 乗 に 7 を加え た 値の 剰余 を出力する	print ( pow ( m , n , 10 ** 9 + 7 ) )	print ( pow ( pow ( m , n , 10 ) , 7 + 9 , 7 ) ) <eos>
depth が max _ depth と 等しい とき 、	if depth == max_depth :	if depth == depth : <eos>
a に f を 掛け た 値 から c に d を 掛け た 値を 引 いた 値を y とする	y = a * f - c * d	y = a * f - c * d <eos>
0 から H に 2 を加え た 値 未 満 までの 数 列 の各要素 を j と し 、 0 から W に 2 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 " . " の 列 の 列 を table とする	table = [ [ "." for i in range ( W + 2 ) ] for j in range ( H + 2 ) ]	table = [ [ "" for i in range ( W + 2 ) ] for j in range ( H + 2 ) ] <eos>
pep er の y に 2 を加え た 値 番目の x 番目 を 1 だけ 増加 させる	peper [ y + 2 ] [ x ] += 1	peper [ y + 2 ] [ x ] += 1 <eos>
datetime モジュール を用い る	from datetime import date	from datetime import date , date , date <eos>
B in ary T re e ( n ) を B T とする	BT = BinaryTree ( n )	T = BinaryTree ( n ) <eos>
count s に対応する 値 、 もし 存在し なければ a 、 0 に 1 を加え た 値を count s の a 番目 にする	counts [ a ] = counts . get ( a , 0 ) + 1	counts [ a ] = counts . get ( a , 0 ) + 1 <eos>
{} を出力する	print ( { a + b + c : . 8 f } )	print ( { pt . x : . 8 f } ) <eos>
t が a d j _ list の s 番目 に 含まれない とき 、	if t not in adj_list [ s ] :	if t not in adj_list [ s ] : <eos>
tea m _ data の 1 番目 を m に 20 に tea m _ data の - p 番目 を 掛け た 値 を加え た 値 だけ 減 少 させる	team_data [ 1 ] -= ( m + 20 * team_data [ - p ] )	team_data [ 1 ] -= team_data [ 20 ] + p * 20 ) <eos>
x 1 から x 2 を 引 いた 値に y 3 から y 4 を 引 いた 値を 掛け た 値 から y 1 から y 2 を 引 いた 値に x 3 から x 4 を 引 いた 値を 掛け た 値を 引 いた 値	( ( x1 - x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 - x4 ) )	x1 = x1 - x2 - y1 - y2 * ( x4 - y3 ) * ( y2 - x3 - y3 ) <eos>
b が 3 より小さい とき 、	if b < 3 :	if b < 3 : <eos>
S の j 番目 が 全て 数字 の とき 、	if S [ j ] . isdigit ( ) :	if S [ j ] . isdigit ( ) : <eos>
1 から V 未 満 までの 数 列 を 順に u として 、 繰 り 返す	for u in range ( 1 , V ) :	for u in range ( 1 , V ) : <eos>
r を 1 だけ 増加 させる	r += 1	r += 1 <eos>
A の N から 1 を 引 いた 値 番目 を出力する	print ( A [ N - 1 ] )	print ( A [ N - 1 ] ) <eos>
' internal node ' を self の type にする	self . type = 'internal node'	self . type = <unk> <eos>
r o m の i から 1 を 引 いた 値 番目の j 番目 、 r o m の i から 1 を 引 いた 値 番目の j から 1 を 引 いた 値 番目の 最大 値に r o m の i 番目の j 番目 を加え た 値を r o m の i 番目の j 番目 にする	rom [ i ] [ j ] = max ( rom [ i - 1 ] [ j ] , rom [ i - 1 ] [ j - 1 ] ) + rom [ i ] [ j ]	rom [ i ] [ j ] = max ( rom [ i - 1 ] [ j - 1 ] , rom [ i - 1 ] [ j ] ) + rom [ i ] [ j - 1 ] <eos>
入力された 文字列の 整数値 を k とする	k = int ( input ( ) )	k = int ( input ( ) ) <eos>
( 0 ) からなる 列 の 8 回 分 の 列 を b とする	b = [ 0 ] * 8	b = [ 0 ] * 8 <eos>
q を 順に i として 、 繰 り 返す	for i in q :	for i in q : <eos>
s から n に 1 を加え た 値 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( s , n + 1 ) :	for k in range ( s , n + 1 ) : <eos>
r の left を r とする	r = r . left	r = r . left <eos>
s が a の k 番目 と 等しい とき 、	if s == a [ k ] :	if s == a [ k ] : <eos>
p x を p の py 番目 にする	p [ py ] = px	px [ py ] = px <eos>
key 、 this M on th の key 番目 に last M on th の key 番目 を加え た 値 を出力する	print ( key , thisMonth [ key ] + lastMonth [ key ] )	print ( key , thisMonth [ key ] + thisMonth [ lastMonth [ key ] ) <eos>
[ MASK ] の 辞書 カウンタ を this _ month とする	this_month = Counter ( )	last_month = Counter ( ) <eos>
入力された 文字列を 順に x として 、 繰 り 返す	for x in input ( ) :	for x in input ( ) : <eos>
F i b ( N ) を出力する	print ( Fib ( N ) )	print ( <unk> ( N ) ) <eos>
string モジュール を用い る	from string import ascii_uppercase	from string import ascii_lowercase <eos>
a d j _ m を ver t ex と の 論理和 にする	adj_m | = vertex	adj | = <unk> <eos>
a d j _ ed ge _ c p の e 1 番目 を e 1 _ c p とする	e1_cp = adj_edge_cp [ e1 ]	e1_cp = adj_edge_cp [ 1 ] <eos>
0 から 20 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 20 ) :	for j in range ( 20 ) : <eos>
b a g _ no が num _ ba g g age s 以上の とき 、	if bag_no >= num_baggages :	if bag_no >= num_baggages : <eos>
% d : % d : % d を ( h 、 m 、 s ec ) の 組 で 割 った 余 り を出力する	print ( "%d:%d:%d" % ( h , m , sec ) )	print ( <unk> % ( h , m , sec ) ) <eos>
check ( A , B , K ) の とき 、	if check ( A , B , K ) :	if check ( A , B , K ) : <eos>
readline ( ) の 両端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ N 、 S とする	N , S = readline ( ) . strip ( ) . split ( )	S , N = readline ( ) . strip ( ) . split ( ) <eos>
number  内の C 2 と 等しい 要素を 取り除く	number . remove ( C2 )	number . remove ( C2 ) <eos>
未 定 値を self の left にする	self . left = None	self . left = None <eos>
b を d の a 番目 にする	d [ a ] = b	d [ a ] = b <eos>
D 0 の i に 1 を加え た 値 番目 を D 0 の i 番目 だけ 増加 させる	D0 [ i + 1 ] += D0 [ i ]	D0 [ i + 1 ] += D [ i ] <eos>
w の浮動小数点数 を h の 浮動小数点数の 2 乗 で 割 った 値が 25 以上の とき 、	if float ( w ) / float ( h ) ** 2 >= 25 :	if float ( w ) / ( float ( h ) ** 2 ) >= 25 : <eos>
index を low link の v 番目 にする	lowlink [ v ] = index	lowlink [ v ] = index <eos>
ns を 1 だけ 増加 させる	ns += 1	ns += 1 <eos>
a の N から 1 を 引 いた 値 番目 から N に 2 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( a [ N - 1 ] , N + 2 ) :	for i in range ( a [ N - 1 ] , N + 2 ) : <eos>
W に 3 を加え た 値 から W に 2 を加え た 値に H に 1 を加え た 値を 掛け た 値 未 満 までの W に 2 を加え た 値 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( W + 3 , ( W + 2 ) * ( H + 1 ) , W + 2 ) :	for i in range ( W + 3 , 2 + 1 , W * 2 + 2 ) : <eos>
H が 0 より小さい とき 、 <blk> 繰り返し を 中断 する </blk>	if H < 0 : <blk> break </blk>	if H < 0 : <blk> break </blk> <eos>
を 間 に入れ て array の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する	print ( " " . join ( map ( str , array ) ) )	print ( " " . join ( map ( str , array ) ) ) <eos>
arr の x 番目の y から 1 を 引 いた 値 番目 が 0 と 等しい とき 、 <blk> p の x 番目の y 番目 を p の x 番目の y から 1 を 引 いた 値 番目 だけ 増加 させる </blk>	if arr [ x ] [ y - 1 ] == 0 : <blk> p [ x ] [ y ] += p [ x ] [ y - 1 ] </blk>	if arr [ x ] [ y - 1 ] [ x - 1 ] == 0 : <blk> p [ y ] [ x ] += 1 </blk> <eos>
10 から 20 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 10 , 20 ) :	for j in range ( 10 , 20 ) : <eos>
真 を d ic の key 番目 にする	dic [ key ] = True	dic [ key ] = True <eos>
start が x と 等しくな く かつ cp _ d is join t . is S ame Set ( x , start ) の とき 、	if start != x and cp_disjoint . isSameSet ( x , start ) :	if start != code and <unk> ( x , tP ) : <eos>
0 から n 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( n ) :	for k in range ( n ) : <eos>
偽 を p _ ch の j 番目 にする	p_ch [ j ] = False	ch_list [ j ] = False <eos>
k 、 r を r r の r 番目 、 p とする	rr [ r ] , p = k , r	r , p = k , r [ r ] <eos>
d q の q の 1 番目 番目の d q の q [ 1 ] 番目の 長さ から 1 を 引 いた 値 番目 を出力する	print ( dq [ q [ 1 ] ] [ len ( dq [ q [ 1 ] ] ) - 1 ] )	print ( dq [ q ] [ 1 ] - len ( dq [ q [ 1 ] ) - 1 ] ) <eos>
a qua を出力する	print ( "aqua" )	print ( <unk> ) <eos>
r r を R S の state 0 番目 に SS の state 1 番目 に d 0 を 掛け た 値に P S の state 1 番目 を加え た 値を 掛け た 値 だけ 減 少 させる	rr -= RS [ state0 ] * ( SS [ state1 ] * d0 + PS [ state1 ] )	rr -= Si [ 0 ] * <unk> + EPS [ 1 ] * <unk> + Si [ 1 ] * depth [ 0 ] <eos>
0 を D の num 番目 にする	D [ num ] = 0	D [ num ] = 0 <eos>
( 1 、 1 、 2 ) からなる 列 を a とする	a = [ 1 , 1 , 2 ]	a = [ 1 , 1 , 2 ] <eos>
tea m s の 末尾に ( tea m 、 time ) からなる 列 を追加する	teams . append ( [ team , time ] )	teams . append ( [ team , time ] ) <eos>
空 列 を points の p 番目 にする	points [ p ] = [ ]	points [ p ] = [ ] <eos>
hand が ( 1 、 10 、 11 、 12 、 13 ) からなる 列 と 等しい とき 、	if hand == [ 1 , 10 , 11 , 12 , 13 ] :	if hand == [ 1 , 10 , 11 , 12 , 13 ] : <eos>
2 25 から MAX に 1 を加え た 値 未 満 までの 2 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 225 , MAX + 1 , 2 ) :	for i in range ( 25 , MAX + 1 , 2 ) : <eos>
pow _ re m ( x , n // 2 ) の 2 乗 を d で 割 った 余 り を返す	return pow_rem ( x , n // 2 ) ** 2 % d	return ( ( ( m , x // 2 ) // d ) ** 2 ) <eos>
( a 、 k ) からなる 列 を返す	return [ a , k ]	return [ a , k ] <eos>
( 0 ) からなる 列 の m 回 分 の 列 を 順に _ として 、 繰 り 返す <blk> 入力された 文字列 </blk>	for _ in [ 0 ] * m : <blk> input ( ) </blk>	for _ in [ 0 ] * m : <blk> input ( ) </blk> <eos>
0 を _ num _ output s とする	_num_outputs = 0	_num_outputs = 0 <eos>
conv ex _ h ul l の逆 順 を返す	return convex_hull [ : : - 1 ]	return convex_hull [ : - 1 ] <eos>
D 、 i に 1 を加え た 値 を出力する	print ( "D" , i + 1 )	print ( D , i + 1 ) <eos>
val 、 c n t を出力する	print ( val , cnt )	print ( val , cnt ) <eos>
空 列 を stack _ A とする	stack_A = [ ]	stack_A = [ ] <eos>
P の 末尾に z を追加する	P . append ( z )	P . append ( z ) <eos>
readline ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ W 、 H とする	W , H = map ( int , readline ( ) . split ( ) )	H , W = map ( int , readline ( ) . split ( ) ) <eos>
S 、 an s の 最大 値を an s とする	ans = max ( S , ans )	ans = max ( S , ans ) <eos>
' k ' 、 ' l ' 、 ' m ' 、 ' n ' 、 ' o ' を a の 31 番目 、 a の 32 番目 、 a の 33 番目 、 a の 34 番目 、 a の 35 番目 とする	a [ 31 ] , a [ 32 ] , a [ 33 ] , a [ 34 ] , a [ 35 ] = 'k' , 'l' , 'm' , 'n' , 'o'	a [ n ] , a [ <unk> ] , a [ <unk> ] , a [ <unk> ] , <unk> [ <unk> ] = 'm' , 'g' , 'g' , 'g' , 'g' , 'g' : <eos>
f を 順に r として 、 繰 り 返す	for r in f :	for r in f : <eos>
x が y より小さい とき " {} {} " を出力する 、 そうでなければ " {} {} " を出力する	print ( { x } { y } ) if x < y else print ( { y } { x } )	print ( { y < 0 else { y } { y else { z } ) <eos>
f を 順に l として 、 繰 り 返す	for l in f :	for l in f : <eos>
空 列 を v s とする	vs = [ ]	vs = [ ] <eos>
queue の 0 を取り出し た 値を current とする	current = queue . pop ( 0 )	current = queue . pop ( 0 ) <eos>
0 を j とする を s とする	s = j = 0	s = j = 0 <eos>
sys の stdin から 読み込んだ 行の 列 を file _ input とする	file_input = sys . stdin . readlines ( )	file_input = sys . stdin . readlines ( ) <eos>
( 1 ) からなる 列 の 1 を L だけ 左 シフト した 値 回 分 の 列 を B とする	B = [ 1 ] * ( 1 << L )	B = [ 1 ] * ( L << L ) <eos>
flag を返す	return flag	return flag <eos>
a が 60 以上の とき 、 <blk> f の 6 番目 を 1 だけ 増加 させる </blk>	if a >= 60 : <blk> f [ 6 ] += 1 </blk>	if a >= 60 : <blk> f [ 1 ] += 6 </blk> <eos>
t M の j 番目 、 t M の k 番目 を p j 、 p k とする	pj , pk = tM [ j ] , tM [ k ]	pj , pk = tM [ j ] , tM [ k ] <eos>
color の i 番目 を an s とする	ans = color [ i ]	ans = color [ i ] <eos>
sum _ list を 順に i として 、 繰 り 返す	for i in sum_list :	for i in sum_list : <eos>
i が p と 等しい とき 、	if i == p :	if i == p : <eos>
s が 正規表現 " [0-9] + " に マッチした 文字列の 列 を 順に i として 、 繰 り 返す <blk> an s を i の 整数値 だけ 増加 させる </blk>	for i in re . findall ( "[0-9]+" , s ) : <blk> ans += int ( i ) </blk>	for i in re . findall ( '[0-9]+' , s ) : <blk> ans += int ( i ) </blk> <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を 展開 し 、 それぞれ a 、 b とする	a , b = [ int ( _ ) for _ in input ( ) . split ( ',' ) ]	a , b = [ int ( _ ) for _ in input ( ) . split ( ',' ) ] <eos>
p を cur とする	cur = p	cur = p <eos>
s b を b だけ 増加 させる	sb += b	sb += b <eos>
s p 1 から s p 2 を 引 いた 値を c とする	c = sp1 - sp2	c = p1 - s2 <eos>
a の 末尾に 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を j と し 、 j の 整数値 の 列 を追加する	a . append ( [ int ( j ) for j in input ( ) . split ( ) ] )	a . append ( [ int ( j ) for j in a . split ( ) ] ) <eos>
lt の 末尾に ls の先頭 を追加する	lt . append ( ls [ 0 ] )	lt . append ( ls [ 0 ] ) <eos>
d f s ( i + 1 , s + a [ i ] )	dfs ( i + 1 , s + a [ i ] )	dfs ( i + 1 , s [ i + 1 ] ) <eos>
result の 、 つまり 先頭から -2 番目 までの 部分 列 、 result の先頭 を 除 いた 部分 列 の 要素を それぞれ 組 に した 列 を 順に t d 1 、 t d 2 として 、 繰 り 返す	for td1 , td2 in zip ( result [ : - 2 ] , result [ 1 : ] ) :	for d1 , d2 in zip ( result [ : - 1 ] , result [ 1 : ] ) : <eos>
self . Find _ R o ot ( y ) を y とする	y = self . Find_Root ( y )	y = self . Find_Root ( y ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ n 、 m とする	n , m = [ int ( i ) for i in input ( ) . split ( ) ]	n , m = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
1 を step とする	step = 1	step = 1 <eos>
( 0 ) からなる 列 の i 回 分 の 列 を x の - i 番目 から 、 つまり 末 尾 までの 部分 列 にする	x [ - i : ] = [ 0 ] * i	x [ i : ] = [ 0 ] * i <eos>
id x が arr の 長さ と 等 し く または arr の id x 番目 が x と 等しくない とき 、	if idx == len ( arr ) or arr [ idx ] != x :	if idx == len ( arr ) or arr [ idx ] != x : <eos>
sys の stdin を 順に line として 、 繰 り 返す	for line in sys . stdin :	for line in sys . stdin : <eos>
0 から n の 整数値 に 1 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 0 の 列 を num list とする	numlist = [ 0 for i in range ( int ( n ) + 1 ) ]	num_list = [ 0 for i in range ( int ( n + 1 ) ) ] <eos>
sum _ s を出力する	print ( sum_s )	print ( <unk> ) <eos>
readline ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ N 、 L とする	N , L = map ( int , readline ( ) . split ( ) )	L , L = map ( int , readline ( ) . split ( ) ) <eos>
入力された 文字列 の浮動小数点数 を x とする	x = float ( input ( ) )	x = float ( input ( ) ) <eos>
s の 文字列の長さ が 80 以下の とき 、	if len ( str ( s ) ) <= 80 :	if len ( str ( s ) ) <= 80 : <eos>
0 から C の先頭 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( C [ 0 ] ) :	for i in range ( C [ 0 ] ) : <eos>
( 0 ) からなる 列 の h 回 分 の 列 の各要素 を _ と し 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の 列 を a とする 0 を b とする	a = [ input ( ) . split ( ) for _ in [ 0 ] * h ] b = 0	a = [ 0 ] * h b = [ 0 for _ in input ( ) . split ( ) ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を 展開 し 、 それぞれ c 1 、 c 5 、 c 10 、 c 50 、 c 100 、 c 500 とする	c1 , c5 , c10 , c50 , c100 , c500 = [ int ( _ ) for _ in input ( ) . split ( ) ]	c , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> = [ int ( _ ) for _ in input ( ) . split ( ) ] <eos>
N の l 番目 を "," で 分割 した 字句 列 を c とする	c = N [ l ] . split ( "," )	c = N [ l ] . split ( "," ) <eos>
a から 1 を 引 いた 値を a とする	a = a - 1	a = a - 1 <eos>
i に i に 1 を加え た 値を 掛け た 値を 2 で 割 った 値を tmp とする	tmp = ( i * ( i + 1 ) ) / 2	tmp = i + 1 * i / 2 <eos>
s に w の i 番目 を加え た 値が p 以下の とき 、	if s + w [ i ] <= p :	if s + w [ i ] <= p : <eos>
x 2 、 y 2 を x 1 、 y 1 とする	x1 , y1 = x2 , y2	x1 , y1 = x2 , y2 <eos>
n に m を加え た 値を s とする	s = n + m	s = n + m <eos>
C の各要素 を p x 、 py と し 、 C の各要素 を q x 、 q y と し 、 ( p x - q x ) ** 2 + ( py - q y ) ** 2 の平方根 の 列 の 組 の 列 の 組 を a d j とする	adj = tuple ( [ tuple ( [ sqrt ( ( px - qx ) ** 2 + ( py - qy ) ** 2 ) for qx , qy in C ] ) for px , py in C ] )	dp = [ math . sqrt ( [ ( ( px - py ) ** 2 + ( qx - py - qy ) ** 2 , dp ) for j in C ] ) <eos>
ver t ex _ weights の u 番目の 末尾に ( v t x _ w g h t の 2 に v _ i を 掛け た 値 番目 、 v t x _ w g h t の 2 に v _ i を 掛け た 値に 1 を加え た 値 番目 ) の 組 を追加する	vertex_weights [ u ] . append ( ( vtx_wght [ 2 * v_i ] , vtx_wght [ 2 * v_i + 1 ] ) )	vertex_weights [ ( vtx_wght [ 2 * v_i ] , pt2_x [ i ] ) * v_i + 1 ] <eos>
% . 3 f % . 3 f を ( c から b * x を 引 いた 値を a で 割 った 値 、 x ) の 組 で 割 った 余 り を出力する	print ( "%.3f %.3f" % ( ( c - b * x ) / a , x ) )	print ( "%.3f %.3f %.3f" % ( x - a * b , x ) ) <eos>
stack _ B の 末尾に stack _ A の i 番目 を追加する	stack_B . append ( stack_A [ i ] )	stack_A . append ( A [ a_i ] ) <eos>
c n t を i だけ 増加 させる	cnt += i	cnt += i <eos>
0 から n に 1 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 0 の 列 を B とする	B = [ 0 for i in range ( n + 1 ) ]	B = [ 0 for i in range ( n + 1 ) ] <eos>
未 定 値を parent とする	parent = None	parent = None <eos>
( ( 1 , 0 ) 、 ( 2 , 0 ) 、 ( 3 , 0 ) 、 ( 4 , 0 ) 、 ( 5 , 0 ) 、 ( 6 , 0 ) ) からなる 辞書を d ic とする	dic = { 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 , 6 : 0 }	dic = { 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 6 : 0 , 6 : 0 } <eos>
B の s b 番目 を 1 だけ 増加 させる	B [ sb ] += 1	B [ sb ] += 1 <eos>
w が dict _ f req に含まれる とき 、	if w in dict_freq :	if w in dict_freq : <eos>
an s が 0 以上の とき an s 、 そうでなければ " un re ach able " を出力する	print ( ans if ans >= 0 else "unreachable" )	print ( <unk> if ans >= 0 else <unk> ) <eos>
m を 1 だけ 右 シフト する	m >> = 1	m >> = 1 <eos>
n が 0 と 等 し く かつ m が 0 と 等 し く かつ a が 0 と 等しい とき 、	if n == 0 and m == 0 and a == 0 :	if n == 0 and m == 0 and a == 0 : <eos>
a の 整数値 を b の 整数値 で 割 った 商 を出力する	print ( int ( a ) // int ( b ) )	print ( int ( a ) // int ( b ) ) <eos>
max _ f low を返す	return max_flow	return flowed <eos>
an s を 順に x 、 y として 、 繰 り 返す	for x , y in ans :	for x , y in ans : <eos>
operator モジュール を用い る	from operator import itemgetter	from operator import mul <eos>
r d を 順に t 、 p c 、 m 、 s として 、 繰 り 返す	for t , pc , m , s in rd :	for t , p , m , s , s in r : <eos>
j の とき 、	if j :	if j : <eos>
d を出力する	print ( "d" )	print ( d ) <eos>
group の 総 和 から min _ in _ group を 引 いた 値を sum _ without _ min とする	sum_without_min = sum ( group ) - min_in_group	<unk> = sum ( group ) - <unk> <eos>
j が 0 より小さい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if j < 0 : <blk> continue </blk>	if j < 0 : <blk> continue </blk> <eos>
'' を s の 1 から i と 1 の 論理 積 を 引 いた 値 番目 にする	s [ 1 - ( i & 1 ) ] = ''	s [ i - 1 ] = '' <eos>
self の x 座 標 に other の y 座 標 を 掛け た 値 から self の y 座 標 に other の x 座 標 を 掛け た 値を 引 いた 値を返す	return self . x * other . y - self . y * other . x	return self . x * other . y - other . y * other . x <eos>
f ( n -1 ) に f ( n -2 ) を加え た 値に f ( n -3 ) を加え た 値を返す	return f ( n - 1 ) + f ( n - 2 ) + f ( n - 3 )	return ( f ( n - 1 ) + f ( n - 2 ) + - 3 ) <eos>
S の i 番目の 整数値 を d とする	d = int ( S [ i ] )	d = int ( S [ i ] ) <eos>
e の id x 番目の i 番目 が '.' と 等しくない とき 、 <blk> 繰り返し を 中断 する </blk>	if e [ idx ] [ i ] != '.' : <blk> break </blk>	if e [ idx ] [ i ] != '.' : <blk> break </blk> <eos>
a の r 番目 、 a の i に 1 を加え た 値 番目 を a の i に 1 を加え た 値 番目 、 a の r 番目 とする	a [ i + 1 ] , a [ r ] = a [ r ] , a [ i + 1 ]	a [ i + 1 ] , a [ r + 1 ] = a [ r ] , a [ i + 1 ] <eos>
N の l 番目 を "," で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を n とする	n = [ int ( i ) for i in N [ l ] . split ( "," ) ]	n = [ int ( i ) for i in N [ l ] . split ( "," ) ] <eos>
w 1 に w 2 を加え た 値を w とする	w = w1 + w2	w = w1 + w2 <eos>
t が '-' と 等しい とき 、	if t == '-' :	if t == '-' : <eos>
d p の n -1 番目の 、 つまり 先頭から 4 番目 までの 部分 列 の 総 和 を mod で 割 った 余 り を出力する	print ( sum ( dp [ n - 1 ] [ : 4 ] ) % mod )	print ( sum ( dp [ : 4 ] [ : 4 ] ) % mod ) <eos>
p の 23 番目 、 p の先頭 を p の先頭 、 p の 23 番目 とする	p [ 0 ] , p [ 23 ] = p [ 23 ] , p [ 0 ]	p [ 0 ] , p [ 0 ] = p [ 21 ] , p [ 0 ] <eos>
q が -1 と 等しい とき 、	if q == - 1 :	if q == - 1 : <eos>
0 から string の 長さ 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( len ( string ) ) :	for j in range ( len ( string ) ) : <eos>
0 を b c とする	bc = 0	bc = 0 <eos>
x 、 y の 最大 値 、 x 、 y の 最小 値を x 、 y とする	x , y = max ( x , y ) , min ( x , y )	x , y = min ( x , y ) , min ( x , y ) <eos>
s を x に y を 掛け た 値 だけ 増加 させる	s += x * y	s += x * y <eos>
( 0 ) からなる 列 の 3 回 分 の 列 を c とする	c = [ 0 ] * 3	c = [ 0 ] * 3 <eos>
self の state の ch _ y に 3 を 掛け た 値に ch _ x を加え た 値 番目 を conv _ char とする	conv_char = self . state [ ch_y * 3 + ch_x ]	ch_list = self . state [ 3 * y + <unk> ] <eos>
prime _ f actor ize ( n ) を prime _ f actor s とする	prime_factors = prime_factorize ( n )	prime_factors = <unk> ( n ) <eos>
50000 を N とする	N = 50000	N = <unk> <eos>
x を d x 1 だけ 増加 させる y を d y 1 だけ 増加 させる d に 1 を加え た 値を 4 で 割 った 余 り を d とする	x += dx1 y += dy1 d = ( d + 1 ) % 4	x = ( dx << dx1 + dy ) % d1 <eos>
0 、 k に 1 を加え た 値を s 、 k とする	s , k = 0 , k + 1	s , k = 0 , k + 1 <eos>
S の i に 1 を加え た 値 番目 を op とする	op = S [ i + 1 ]	op = S [ i + 1 ] <eos>
' C ' を そうでなければ 、 とする	else = 'C'	else = 'C' <eos>
lists [ arg [ 0 ] ] . dump ( )	lists [ arg [ 0 ] ] . dump ( )	<unk> [ 0 ] [ 0 ] . <unk> ( ) <eos>
num が y の j 番目 と 等しい とき 、 <blk> tmp の j 番目 に 1 を加え た 値を D P の j に 1 を加え た 値 番目 にする </blk>	if num == y [ j ] : <blk> DP [ j + 1 ] = tmp [ j ] + 1 </blk>	if num == y [ j ] : <blk> DP [ j + 1 ] = DP [ j + 1 ] + 1 </blk> <eos>
c が p より大きい とき 、 <blk> b を r とする <sep> c を p とする </blk>	if c > p : <blk> r = b <sep> p = c </blk>	if c > p : <blk> r = b <sep> p = c </blk> <eos>
a の n r 番目の c 番目 が '1' と 等しい とき 、	if a [ nr ] [ c ] == '1' :	if a [ nr ] [ nc ] == '1' : <eos>
0 から a 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( a ) :	for i in range ( a ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ A 、 B とする	A , B = map ( str , input ( ) . split ( ) )	A , B = map ( int , input ( ) . split ( ) ) <eos>
d p の i 番目の j 番目の b 番目 が co st より小さい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if dp [ i ] [ j ] [ b ] < cost : <blk> continue </blk>	if dp [ i ] [ j ] < b : <blk> continue </blk> <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ n m 、 k とする	nm , k = input ( ) . split ( )	n , k = input ( ) . split ( ) <eos>
num を 順に j として 、 繰 り 返す	for j in num :	for j in num : <eos>
d を c から b を 引 いた 値 だけ 増加 させる	d += c - b	d += c - b <eos>
t の x 番目 が '-' と 等しい とき 、 <blk> a を t の x に 2 を加え た 値 番目 だけ 増加 させる </blk>	if t [ x ] == '-' : <blk> a += t [ x + 2 ] </blk>	if t [ x ] == '-' : <blk> a [ t + x ] += 2 </blk> <eos>
parent _ search ( tree , target ) を child _ parent とする	child_parent = parent_search ( tree , target )	child = parent_search ( tree , parent ) <eos>
arr の r 番目の c 番目 が i と 等しくない とき 、 <blk> n t を co st の i 番目 だけ 増加 させる </blk>	if arr [ r ] [ c ] != i : <blk> nt += cost [ i ] </blk>	if arr [ r ] [ c ] != cost : <blk> cost [ i ] += cost </blk> <eos>
seq の k 番目 が guess の k 番目 と 等しい とき 、	if seq [ k ] == guess [ k ] :	if seq [ k ] == guess [ k ] : <eos>
0 から m 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 入力された 文字列の 整数値 の 列 を b とする	b = [ int ( input ( ) ) for _ in range ( m ) ]	b = [ int ( input ( ) ) for _ in range ( m ) ] <eos>
1 を 辞書の k i 番目 にする	dict [ ki ] = 1	dict [ ki ] = 1 <eos>
x から 1 を 引 いた 値に y から 1 を 引 いた 値 を加え た 値に 2 を加え た 値 から d から 1 を 引 いた 値を 引 いた 値を an s とする	ans = ( x - 1 ) + ( y - 1 ) + 2 - ( d - 1 )	ans = x - 1 + y1 - d + 2 - 1 <eos>
tree の target 番目の 1 番目 を そうでなければ 、 とする	else = tree [ target ] [ 1 ]	else = tree [ target ] [ 1 ] <eos>
p _ q の 末尾に ( p _ name 、 r _ time の 整数値 ) からなる 列 を追加する	p_q . append ( [ p_name , int ( r_time ) ] )	p_q . append ( [ int ( t_p ) , int ( time ) ] ) <eos>
1 を d の line の 1 番目 番目 にする	d [ line [ 1 ] ] = 1	d [ line1 [ 1 ] ] = 1 <eos>
( ( i , self . root s ( ) の各要素 を i と し 、 self . members ( i ) の 列 ) ) からなる 辞書 を返す	return { i : [ self . members ( i ) for i in self . roots ( ) ] }	return { i : self . root ( [ i for i in self . root ) ] } <eos>
change ( t 2 ) に n 2 を 掛け た 値 を出力する	print ( change ( t2 ) * n2 )	print ( change ( t2 ) * n2 ) <eos>
q の 末尾に s を追加する	q . append ( s )	q . append ( s ) <eos>
z の 整数値 を s とする	s = int ( z )	s = int ( z ) <eos>
- s n を s n とする - t n を t n とする - d を d とする	sn = - sn tn = - tn d = - d	d = - sn t = - sn d = - d <eos>
0 を H an ak o _ ten とする	Hanako_ten = 0	Hanako_ten = 0 <eos>
C a se % d : を case で 割 った 余 り を出力する	print ( "Case %d:" % case )	print ( "Case <unk> % case ) <eos>
b の 、 つまり 先頭から 2 番目 までの 部分 列 の 総 和 を c とする	c = sum ( b [ : 2 ] )	c = sum ( b [ : 2 ] ) <eos>
to の x 番目の 末尾に ( y 、 d 、 c ) の 組 を追加する	to [ x ] . append ( ( y , d , c ) )	to [ x ] . append ( ( y , d ) ) <eos>
level の v 番目 が next _ level 以上 かつ r _ cap a c ity が 0 より大きい とき 、	if ( level [ v ] >= next_level ) and ( r_capacity > 0 ) :	if level [ v ] >= 0 and level > 0 : <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の 総 和 を c n t とする	cnt = sum ( map ( int , f_i . readline ( ) . split ( ) ) )	cnt = sum ( map ( int , f_i . readline ( ) . split ( ) ) ) <eos>
1 を n とする	n = 1	n = 1 <eos>
M P の co prime ( x n 0 , d 0 ) に co prime ( y n 0 , d 0 ) を加え た 値 番目 を v 0 とする	v0 = MP [ coprime ( xn0 , d0 ) + coprime ( yn0 , d0 ) ]	v0 = MP [ coprime ( xn , d0 ) + coprime ( yn , d0 ) ] <eos>
( 0 ) からなる 列 の n から 1 を 引 いた 値 回 分 の 列 を 順に _ として 、 繰 り 返す	for _ in [ 0 ] * ( n - 1 ) :	for _ in [ 0 ] * ( n - 1 ) : <eos>
a に 番号 付 した 組 の 列 を 順に i 、 v として 、 繰 り 返す	for i , v in enumerate ( a ) :	for i , v in enumerate ( a ) : <eos>
a の i に i を 掛け た 値 番目の 1 番目 を 1 だけ 増加 させる	a [ i * i ] [ 1 ] += 1	a [ i * i ] [ 1 ] += 1 <eos>
A を 5 で 割 った 余 り を n a とする	na = A % 5	a = A % 5 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 m 、 l とする	n , m , l = map ( int , input ( ) . split ( ) )	n , l , m = map ( int , input ( ) . split ( ) ) <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト の 列 を arr 1 とする	arr1 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ]	arr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <eos>
f の とき " OK " 、 そうでなければ " N G " を出力する	print ( "OK" if f else "NG" )	print ( "OK" if f else "NG" ) <eos>
d p の da に k を加え た 値 番目の i に 1 を加え た 値 番目 、 d p の da 番目の i 番目 に t を加え た 値の 最大 値を d p の da に k を加え た 値 番目の i に 1 を加え た 値 番目 にする	dp [ da + k ] [ i + 1 ] = max ( dp [ da + k ] [ i + 1 ] , dp [ da ] [ i ] + t )	dp [ k + 1 ] [ i + 1 ] = max ( dp [ k + i ] [ i + 1 ] , dp [ i ] [ j ] ) <eos>
M の t 番目の 末尾に ( w 、 s ) からなる 列 を追加する	M [ t ] . append ( [ w , s ] )	M [ t ] . append ( [ sw , s ] ) <eos>
s を "," で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ c 、 d とする	c , d = [ int ( i ) for i in s . split ( "," ) ]	c , d = [ int ( i ) for i in s . split ( "," ) ] <eos>
Q の 長さ の間 、 次 を 繰 り 返す	while len ( Q ) :	while len ( Q ) : <eos>
1 を an s の 1 番目の i 番目 にする	ans [ 1 ] [ i ] = 1	ans [ 1 ] [ i ] = 1 <eos>
Point ( x 3 , y 3 ) を P 3 とする	P3 = Point ( x3 , y3 )	y3 = Point ( x3 , y3 ) <eos>
c 1 が n 以下の とき 、	if c1 <= n :	if c1 <= n : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト の 総 和 を s a とする	sa = sum ( list ( map ( int , input ( ) . split ( ) ) ) )	sa = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
42 80 から 11 50 に 10 * 125 を加え た 値に 10 に 1 40 を 掛け た 値 を加え た 値に w から 30 を 引 いた 値に 16 0 を 掛け た 値 を加え た 値を 引 いた 値 を出力する	print ( 4280 - ( 1150 + 10 * 125 + 10 * 140 + ( w - 30 ) * 160 ) )	print ( 4280 - ( 1150 + 10 * 125 + ( w - 30 ) * 160 ) + 0 ) <eos>
pre - me i j i を出力する	print ( "pre-meiji" )	print ( "pre-meiji" ) <eos>
s を 10 の 4 乗 で 割 った 商 を s とする	s = s // 10 ** 4	s = s // 10 ** 4 <eos>
b を ソート した 列 を 順に x として 、 繰 り 返す	for x in sorted ( b ) :	for x in sorted ( b ) : <eos>
'' を 間 に入れ て dec s を 連結 した 文字列 を出力する	print ( '' . join ( decs ) )	print ( '' . join ( decs ) ) <eos>
i 、 j を パラメータ として t 21 の i 番目 に t 31 の j 番目 を 掛け た 値 から t 21 の j 番目 に t 31 の i 番目 を 掛け た 値を 引 いた 値を返す 関数を de t とする	det = lambda i , j : t21 [ i ] * t31 [ j ] - t21 [ j ] * t31 [ i ]	det = lambda i : j [ 21 [ i ] * 31 [ j ] ] , t [ 21 - t [ i ] ] <eos>
x の リストを x とする	x = list ( x )	x = list ( x ) <eos>
d p の i 番目 を b に 1 から a を 引 いた 値を 掛け た 値に j に d p の i から j を 引 いた 値 から 1 を 引 いた 値 番目 を加え た 値を 掛け た 値 だけ 増加 させる	dp [ i ] += b * ( 1 - a ) * ( j + dp [ i - j - 1 ] )	dp [ i ] += ( b [ i - 1 ] * ( a - j ) + d - 1 ) * ( p - i ) <eos>
node s の キー の集まり の集合 から left s に right s を加え た 値 の集合 を 引 いた 値 のリスト の先頭 を root _ no とする	root_no = list ( set ( nodes . keys ( ) ) - set ( lefts + rights ) ) [ 0 ]	root_node_no = list ( set ( set ( nodes . keys ( ) ) - left ) + set ( ) ) [ 0 ] <eos>
i が 2 より大きい とき 、 <blk> k を t の i から 3 を 引 いた 値 番目 だけ 減 少 させる </blk>	if i > 2 : <blk> k -= t [ i - 3 ] </blk>	if i > 2 : <blk> t [ i - 3 ] -= t </blk> <eos>
\\\\\ write ( " % d % + d i \\\\ \\\\ n " % ( res . real , res . imag ) ) \\\\\	\\\\\write ( "%d%+di\\\\\\\\n" % ( res . real , res . imag ) )\\\\\	\\\\\write ( "%d %d\\\\\\\\n" % ( i + res . real , res . imag ) )\\\\ <eos>\
yes の とき " Y ES " 、 そうでなければ " NO " を出力する	print ( "YES" if yes else "NO" )	print ( "YES" if "yes" else "NO" ) <eos>
so in の 末尾に b を追加する	soin . append ( b )	soin . append ( b ) <eos>
S ame を返す	return "Same"	return Same <eos>
message を " ? " だけ 増加 させる	message += "?"	message += "?" <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 w 、 h とする	n , w , h = map ( int , input ( ) . split ( ) )	n , h , w = map ( int , input ( ) . split ( ) ) <eos>
n が i に 2 を 掛け た 値 より小さい とき 、	if n < i * 2 :	if n < i * 2 : <eos>
d _ tmp . move ( op )	d_tmp . move ( op )	d_tmp . move ( op ) <eos>
self の node s を返す	return self . nodes	return self . nodes <eos>
si k i の j 番目 が ') ' と 等しい とき 、	if siki [ j ] == ')' :	if siki [ j ] == ')' : <eos>
1 から N 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , N ) :	for i in range ( 1 , N ) : <eos>
t を x とする	x = t	x = t <eos>
b 内の ' X ' を x の 文字列で 置き換え た 文字列を n b とする	nb = b . replace ( 'X' , str ( x ) )	nb = b . replace ( 'X' , str ( x ) <eos>
( ( " N or th " , 1 ) 、 ( " E a st " , 2 ) 、 ( " W est " , 3 ) 、 ( " S out h " , 4 ) 、 ( " R ight " , 5 ) 、 ( " L e f t " , 6 ) ) からなる	d = { "North" : 1 , "East" : 2 , "West" : 3 , "South" : 4 , "Right" : 5 , "Left" : 6 }	<unk> = { N : <unk> , 1 : <unk> , 2 : <unk> , 6 : <unk> , 4 : <unk> , 6 : <unk> } <eos>
a を r の i 番目 に i + 1 、 s + 1 - i の 最大 値 から 10 1 未 満 までの 数 列 の各要素 を j と し 、 r の j 番目の 列 の 総 和 を 掛け た 値 だけ 増加 させる	a += r [ i ] * sum ( [ r [ j ] for j in range ( max ( i + 1 , s + 1 - i ) , 101 ) ] )	a += max ( [ r [ i + 1 ] * i + 1 for j in range ( sum ( s [ i + 1 ] - 1 , - j + 1 ) ) ] ) <eos>
0 から h ul l の 長さ から 1 を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( hull ) - 1 ) :	for i in range ( len ( hull ) - 1 ) : <eos>
n uri ( table , m , x , y -1 )	nuri ( table , m , x , y - 1 )	nuri ( table , m , x , y - 1 ) <eos>
r を 100 で 割 った 余 り が t を 30 で 割 った 余 り と 等しい かどうか が 0 と 等しい とき 、 <blk> a を出力する </blk>	if r % 100 == t % 30 == 0 : <blk> print ( a ) </blk>	if r % 100 == 0 : <blk> print ( a % 30 == 0 ) </blk> <eos>
w all が '0' と 等しい とき 、	if wall == '0' :	if wall == '0' : <eos>
入力された 文字列のリスト を a の 先頭の r 番目 にする	a [ 0 ] [ r ] = list ( input ( ) )	a [ 0 ] [ r ] = list ( input ( ) ) <eos>
IN F を r とする	r = INF	r = INF <eos>
t x から s x を 引 いた 値を d x とする	dx = tx - sx	dx = tx - xs <eos>
z から x x を 引 いた 値の 1 を 3 で 割 った 値 乗 の 整数値 を y とする	y = int ( ( z - xx ) ** ( 1 / 3 ) )	y = int ( z - ( x / 3 ) ** 1 ) <eos>
s の i 番目 に an s を加え た 値を x とする	x = s [ i ] + ans	x = s [ i ] + ans <eos>
cur を pre v とする	prev = cur	prev = cur <eos>
1 から n に 1 を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 1 , n + 1 ) :	for j in range ( 1 , n + 1 ) : <eos>
d x 、 d y を出力する	print ( dx , dy )	print ( dx , dy ) <eos>
tb l の j -1 番目の 2 番目 に x を 掛け た 値を w で 割 った 値に tb l の j から 1 を 引 いた 値 番目の 先頭 を加え た 値を y 1 とする	y1 = tbl [ j - 1 ] [ 2 ] * x / w + tbl [ j - 1 ] [ 0 ]	y = tbl [ j - 1 ] [ x ] * x2 + tbl [ j ] [ 0 ] [ 1 ] <eos>
a から c を 引 いた 値の 2.0 乗 に b から d を 引 いた 値の 2.0 乗 を加え た 値 の平方根 を出力する	print ( sqrt ( ( a - c ) ** 2.0 + ( b - d ) ** 2.0 ) )	print ( math . sqrt ( ( math . sqrt ( a - c ) ** 2.0 - b ) ) <eos>
0 から H 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 入力された 文字列 の各要素 を s と し 、 s の 列 の 列 を property とする	property = [ [ s for s in input ( ) ] for i in range ( H ) ]	property = [ [ input ( ) for i in range ( H ) ] for i in range ( H ) ] <eos>
'#' を r の y 番目の x 番目 にする	r [ y ] [ x ] = '#'	r [ y ] [ x ] = '#' <eos>
( 、 つまり 無限大 ) からなる 列 の size 回 分 の 列 を dist ance とする	distance = [ inf ] * size	distance = [ inf ] * size <eos>
s の 先頭の 2 乗 に s の 1 番目の 2 乗 を加え た 値 から s の 2 番目の 2 乗 を 引 いた 値を b とする	b = s [ 0 ] ** 2 + s [ 1 ] ** 2 - s [ 2 ] ** 2	b = s [ 0 ] ** 2 + s [ 1 ] ** 2 - s [ 2 ] <eos>
new の 末尾に '' を 間 に入れ て re _ a に re _ b を加え た 値を 連結 した 文字列 を追加する	new . append ( '' . join ( re_a + re_b ) )	new . append ( '' . join ( re_b + a ) ) <eos>
改行 せずに ' node % d : key = % d , ' を ( i 、 a の i 番目 ) の 組 で 割 った 余 り を出力する	print ( 'node %d: key = %d, ' % ( i , a [ i ] ) , end = '' )	print ( 'node %d: key = %d, ' % ( a [ i ] , end = '' ) ) <eos>
0 を h _ num とする	h_num = 0	h_num = 0 <eos>
fractions モジュール を用い る	import fractions	from fractions import <unk> <eos>
0 から w に 1 を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( w + 1 ) :	for j in range ( w + 1 ) : <eos>
N の先頭 を "," で 分割 した 字句 列 の各要素 を i と し 、 i の 浮動小数点数の 列 を 展開 し 、 それぞれ x 0 、 y 0 とする	x0 , y0 = [ float ( i ) for i in N [ 0 ] . split ( "," ) ]	x0 , y0 = [ float ( i ) for i in N [ 0 ] . split ( "," ) ] <eos>
i が id の i 番目 と 等しくない 間 、 次 を 繰 り 返す	while i != id [ i ] :	while i != id [ i ] : <eos>
a の j 番目の 1 番目 が x 以下の とき 、	if a [ j ] [ 1 ] <= x :	if a [ j ] [ 1 ] <= x : <eos>
0 、 x に a を加え た 値の 最大 値を x とする	x = max ( 0 , x + a )	x = max ( 0 , x + a ) <eos>
( 0 ) からなる 列 を p ic tur e とする	picture = [ 0 ]	picture = [ 0 ] <eos>
( 0 ) からなる 列 の 21 回 分 の 列 を a とする	a = [ 0 ] * 21	a = [ 0 ] * 21 <eos>
a の 最大 値を b とする	b = max ( a )	b = max ( a ) <eos>
{ : f } を 書式 として an s で 整 形 した 文字列 を出力する	print ( "{:f}" . format ( ans ) )	print ( <unk> . format ( ans ) ) <eos>
1 を arr の y 番目の x 番目 にする	arr [ y ] [ x ] = 1	arr [ y ] [ x ] = 1 <eos>
N を 順に i として 、 繰 り 返す <blk> answer の 末尾に a ba c us の i の 整数値 番目の リスト を追加する </blk>	for i in N : <blk> answer . append ( list ( abacus [ int ( i ) ] ) ) </blk>	for i in list ( str ( <unk> ) ) : <blk> answer . append ( int ( str ( a [ i ] ) ) ) </blk> <eos>
0 から 31 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 偽 の 列 を points とする	points = [ False for i in range ( 31 ) ]	points = [ False for i in range ( 31 ) ] <eos>
R の i に 1 を加え た 値 番目 を b とする	b = R [ i + 1 ]	b = R [ i + 1 ] <eos>
txt 1 の i 番目 、 txt 2 の i 番目 を c 1 、 c 2 とする	c1 , c2 = txt1 [ i ] , txt2 [ i ]	c1 [ i ] , c2 [ c1 ] = <unk> [ i ] , <unk> <eos>
t a x ( i , x ) に t a x ( j , x ) を加え た 値が s と 等 し く かつ j が 0 より大きい とき 、	if tax ( i , x ) + tax ( j , x ) == s and j > 0 :	if ( i_tax ( i , x + a ) == 0 and ( j + a , j ) > 0 : <eos>
p o ly 0 の 末尾に p o ly 0 の先頭 を追加する	poly0 . append ( poly0 [ 0 ] )	poly0 . append ( poly0 [ 0 ] ) <eos>
id x の k 番目 を 順に j として 、 繰 り 返す <blk> a の 末尾に ( j 、 辞書の j 番目 ) の 組 を追加する </blk>	for j in idx [ k ] : <blk> a . append ( ( j , dict [ j ] ) ) </blk>	for j in idx [ k ] : <blk> dict ( a [ j ] , a [ j ] ) </blk> <eos>
1 を fib の 0 番目 にする	fib [ 0 ] = 1	fib [ 0 ] = 1 <eos>
d の 最大 値を m とする	m = max ( d )	m = max ( d ) <eos>
fact s の i 番目 を table s の i 番目の j 番目 にする	tables [ i ] [ j ] = facts [ i ]	tables [ i ] [ j ] = facts [ i ] <eos>
改行 せずに p h one の num 番目の k a is u u から 1 を 引 いた 値 番目 を出力する	print ( phone [ num ] [ kaisuu - 1 ] , end = "" )	print ( phone [ num ] [ u ] [ k - 1 ] , end = "" ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 v 、 e 、 a 、 b とする	n , v , e , a , b = map ( int , input ( ) . split ( ) )	n , a , b , e , v = map ( int , input ( ) . split ( ) ) <eos>
x を パラメータ として x の先頭 を返す 関数を キー として dist _ from _ 0 の キーと値 の集まり を ソート した 列 を sorted _ dist とする	sorted_dist = sorted ( dist_from_0 . items ( ) , key = lambda x : x [ 0 ] )	dist_from_0 = sorted ( dist . items ( ) , key = lambda x : x [ 0 ] ) <eos>
0 から 10 未 満 までの 数 列 を 順に step として 、 繰 り 返す	for step in range ( 10 ) :	for step in range ( 10 ) : <eos>
0 を sum _ an s とする	sum_ans = 0	sum_ans = 0 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ a 、 b 、 c 、 d 、 e 、 f 、 g 、 h とする	a , b , c , d , e , f , g , h = map ( float , input ( ) . split ( ) )	a , b , c , d , e , f , g , h , g , g , g = map ( float , input ( ) . split ( ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ b 、 m 、 e とする	b , m , e = map ( int , input ( ) . split ( ) )	b , e , m = map ( int , input ( ) . split ( ) ) <eos>
ソートされた 順序 を 保 った まま n を a に 挿入 できる 位置 を x とする	x = bisect . bisect_left ( a , n )	x = bisect . bisect_left ( a , n ) <eos>
p a int ( i , j ) 、 re t val の 最小 値を re t val とする	retval = min ( paint ( i , j ) , retval )	retval = min ( min ( bp , j ) , retval ) <eos>
n が 10 より大きく または s が v min の n 番目 より 小さく または s が v max の n 番目 より大きい とき 、 <blk> 0 を an s とする </blk>	if n > 10 or s < vmin [ n ] or s > vmax [ n ] : <blk> ans = 0 </blk>	if n > 10 or s > vmax [ n ] or ans > ans [ 0 ] : <blk> ans = 0 </blk> <eos>
a に b を 掛け た 値を x とする	x = a * b	x = a * b <eos>
0 から MAX 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 偽 の 列 を t prime s とする	tprimes = [ False for i in range ( MAX ) ]	<unk> = [ False for i in range ( MAX ) ] <eos>
s a が 0 より大きく かつ s b が 0 より大きく または s a が 0 より 小さく かつ s b が 0 より小さい かどうか を返す	return ( sa > 0 and sb > 0 ) or ( sa < 0 and sb < 0 )	return sa > 0 and sb < 0 and sb < 0 and sb < 0 <eos>
s m 、 x * b に y * p を加え た 値に 4 を 掛け た 値を 5 で 割 った 商 の 最小 値 を出力する	print ( min ( sm , ( ( x * b + y * p ) * 4 ) // 5 ) )	print ( min ( s , ( x * b + y * p * 4 // 5 ) ) ) <eos>
改行 せずに " parent key = {} , " を 書式 として node s の parent _ id x から 1 を 引 いた 値 番目 で 整 形 した 文字列 を出力する	print ( "parent key = {}, " . format ( nodes [ parent_idx - 1 ] ) , end = "" )	print ( "node <unk> key = {}, " . format ( nodes [ right_idx - 1 ] ) , end = "" ) <eos>
m の 長さ を 2 で 割 った 余 り が 1 と 等しい とき 、	if len ( m ) % 2 == 1 :	if len ( m ) % 2 == 1 : <eos>
s を n を 10 で 割 った 余 り だけ 増加 させる	s += n % 10	s += n % 10 <eos>
A の i に 2 を 掛け た 値に 1 を加え た 値 番目 、 A の i に 2 を 掛け た 値に 2 を加え た 値 番目の 最小 値を A の i 番目 にする	A [ i ] = min ( A [ i * 2 + 1 ] , A [ i * 2 + 2 ] )	A [ i ] = min ( A [ i * 2 + 1 ] , A [ i ] * A [ 2 ] ) <eos>
pro f it 、 r から min _ so _ f ar を 引 いた 値の 最大 値を pro f it とする	profit = max ( profit , r - min_so_far )	profit = max ( profit , <unk> - min_so_far ) <eos>
num を _ pow ( 10 , 44 ) で 割 った 余 り を num とする	num = num % _pow ( 10 , 44 )	num = num % _pow ( 10 , 44 ) <eos>
que の間 、 次 を 繰 り 返す	while que :	while que : <eos>
( 、 つまり 未 定 値 ) からなる 列 の M 回 分 の 列 を U とする	U = [ None ] * M	U = [ None ] * M <eos>
0 を i j とする	ij = 0	j = 0 <eos>
p 、 diff を id 、 v min とする	id , vmin = p , diff	id , vmin = p , id <eos>
0 を step とする	step = 0	step = 0 <eos>
k から 1 を 引 いた 値を 1 だけ 右 シフト した 値を k とする	k = ( k - 1 ) >> 1	k = ( k - 1 ) >> 1 <eos>
N の l 番目 を "," で 分割 した 字句 列 を data とする	data = N [ l ] . split ( "," )	data = N [ l ] . split ( "," ) <eos>
Py に 2 に Q y を 掛け た 値 を加え た 値を 3 で 割 った 値を By とする	By = ( Py + 2 * Qy ) / 3	<unk> = ( <unk> + 2 * y ) / 3 <eos>
0 を c n t 3 とする	cnt3 = 0	cnt3 = 0 <eos>
t _ w 、 m w _ b に a d j の i 番目の j 番目 を加え た 値の 最小 値を m w の t _ b 番目 にする	mw [ t_b ] = min ( t_w , mw_b + adj [ i ] [ j ] )	mw [ t_b ] = min ( min_w , b_w + b [ j ] ) <eos>
x を w inner とする	winner = x	winner = x <eos>
height が y 以上の とき 、	if height >= y :	if height >= y : <eos>
0 が row 2 以下 かどうか が H より 小さく かつ 0 が c ol 2 以下 かどうか が W より 小さく かつ g r id の row 2 番目の c ol 2 番目 が color と 等しい とき 、	if 0 <= row2 < H and 0 <= col2 < W and grid [ row2 ] [ col2 ] == color :	if 0 <= row2 < H and 0 <= row2 < W and grid [ row2 ] [ row2 ] == color [ row2 ] : <eos>
f ab の各要素 に sum を 適用 した 列 の 総 和 を s とする	s = sum ( map ( sum , fab ) )	s = sum ( map ( sum , fab ) ) <eos>
s z を n とする	n = sz	n = sz <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ S x 、 S y 、 S z とする	Sx , Sy , Sz = map ( int , f_i . readline ( ) . split ( ) )	S , x , y , S = map ( int , f_i . readline ( ) . split ( ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 浮動小数点数の 列 を 展開 し 、 それぞれ x 1 、 y 1 、 x 2 、 y 2 、 x 3 、 y 3 とする	x1 , y1 , x2 , y2 , x3 , y3 = [ float ( _ ) for _ in input ( ) . split ( ) ]	x1 , y1 , x2 , y2 , x3 , y3 = [ float ( _ ) for _ in input ( ) . split ( ) ] <eos>
A の l の 1 番目の 整数値 番目の 末尾に l の 2 番目 を追加する	A [ int ( l [ 1 ] ) ] . append ( l [ 2 ] )	A [ l ] . append ( int ( l [ 1 ] ) ) <eos>
0 から m 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 入力された 文字列の 整数値 の 列 のリスト を P とする	P = list ( [ int ( input ( ) ) for _ in range ( m ) ] )	P = list ( [ int ( input ( ) ) for _ in range ( m ) ] ) <eos>
s の 長さが 6 より小さい とき 、	if len ( s ) < 6 :	if len ( s ) < 6 : <eos>
a を 60 で 割 った 値を 60 で 割 った 余 り の 整数値 を m とする	m = int ( ( a / 60 ) % 60 )	m = int ( a % 60 ) <eos>
m が l と 等 し く かつ m x が d x より 小さく または m が l より小さい とき 、 <blk> l 、 d x 、 d y を m 、 m x 、 my とする </blk>	if ( m == l and mx < dx ) or m < l : <blk> m , mx , my = l , dx , dy </blk>	if m == l and x < m and x < d or y , l , m = d , l , x </blk> <eos>
0.5 に a を 掛け た 値に b を 掛け た 値に C の 正 弦 を 掛け た 値を S とする	S = 0.5 * a * b * math . sin ( C )	S = 0.5 * a * b * math . sin ( C ) <eos>
char が '@' と 等しくない とき 、	if char != '@' :	if char != '@' : <eos>
r を p とする	p = r	p = r <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ op 、 x とする	op , x = map ( int , f_i . readline ( ) . split ( ) )	op , x = map ( int , f_i . readline ( ) . split ( ) ) <eos>
1 を v の i を j で 割 った 商 を A で 割 った 余 り 番目 にする	v [ ( i // j ) % A ] = 1	v [ i // A ] = 1 <eos>
R M Q ( n + 1 ) を r m q とする	rmq = RMQ ( n + 1 )	aqr = <unk> ( n1 + 1 ) <eos>
r の 長さが 0 より大きく かつ r の 0 番目 が " X " と 等しい 間 、 次 を 繰 り 返す	while len ( r ) > 0 and r [ 0 ] == "X" :	while len ( r ) > 0 and r [ 0 ] == "X" : <eos>
key が d に 含まれない とき 、	if not key in d :	if key not in d : <eos>
readline ( )	readline ( )	readline ( ) <eos>
f ab の y に d y の i 番目 を加え た 値に 2 を加え た 値 番目の x に d x の i 番目 を加え た 値に 2 を加え た 値 番目 を 1 だけ 増加 させる	fab [ y + dy [ i ] + 2 ] [ x + dx [ i ] + 2 ] += 1	fab [ y + d [ i + 2 ] [ x + 1 ] += d [ i + 2 ] <eos>
q の 0 番目 が " IN " と 等しい とき 、	if q [ 0 ] == "IN" :	if q [ 0 ] == "insert" : <eos>
self . cross ( vec _ p t 1 _ to _ p t ) を cross とする	cross = self . cross ( vec_pt1_to_pt )	cross = self . cross ( vec_pt1_to_pt ) <eos>
1 から table の i 番目の j に 1 を加え た 値 番目 を 引 いた 値を table の i 番目の j に 1 を加え た 値 番目 にする	table [ i ] [ j + 1 ] = 1 - table [ i ] [ j + 1 ]	table [ i ] [ j ] = 1 - table [ i + 1 ] [ j ] <eos>
arr の 1 番目の y 番目の とき 、 <blk> 繰り返し を 中断 する </blk>	if arr [ 1 ] [ y ] : <blk> break </blk>	if arr [ 1 ] [ y ] : <blk> break </blk> <eos>
a の r 番目 を x とする	x = a [ r ]	x = a [ r ] <eos>
- d の j 番目 、 u の j 2 番目の 最小 値に d y の dir 番目 を加え た 値を u の j 2 番目 にする	u [ j2 ] = min ( - d [ j ] , u [ j2 ] ) + dy [ dir ]	d [ j2 ] = min ( - min ( - d [ j ] , u [ j2 ] ) + dy [ dir ] ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ a 、 f の i 番目の 先頭 、 b 、 f の i 番目の 1 番目 とする	a , f [ i ] [ 0 ] , b , f [ i ] [ 1 ] = map ( int , input ( ) . split ( ) )	a , b [ i ] [ 0 ] , f [ i ] [ 1 ] , f [ i ] = map ( int , input ( ) . split ( ) ) <eos>
N の l 番目 を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ p 、 q とする	p , q = [ int ( i ) for i in N [ l ] . split ( ) ]	p , q = [ int ( i ) for i in N [ l ] . split ( ) ] <eos>
偽 を map _ in p の y 番目の x 番目 にする	map_inp [ y ] [ x ] = False	map_inp [ y ] [ x ] = False <eos>
s z を j とする	j = sz	j = sz <eos>
an s の 末尾に day を追加する	ans . append ( day )	ans . append ( day ) <eos>
f の i 番目の j 番目 が 、 つまり 真 と 等しい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if f [ i ] [ j ] == True : <blk> continue </blk>	if f [ i ] [ j ] == True : <blk> continue </blk> <eos>
in P has e ( top )	inPhase ( top )	inPhase ( top ) <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を 展開 し 、 それぞれ a 、 b 、 c 、 d とする	a , b , c , d = list ( map ( int , input ( ) . split ( ',' ) ) )	a , b , c , d = list ( map ( int , input ( ) . split ( ',' ) ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 のリスト を A とする	A = list ( input ( ) . split ( ) )	A = list ( input ( ) . split ( ) ) <eos>
0 を k 1 とする を c n t とする	cnt = k1 = 0	cnt = 0 cnt = 1 <eos>
s p e ed 、 s to c k 、 U 、 K 、 i 、 T 、 a c c el _ time は グローバル変数 とする	global speed , stock , U , K , i , T , accel_time	global speed , K , accel_time , T , <unk> , <unk> , <unk> , <eos>
\\\\\ ' ABCDEFG HI J K L M NOP Q R STU V W XYZ ' に ' . , - \\\\ \\\\ ' ? ' を加え た 値を en とする \\\\\	\\\\\en = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + ' .,-\\\\\\\\'?'\\\\\	<unk> = <unk> + " <unk> <eos>
self の FLAGS を self の Ma s k s の m 番目 と の 論理和 にする	self . FLAGS | = self . Masks [ m ]	self . FLAGS | = self . Masks [ m ] <eos>
num s を ソート する	nums . sort ( )	nums . sort ( ) <eos>
1 から 10 未 満 までの 数 列 の各要素 を j と し 、 j から j に 5 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 i の 列 の 列 を str a ight とする	straight = [ [ i for i in range ( j , j + 5 ) ] for j in range ( 1 , 10 ) ]	<unk> = [ [ a for i in range ( 1 , 5 + i ) ] for j in range ( 1 , 10 ) ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を arr 2 とする	arr2 = list ( map ( int , input ( ) . split ( ) ) )	arr2 = list ( map ( int , input ( ) . split ( ) ) ) <eos>
_ pi の先頭 を tmp とする	tmp = _pi [ 0 ]	tmp = _pi [ 0 ] <eos>
i の 整数値 を i とする	i = int ( i )	i = int ( i ) <eos>
を s _ out とする	s_out = ""	outs = "" <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ W 、 H とする	W , H = map ( int , file_input . readline ( ) . split ( ) )	W , H = map ( int , file_input . readline ( ) . split ( ) ) <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 1 の 列 を x とする	x = [ 1 for i in range ( n ) ]	x = [ 1 for i in range ( n ) ] <eos>
end を 1 だけ 増加 させる	end += 1	end += 1 <eos>
i が w より小さい 間 、 次 を 繰 り 返す	while i < w :	while i < w : <eos>
d f s ( i + 1 , t , s ) で ないとき 、	if not dfs ( i + 1 , t , s ) :	if not dfs ( i + 1 , t , s ) : <eos>
q s の 長さ を L とする	L = len ( qs )	L = len ( sq ) <eos>
datetime 、 y 1 、 m 1 、 d 1 の 日付 を date 1 とする	date1 = datetime . date ( y1 , m1 , d1 )	date = datetime . date ( y1 , m1 , d1 ) <eos>
gen g o ( y , m , d ) を出力する	print ( gengo ( y , m , d ) )	print ( <unk> ( y , m , d ) ) <eos>
a の b から 1 を 引 いた 値 番目の f から 1 を 引 いた 値 番目の r から 1 を 引 いた 値 番目 を v だけ 増加 させる	a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v	a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <eos>
i の文字列 において 正規表現 start _ pos が 最初 にマッチする 位置 を 展開 し 、 それぞれ start _ pos 、 t とする	start_pos , t = search ( start_pos , str ( i ) )	<unk> , <unk> = "" . join ( map ( <unk> , start ) ) <eos>
0 から 1000 未 満 までの 数 列 を 順に c n t として 、 繰 り 返す	for cnt in range ( 1000 ) :	for cnt in range ( 1000 ) : <eos>
入力された 文字列を " " で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ N 、 W とする	N , W = [ int ( i ) for i in input ( ) . split ( " " ) ]	W , W = [ int ( i ) for i in input ( ) . split ( " " ) ] <eos>
a mi da の 末尾に i を追加する	amida . append ( i )	amida . append ( i ) <eos>
空 列 を f l _ h t とする	fl_ht = [ ]	fl_ht = [ ] <eos>
total を N で 割 った 値の 切り 上 げ 整数値 を出力する	print ( math . ceil ( total / N ) )	print ( math . ceil ( total / N ) ) <eos>
0 を V の v 2 番目 にする	V [ v2 ] = 0	V [ v2 ] = 0 <eos>
N の 長さが 1 以下の とき 、	if len ( N ) <= 1 :	if len ( N ) <= 1 : <eos>
r を 1 だけ 減 少 させる 0 を c とする	r -= 1 c = 0	r = r -= 1 c -= 0 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ p 、 d 1 、 d 2 とする	p , d1 , d2 = map ( int , input ( ) . split ( ) )	p , d1 , d2 = map ( int , input ( ) . split ( ) ) <eos>
S M E ( N ) を answer とする	answer = SME ( N )	answer = <unk> ( N ) <eos>
f ibonacci ( f , n -2 ) に f ibonacci ( f , n -1 ) を加え た 値を f の n 番目 にする	f [ n ] = fibonacci ( f , n - 2 ) + fibonacci ( f , n - 1 )	f [ n ] = fibonacci ( f ( n , f ( n - 2 ) + 1 , f ) <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を a とする </blk>	try : <blk> a = input ( ) </blk>	try : <blk> a = input ( ) </blk> <eos>
x の i 番目 から 200 00 未 満 までの x の i 番目 間 隔 の数 列 を 順に j として 、 繰 り 返す	for j in range ( x [ i ] , 20000 , x [ i ] ) :	for j in range ( x [ i ] , 200 , x [ i ] ) : <eos>
to w n _ map の 先頭から ' S ' を探し て 見つかった 位置 を start _ pos とする	start_pos = town_map . find ( 'S' )	<unk> = town_map . find ( to_base ) <eos>
0 から 10 未 満 までの 数 列 のリスト を num s とする	nums = list ( range ( 10 ) )	nums = list ( range ( 10 ) ) <eos>
1000 から 、 つまり 入力された 文字列の 整数値 を 引 いた 値を m とする	m = 1000 - int ( input ( ) )	m = 1000 - int ( input ( ) ) <eos>
X に Y を加え た 値に 2 を加え た 値を v _ num とする	v_num = X + Y + 2	v_num = X + Y + 2 <eos>
p o を追加して tb l を拡張する	tbl . extend ( po )	tbl . extend ( p ) <eos>
string の位置 pos に 1 を加え た 値 から pattern を探し て 見つかった 位置 を pos とする	pos = string . find ( pattern , pos + 1 )	pos = string . find ( pos + 1 ) <eos>
H の浮動小数点数 を h とする	h = float ( H )	h = float ( H ) <eos>
l c が -1 と 等しくない とき 、	if lc != - 1 :	if lcm != - 1 : <eos>
0 から str _ org の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( str_org ) ) :	for i in range ( len ( str_org ) ) : <eos>
a の各要素 に 整数 を 適用 した 列 のリスト を d とする	d = list ( map ( int , a ) )	d = list ( map ( int , a ) ) <eos>
( an s 、 i ) からなる 列 を返す	return [ ans , i ]	return [ ans , i ] <eos>
S の 長さが 0 より大きい 間 、 次 を 繰 り 返す	while len ( S ) > 0 :	while len ( S ) > 0 : <eos>
A の先頭に q の 4 番目 から 、 つまり 末 尾 までの 部分 列 を追加する	A . appendleft ( q [ 4 : ] )	A [ 0 : ] . appendleft ( q [ 4 : ] ) <eos>
an s 、 an s の先頭 を 除 いた 部分 列 の 要素を それぞれ 組 に した 列 を 順に s 、 t として 、 繰 り 返す	for s , t in zip ( ans , ans [ 1 : ] ) :	for s , t in zip ( ans , ans [ 1 : ] ) : <eos>
k を p で 割 った 余 り が 0 と 等しい とき 、	if k % p == 0 :	if k % p == 0 : <eos>
In order を出力する	print ( "Inorder" )	In_order ( order ) <eos>
0 を an s 1 とする	ans1 = 0	ans1 = 0 <eos>
Point ( c , d ) を self の p 2 にする	self . p2 = Point ( c , d )	self . p2 = Point ( c , d ) <eos>
node _ id が -1 と 等しくない とき 、	if node_id != - 1 :	if node_id != - 1 : <eos>
0 から k から i を 引 いた 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( k - i ) :	for j in range ( k - i ) : <eos>
を 間 に入れ て A を 連結 した 文字列 を出力する	print ( " " . join ( A ) )	print ( " " . join ( A ) ) <eos>
set _ tmp _ list を 順に set _ tmp として 、 繰 り 返す	for set_tmp in set_tmp_list :	for set_tmp_list in set_tmp_list : <eos>
list _ m を ソート する	list_m . sort	list_m . sort ( ) <eos>
bisect or ( p [ i ] , p [ j ] ) を s eg とする	seg = bisector ( p [ i ] , p [ j ] )	seg = bisect ( p [ i ] , p [ j ] ) <eos>
S の i 番目 を S i とする	Si = S [ i ]	S = S [ i ] <eos>
pre v _ f a ce s の pre v _ f 番目 を self の f _ keys の next _ f 番目 にする	self . f_keys [ next_f ] = prev_faces [ prev_f ]	self . f_keys [ face ] = prev_faces <eos>
2 から 18 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 2 , 18 ) :	for i in range ( 2 , 18 ) : <eos>
dec s の 末尾に d の文字列 を追加する	decs . append ( str ( d ) )	decs . append ( str ( d ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を y とする	y = list ( map ( int , input ( ) . split ( ) ) )	y = list ( map ( int , input ( ) . split ( ) ) ) <eos>
extended _ g cd ( a , b ) を展開し 、 それぞれ g 、 x 、 y とする	g , x , y = extended_gcd ( a , b )	g , x , y = <unk> ( a , b ) <eos>
List の i 番目 が i に 1 を加え た 値 と 等しくない とき 、	if List [ i ] != i + 1 :	if List [ i ] != 1 + 1 : <eos>
a に b を加え た 値の 文字列の長さ を出力する	print ( len ( str ( a + b ) ) )	print ( len ( str ( len ( a + b ) ) ) ) <eos>
% . 10 f を box の 総 和 を n で 割 った 値の 0.5 乗 で 割 った 余 り を出力する	print ( "%.10f" % ( ( sum ( box ) / n ) ** 0.5 ) )	print ( "%.8f" % sum ( box ) ** 0.5 ) <eos>
heapq モジュール を用い る	from heapq import	from heapq import heappush , heappop , heappush <eos>
q の 末尾に q の先頭 を取り出し た 値に q の先頭 を取り出し た 値 を加え た 値 を追加する	q . append ( q . pop ( ) + q . pop ( ) )	q . append ( q . pop ( ) + q . pop ( ) ) <eos>
s を parent の t 番目 にする	parent [ t ] = s	parent [ t ] = s <eos>
k p r v を返す	return kprv	return kprv <eos>
H が W と 等しい かどうか が 0 と 等しい とき 、	if H == W == 0 :	if H == W == 0 : <eos>
operation の 末尾に ( m q 、 v ) の 組 を追加する	operation . append ( ( mq , v ) )	operation . append ( ( m , v ) ) <eos>
mk の a から 1 を 引 いた 値 番目 または mk の b から 1 を 引 いた 値 番目の とき 、	if mk [ a - 1 ] or mk [ b - 1 ] :	if mk [ a - 1 ] or mk [ b - 1 ] [ 1 ] : <eos>
を parent とする	parent = ""	parent = "" <eos>
a を ( 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト ) からなる 列 だけ 増加 させる	a += [ list ( map ( int , input ( ) . split ( ) ) ) ]	a += [ list ( map ( int , input ( ) . split ( ) ) ) ] <eos>
y が 0 と 等しい とき 、	if y == 0 :	if y == 0 : <eos>
A の 1 番目 から 、 つまり 末 尾 までの 部分 列 に ( 0 ) からなる 列 を加え た 値を 順に a として 、 繰 り 返す	for a in A [ 1 : ] + [ 0 ] :	for a in [ 1 : ] + [ 0 ] : <eos>
x に y を 掛け た 値 、 x に 2 を 掛け た 値に y に 2 を 掛け た 値 を加え た 値 を出力する	print ( x * y , x * 2 + y * 2 )	print ( x * y , 2 * x + 2 * y ) <eos>
s _ c から l を 引 いた 値を c 1 とする	c1 = s_c - l	c1 = <unk> - l <eos>
辞書 の値 の集まり のリスト を l とする	l = list ( dict . values ( ) )	l = list ( Counter ( Counter ( ) ) ) <eos>
num を _ pow ( 10 , 52 ) で 割 った 余 り を num とする	num = num % _pow ( 10 , 52 )	num = num % _pow ( 10 , 52 ) <eos>
p を 1 だけ 増加 させる	p += 1	p += 1 <eos>
r o ar の i 番目 が ' w ' と 等しい とき 、 <blk> i を 1 だけ 増加 させる </blk>	if roar [ i ] == 'w' : <blk> i += 1 </blk>	if roar [ i ] == <unk> : <blk> i += 1 </blk> <eos>
入力された 文字列を r o ar とする	roar = input ( )	roar = input ( ) <eos>
i を Y の X の i 番目 番目 にする	Y [ X [ i ] ] = i	X [ i ] = i <eos>
line を ', ' で 分割 した 字句 列 を line とする	line = line . split ( ',' )	line = line . split ( ',' ) <eos>
-1 を root _ node _ no とする	root_node_no = - 1	root_node_no = - 1 <eos>
defaultdict ( int ) を P とする	P = defaultdict ( int )	P = defaultdict ( int ) <eos>
full h ous e を返す	return "full house"	return "full house" <eos>
c を a で 割 った 余 り が 0 と 等しい とき 、	if c % a == 0 :	if c % a == 0 : <eos>
file _ input から 読み込んだ 一行 を Q とする	Q = file_input . readline ( )	Q = file_input . readline ( ) <eos>
i が half 以下の とき 、	if i <= half :	if i <= <unk> : <eos>
s hop の 末尾に d を追加する	shop . append ( d )	shop . append ( d ) <eos>
( 0 ) からなる 列 の n 回 分 の 列 の各要素 を _ と し 、 score ( list ( map ( int , input ( ) . split ( ) ) ) ) の 列 を ソート した 列 を A とする	A = sorted ( [ score ( list ( map ( int , input ( ) . split ( ) ) ) ) for _ in [ 0 ] * n ] )	A = sorted ( [ list ( map ( int , input ( ) . split ( ) ) for _ in [ 0 ] * n ) ] ) <eos>
s 内の ' X ' を x の 文字列で 置き換え た 文字列を ns とする	ns = s . replace ( 'X' , str ( x ) )	ns = s . replace ( 'X' , str ( x ) ) <eos>
file _ input から 読み込んだ 一行 を p とする	p = file_input . readline ( )	p = file_input . readline ( ) <eos>
( 、 つまり 偽 ) からなる 列 の size 回 分 の 列 を is _ v is it ed とする	is_visited = [ False ] * size	is_visited = [ False ] * size <eos>
g 2 の 末尾に P l a y er ( p , t ) を追加する	g2 . append ( Player ( p , t ) )	g2 . append ( Player ( p , t ) ) <eos>
0 から e 未 満 までの 数 列 を 順に _ として 、 繰 り 返す	for _ in range ( e ) :	for _ in range ( e ) : <eos>
1 から n の 0.5 乗 の 整数値 に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , int ( n ** 0.5 ) + 1 ) :	for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <eos>
r を i から 1 を 引 いた 値 から p を 引 いた 値 だけ 増加 させる	r += ( i - 1 ) - p	r += i - 1 <eos>
bits と 1 を j だけ 左 シフト した 値の 論理 積 の とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if bits & ( 1 << j ) : <blk> continue </blk>	if bits & ( 1 << j ) : <blk> continue </blk> <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ H 、 W とする	H , W = map ( int , f_i . readline ( ) . split ( ) )	H , W = map ( int , f_i . readline ( ) . split ( ) ) <eos>
n に n から 1 を 引 いた 値を 掛け た 値を 2 で 割 った 値の 整数値 を m とする	m = int ( n * ( n - 1 ) / 2 )	m = int ( ( n * ( n - 1 ) / 2 ) ) <eos>
data の 最大 値 から data の 最小 値を 引 いた 値 を出力する	print ( max ( data ) - min ( data ) )	print ( max ( data ) - min ( data ) ) <eos>
0 から MAX 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 真 の 列 を prime とする	prime = [ True for i in range ( MAX ) ]	prime = [ True for i in range ( MAX ) ] <eos>
p o ly g on の i 番目の 先頭 、 p o ly g on の i 番目の 1 番目 を x 1 、 y 1 とする	x1 , y1 = polygon [ i ] [ 0 ] , polygon [ i ] [ 1 ]	x1 , y1 = polygon [ i ] [ 0 ] , polygon [ i ] [ 1 ] <eos>
'' を 間 に入れ て s の逆 順 を 連結 した 文字列の 整数値 から '' を 間 に入れ て s を 連結 した 文字列の 整数値 を 引 いた 値 を出力する	print ( int ( '' . join ( s [ : : - 1 ] ) ) - int ( '' . join ( s ) ) )	print ( int ( '' . join ( s [ : : - 1 ] ) - int ( '' . join ( s ) ) ) ) <eos>
99 000 01 を min cos t とする	mincost = 9900001	mincost = <unk> <eos>
un check ed の r 番目の とき 、	if unchecked [ r ] :	if unchecked [ r ] : <eos>
pip を self の pip にする	self . pip = pip	self . pip = pip <eos>
line を 空白 で 分割 した 字句 列 の各要素 を x と し 、 x の 浮動小数点数の 列 を 展開 し 、 それぞれ a 、 b 、 c 、 d 、 e 、 f とする	a , b , c , d , e , f = [ float ( x ) for x in line . split ( ) ]	a , b , c , d , e , f = [ float ( x ) for x in line . split ( ) ] <eos>
x に 1 を加え た 値 、 y に 2 を加え た 値 、 depth に 1 を加え た 値 、 max _ depth において 正規表現 table が 最初 にマッチする 位置 の とき 、	if search ( table , x + 1 , y + 2 , depth + 1 , max_depth ) :	if search ( table , x + 1 , y + 2 , depth + 1 , max_depth ) : <eos>
li の 末尾に n を追加する	li . append ( n )	li . append ( n ) <eos>
column の先頭 を返す	return column [ 0 ]	return column [ 0 ] <eos>
i に 1 を加え た 値 から d s の 長さ 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( i + 1 , len ( ds ) ) :	for j in range ( i + 1 , len ( s ) ) : <eos>
even の先頭 、 even の 1 番目 、 odd の先頭 を e 1 、 e 2 、 o 1 とする	e1 , e2 , o1 = even [ 0 ] , even [ 1 ] , odd [ 0 ]	e1 , e2 , e3 = even [ 0 ] , even [ 1 ] <eos>
x に d に arg の ラジアン の 余 弦 を 掛け た 値 を加え た 値を x とする	x = x + d * math . cos ( math . radians ( arg ) )	x = x + math . radians ( d ) * cos ( arg ) <eos>
an s を N を k で 割 った 商 だけ 増加 させる	ans += N // k	ans += N // k <eos>
c _ m を 順に c として 、 繰 り 返す	for c in c_m :	for c in <unk> : <eos>
line を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ i 、 j とする	i , j = map ( int , line . split ( ) )	i , j = map ( int , line . split ( ) ) <eos>
0 から N 未 満 までの 数 列 の各要素 を i と し 、 readline ( ) の 両端 から 空白 改行 を取り 除 いた 文字列の 列 を S とする	S = [ readline ( ) . strip ( ) for i in range ( N ) ]	S = [ readline ( ) . strip ( ) for i in range ( N ) ] <eos>
p x の 2 乗 に py の 2 乗 を加え た 値の 0.5 乗 を OP とする	OP = ( px ** 2 + py ** 2 ) ** 0.5	= ( ( px ** 2 + py ** 2 ) ** 0.5 ) <eos>
t 1 を展開し 、 それぞれ G _ i 、 ar _ i 、 a c _ i 、 a c _ 1 i とする	G_i , ar_i , ac_i , ac_1i = t1	<unk> , <unk> , <unk> , <unk> = t1 <eos>
Q の cur 番目 を cur とする	cur = Q [ cur ]	cur = Q [ cur ] <eos>
入力された 文字列の 整数値 を p 2 とする	p2 = int ( input ( ) )	p2 = int ( input ( ) ) <eos>
S を展開し て を出力する	print ( * S )	print ( * S ) <eos>
x j から x 1 を 引 いた 値を d x 1 とする y j から y 1 を 引 いた 値を d y 1 とする	dx1 = xj - x1 dy1 = yj - y1	dx1 = xj - x1 dy1 = yj - y1 <eos>
s の 長さが 1 より大きい とき 、 <blk> s の先頭 を c とする <sep> s の 1 番目 を d とする </blk>	if len ( s ) > 1 : <blk> c = s [ 0 ] <sep> d = s [ 1 ] </blk>	if len ( s ) > 1 : <blk> s = s [ 1 ] <sep> d = s [ 1 ] </blk> <eos>
i を 3 で 割 った 余 り が 0 と 等 し く または str _ i の 先頭から ' 3 ' を探し て 見つかった 位置 が -1 と 等しくない とき 、	if i % 3 == 0 or str_i . find ( '3' ) != - 1 :	if i % 3 == 0 or '3' != - 1 : <eos>
c ir c les の 2 個 までの コン ビ ネ ーション を 順に c 1 、 c 2 として 、 繰 り 返す	for c1 , c2 in combinations ( circles , 2 ) :	for c1 , c2 in combinations ( circles , 2 ) : <eos>
B を X の末尾 の -1 番目 にする	X [ - 1 ] [ - 1 ] = B	X [ - 1 ] = B [ - 1 ] <eos>
B の 、 つまり ソートされた 順序 を 保 った まま i を B に 挿入 できる 位置 番目 が i と 等しい とき 、 <blk> " yes " を出力する </blk>	if B [ bisect_left ( B , i ) ] == i : <blk> print ( "yes" ) </blk>	if B [ bisect . bisect_left ( B , i ) == "B" : <blk> print ( "yes" ) </blk> <eos>
decode d を返す	return decoded	return decoded <eos>
d p の k 番目の n 番目 を出力する	print ( dp [ k ] [ n ] )	print ( dp [ k ] [ n ] ) <eos>
f _ i から 読み込んだ 一行 の末尾 から 空白 改行 を取り 除 いた 文字列を '0' で 分割 した 字句 列 を code とする	code = f_i . readline ( ) . rstrip ( ) . split ( '0' )	code = f_i . readline ( ) . rstrip ( ) . split ( ) <eos>
a 、 c から b を 引 いた 値の 最大 値 、 b 、 c の 最小 値を a 、 b とする	a , b = max ( a , c - b ) , min ( b , c )	a , b = min ( a , max ( b - c ) , c ) <eos>
tb l の 末尾に ( name 、 i 、 3 に w の 整数値 を 掛け た 値に d の 整数値 を加え た 値 ) からなる 列 を追加する	tbl . append ( [ name , i , 3 * int ( w ) + int ( d ) ] )	tbl . append ( [ name , int ( w ) , int ( d ) , int ( d ) ] ) <eos>
l が h 以下 かつ a の l 番目 が a の i 番目 より大きい とき 、	if l <= h and a [ l ] > a [ i ] :	if l <= h and a [ l ] > a [ i ] : <eos>
beta を key B とする	keyB = beta	<unk> = <unk> <eos>
s n ake の i 番目 から i に 2 を加え た 値 までの 部分 列 が ' oo ' と 等しい とき 、	if snake [ i : i + 2 ] == 'oo' :	if <unk> [ i : i + 2 ] == <unk> : <eos>
L から 6 を 引 いた 値 から -1 未 満 までの -1 間 隔 の数 列 を 順に j として 、 繰 り 返す	for j in range ( L - 6 , - 1 , - 1 ) :	for j in range ( L - 6 , - 1 , - 1 ) : <eos>
0 から line の 長さ 未 満 までの 数 列 を 順に l として 、 繰 り 返す	for l in range ( len ( line ) ) :	for l in range ( len ( line ) ) : <eos>
set _ attributes ( l c , n _ i , rc , depth + 1 ) に 1 を加え た 値を h 1 とする	h1 = set_attributes ( lc , n_i , rc , depth + 1 ) + 1	h1 = <unk> ( n , rc , depth + 1 , 1 ) + 1 <eos>
self . Find _ R o ot ( x ) が self . Find _ R o ot ( y ) と 等しい かどうか を返す	return self . Find_Root ( x ) == self . Find_Root ( y )	return self . Find_Root ( x ) == self . Find_Root ( y ) <eos>
cmath . phase ( c 1 c 2 ) を t とする	t = cmath . phase ( c1c2 )	t = cmath . phase ( c1 ) <eos>
s を c だけ 増加 させる	s += c	s += c <eos>
V ec t or ( p t _ m id , p t _ b ) を vec _ b とする	vec_b = Vector ( pt_mid , pt_b )	vec_b = Vector ( pt , pt ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ H 、 W とする	H , W = [ int ( i ) for i in input ( ) . split ( ) ]	H , W = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
i が L から 1 を 引 いた 値 と 等しい かどうか から 10 未 満 までの 数 列 を 順に b として 、 繰 り 返す	for b in range ( i == L - 1 , 10 ) :	for b in range ( i == L - 1 , 10 ) : <eos>
cp 1 から cp を 引 いた 値を t _ s 1 とする	t_s1 = cp1 - cp	str_tpl1 = cp1 - cp <eos>
f の a 番目 が 2 より大きい とき 、 <blk> 偽 を an s とする </blk>	if f [ a ] > 2 : <blk> ans = False </blk>	if f [ a ] > 2 : <blk> ans = False </blk> <eos>
( ( 0 、 0 ) の 組 、 ( X 、 Y から 1 を 引 いた 値 ) の 組 、 ( x 0 、 y 0 ) の 組 、 ( X から 1 を 引 いた 値 、 Y ) の 組 ) からなる 列 を an s とする	ans = [ ( 0 , 0 ) , ( X , Y - 1 ) , ( x0 , y0 ) , ( X - 1 , Y ) ]	ans = [ ( 0 , 0 ) , ( X - 1 ) , ( X - 1 , Y ) , ( y - 1 , 0 ) ] <eos>
( ( 0 、 0 ) の 組 ) からなる 列 を b とする 0 を j とする を i とする	b = [ ( 0 , 0 ) ] i = j = 0	b = [ ( 0 , 0 ) ] b = [ ( 0 , 0 ] <eos>
a の 7 番目 を出力する	print ( a [ 7 ] )	print ( a [ 7 ] ) <eos>
val が 0 より大きい とき 1 、 そうでなければ 2 を返す	return 1 if val > 0 else 2	return 1 if val > 0 else 2 <eos>
o 1 と o 2 の ユ ー ク リ ッ ド 距 離 が 2 より大きい とき 、	if dist ( o1 , o2 ) > 2 :	if dist1 ( o , 2 ) > dist2 ( <unk> ) : <eos>
m が 1 と 等しい とき 、	if m == 1 :	if m == 1 : <eos>
b が 1 000000 より大きい とき 、 <blk> 1 000000 を b とする </blk>	if b > 1000000 : <blk> b = 1000000 </blk>	if b > 1000000 : <blk> b = 1000000 </blk> <eos>
x _ list 、 x _ list の先頭 を 除 いた 部分 列 の 要素を それぞれ 組 に した 列 の各要素 を d 1 、 d 2 と し 、 d 2 から d 1 を 引 いた 値の 列 を dist ance とする	distance = [ d2 - d1 for d1 , d2 in zip ( x_list , x_list [ 1 : ] ) ]	distance = tuple ( [ 1 : - d1 , d2 for d1 in zip ( x2 , y2 ) ] ) <eos>
check ( k , f [ i ] [ 1 ] )	check ( k , f [ i ] [ 1 ] )	check ( k , f [ i ] [ 1 ] ) <eos>
in p を ソート する	inp . sort ( )	inp . sort ( ) <eos>
0 から n に 5 を加え た 値 未 満 までの 数 列 の各要素 を c と し 、 0 から n に 5 を加え た 値 未 満 までの 数 列 の各要素 を c と し 、 ' ' の 列 の 列 を a とする	a = [ [ ' ' for c in range ( n + 5 ) ] for c in range ( n + 5 ) ]	a = [ [ [ 'NO' for c in range ( 5 + a ) ] for c in range ( 5 + 5 ) ] <eos>
table の N 番目の N 番目 を table の i 番目の N 番目 だけ 増加 させる	table [ N ] [ N ] += table [ i ] [ N ]	table [ N ] [ N ] [ i ] += table [ N ] <eos>
max _ den s ity 、 line の 最大 値の 最大 値を max _ den s ity とする	max_density = max ( max_density , max ( line ) )	max_density = max ( max_density ) , max ( <unk> ) <eos>
vec _ p t 1 _ to _ p t . abs ( ) を返す	return vec_pt1_to_pt . abs ( )	return vec_pt1_to_pt . abs ( ) <eos>
a を 100 で 割 った 余 り を 10 で 割 った 商 が b を 1000 で 割 った 商 と 等 し く または a を 100 で 割 った 余 り を 10 で 割 った 商 が b を 1000 で 割 った 余 り を 100 で 割 った 商 と 等 し く または a を 100 で 割 った 余 り を 10 で 割 った 商 が b を 10 で	if ( a % 100 ) // 10 == b // 1000 or ( a % 100 ) // 10 == ( b % 1000 ) // 100 or ( a % 100 ) // 10 == b % 10 :	if a % 100 == b % 10 or a % 100 == b % 100 or a % 100 == b % 100 : <eos>
is S ol v ed ( board ) を出力する	print ( isSolved ( board ) )	print ( <unk> ( board ) ) <eos>
node s の id x 番目 を tmp とする	tmp = nodes [ idx ]	tmp = nodes [ idx ] <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ v _ num 、 e _ num とする	v_num , e_num = map ( int , file_input . readline ( ) . split ( ) )	v_num , <unk> = map ( int , file_input . readline ( ) . split ( ) ) <eos>
str _ org を 英 大文字 に変換し た 文字列 を出力する	print ( str_org . upper ( ) )	print ( str_org . upper ( ) ) <eos>
x に m v の i 番目の 先頭 を加え た 値 、 y に m v の i 番目の 1 番目 を加え た 値 、 z に m v の i 番目の 2 番目 を加え た 値を x x 、 y y 、 z z とする	xx , yy , zz = x + mv [ i ] [ 0 ] , y + mv [ i ] [ 1 ] , z + mv [ i ] [ 2 ]	x , y , z = x + mv [ i ] [ 0 ] , y + mv [ i ] [ x ] , z = x + mv [ i ] [ y ] [ i ] <eos>
tmp に pi を 掛け た 値を 1 80 . で 割 った 値を tmp とする	tmp = tmp * pi / 180 .	tmp = tmp * pi / 180 <eos>
0 を D の r 番目 にする	D [ r ] = 0	D [ r ] = 0 <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 0 から n 未 満 までの 数 列 の各要素 を _ と し 、 0 の 列 の 列 を mp とする	mp = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ]	mp = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] <eos>
a を f だけ 減 少 させる	a -= f	a -= f <eos>
A を C で 割 った 商 に 1 を加え た 値を K ok u g o とする	Kokugo = A // C + 1	Kokugo = A // C + 1 <eos>
time を l の i 番目の f にする	l [ i ] . f = time	l [ i ] . f = time <eos>
b low に 1 を加え た 値を b low とする	blow = blow + 1	blow = blow + 1 <eos>
cross ( base , h y p o 1 ) の 絶対値 を base の 絶対値 で 割 った 値を d 1 とする	d1 = abs ( cross ( base , hypo1 ) ) / abs ( base )	d1 = abs ( cross ( base , hypo1 ) ) / abs ( base ) <eos>
1 を t の a 35 に a 2 を 掛け た 値 番目 にする	t [ a35 * a2 ] = 1	t [ 2 * <unk> ] = 1 <eos>
入力された 文字列の 整数値 を n 1 とする	n1 = int ( input ( ) )	n1 = int ( input ( ) ) <eos>
0 を T とする	T = 0	T = 0 <eos>
整数の 逆 順 を出力する	print ( str [ : : - 1 ] )	print ( str ( len ( str ) ) [ : - 1 ] ) <eos>
2 から n の平方根 の 整数値 に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) :	for i in range ( 2 , int ( math . sqrt ( math . sqrt ( n ) ) + 1 ) ) : <eos>
m が 0 より大きい 間 、 次 を 繰 り 返す	while m > 0 :	while m > 0 : <eos>
入力された 文字列を " " で 分割 した 字句 列 を 展開 し 、 それぞれ name 、 time とする	name , time = input ( ) . split ( " " )	name , time = input ( ) . split ( " " ) <eos>
move の i 番目 を 順に j として 、 繰 り 返す	for j in move [ i ] :	for j in move [ i ] : <eos>
tb l の da 番目 を 順に k 、 t として 、 繰 り 返す	for k , t in tbl [ da ] :	for k , t in tbl [ k ] : <eos>
t a が C P _ a re a の i 番目 より小さい とき 、	if ta < CP_area [ i ] :	if ta < CP_area [ i ] : <eos>
an s 、 v 1 に r を加え た 値の 最小 値を an s とする	ans = min ( ans , v1 + r )	ans = min ( ans , v1 + rv ) <eos>
0 から N 未 満 までの 数 列 を 順に a として 、 繰 り 返す	for a in range ( N ) :	for a in range ( N ) : <eos>
' In order ' を出力する	print ( 'Inorder' )	print ( <unk> ) <eos>
b 、 c を出力する	print ( b , c )	print ( b , c ) <eos>
weights の 長さが 0 と 等しくない 間 、 次 を 繰 り 返す	while len ( weights ) != 0 :	while len ( weights ) != 0 : <eos>
r が a 以下 または b が l 以下の とき 、 <blk> self の inf を返す </blk>	if r <= a or b <= l : <blk> return self . inf </blk>	if r <= a or b <= l : <blk> return self . inf </blk> <eos>
0 から N 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( N ) :	for i in range ( N ) : <eos>
line の 両端 から 空白 改行 を取り 除 いた 文字列を ', ' で 分割 した 字句 列 の各要素 を _ と し 、 ID X の _ 番目の 列 を 展開 し 、 それぞれ a 、 b とする	a , b = [ IDX [ _ ] for _ in line . strip ( ) . split ( ',' ) ]	a , b , <unk> = [ a [ _ ] for _ in line . strip ( ) . split ( ',' ) ] <eos>
' le a f ' を self の type にする	self . type = 'leaf'	self . type = <unk> <eos>
w の 末尾に v w の 1 番目の 整数値 を追加する	w . append ( int ( vw [ 1 ] ) )	w . append ( int ( v [ w ] ) ) <eos>
p で ないとき 、	if not p :	if not p : <eos>
input _ command の 0 番目 が ' i ' と 等しい とき 、	if input_command [ 0 ] == 'i' :	if command [ 0 ] == 'i' : <eos>
groups の person 番目 を member 2 と の 論理和 にする	groups [ person ] | = member2	groups [ 2 ] | = <unk> <eos>
t の f ( b ) 番目 を 1 だけ 増加 させる t の f ( c ) 番目 を 1 だけ 減 少 させる	t [ f ( b ) ] += 1 t [ f ( c ) ] -= 1	t [ f ( b ) ] -= ( 1 ) [ t ] -= 1 <eos>
selection _ sort ( A ) を展開し 、 それぞれ A 、 swap s とする	A , swaps = selection_sort ( A )	A , swaps = <unk> ( A ) <eos>
a の 先頭から m を 引 いた 値を b とする	b = a [ 0 ] - m	b = a [ 0 ] - m <eos>
M の point 番目の i 番目 を D の i 番目 にする	D [ i ] = M [ point ] [ i ]	D [ i ] = M [ point ] [ i ] <eos>
0 から 8 未 満 までの 数 列 を 順に r として 、 繰 り 返す	for r in range ( 8 ) :	for r in range ( 8 ) : <eos>
v を self の value にする	self . value = v	self . value = v <eos>
rel ation s の start _ ver t ex 番目の キーと値 の集まり を 順に k 、 v として 、 繰 り 返す	for k , v in relations [ start_vertex ] . items ( ) :	for k , v in relations [ <unk> ] : <eos>
w w の浮動小数点数 を w とする	w = float ( ww )	w = float ( w ) <eos>
1 から q 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( 1 , q ) :	for k in range ( 1 , q ) : <eos>
an s を 順に i として 、 繰 り 返す	for i in ans :	for i in ans : <eos>
s の 先頭の 1 番目 を an s とする	ans = s [ 0 ] [ 1 ]	ans = s [ 0 ] [ 1 ] <eos>
order の 3 番目の リストを s の order の 1 番目の 整数値 から order の 2 番目の 整数値 に 1 を加え た 値 までの 部分 列 にする	s [ int ( order [ 1 ] ) : int ( order [ 2 ] ) + 1 ] = list ( order [ 3 ] )	s [ int ( order [ 3 ] ) : int ( order [ 1 ] ) + 1 ] = int ( order [ int ( order [ 3 ] ) ) <eos>
. を返す	return "."	return "." <eos>
b an は グローバル変数 とする	global ban	global ban <eos>
g から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( g , n ) :	for i in range ( g , n ) : <eos>
0 から MAX 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> tb l の i 番目 に 30 を 掛け た 値に 19 を加え た 値を tb l の i 番目 にする </blk>	for i in range ( MAX ) : <blk> tbl [ i ] = tbl [ i ] * 30 + 19 </blk>	for i in range ( MAX ) : <blk> tbl [ i ] = tbl [ <unk> * 30 + <unk> </blk> <eos>
b f s ( s ) を dist 0 とする	dist0 = bfs ( s )	dist = bfs ( 0 ) <eos>
文字 コード i の 文字 、 ":" 、 count _ char の i から 97 を 引 いた 値 番目 を出力する	print ( chr ( i ) , ":" , count_char [ i - 97 ] )	print ( chr ( i , ":" , <unk> [ i - ":" , deq ) ) <eos>
c x に x の nd 番目 を加え た 値を n x とする	nx = cx + x [ nd ]	nx = xc + x [ nd ] <eos>
p は グローバル変数 とする	global p	global p <eos>
0 、 真 を s 、 f とする	s , f = 0 , True	s , f = 0 , True <eos>
h の 2 乗 に x の 2 乗 を 4 で 割 った 値 を加え た 値 の平方根 を h _ x とする	h_x = math . sqrt ( h ** 2 + x ** 2 / 4 )	x = math . sqrt ( h ** 2 + x ** 2 / 4 ) <eos>
x を n x とする	nx = x	nx = x <eos>
board の 2 番目の 先頭 を返す	return board [ 2 ] [ 0 ]	return board [ 2 ] [ 0 ] <eos>
を key とする	key = ""	key = "" <eos>
find ( x , y + 1 , 0 , 0 , n ) を an s とする	ans = find ( x , y + 1 , 0 , 0 , n )	ans = find ( x , y + 1 , 0 , n ) <eos>
0 を c の i 番目の j 番目 にする	c [ i ] [ j ] = 0	c [ i ] [ j ] = 0 <eos>
k et a に 1 を加え た 値を k et a とする	keta = keta + 1	a = keta + 1 <eos>
sorted _ array の先頭 を min _ in _ array とする	min_in_array = sorted_array [ 0 ]	array_A = sorted_array [ 0 ] <eos>
空 辞書を co st _ dict とする	cost_dict = { }	cost_dict = { } <eos>
( ( 0 、 0 ) からなる 列 ) からなる 列 を p q とする	pq = [ [ 0 , 0 ] ]	pq = [ [ 0 , 0 ] ] <eos>
a を 36 0 だけ 増加 させる	a += 360	a += 360 <eos>
date が 18 68 09 08 より小さい とき 、	if date < 18680908 :	if date < 18680908 : <eos>
b を self の score にする	self . score = b	self . score = b <eos>
x が i と 等 し く かつ y が j と 等しい とき 、	if ( x == i and y == j ) :	if x == i and y == j : <eos>
f ence s の 末尾に ( f ence _ len 、 p 、 q ) の 組 を追加する	fences . append ( ( fence_len , p , q ) )	fences . append ( ( ( f_len , p , q ) ) <eos>
空 列 を line とする	line = [ ]	line = [ ] <eos>
root が 1 と 等しい とき 、 <blk> A  内の 0 と 等しい 要素を 取り除く </blk>	if root == 1 : <blk> A . remove ( 0 ) </blk>	if root == 1 : <blk> A . remove ( 0 ) </blk> <eos>
v max から v min を 引 いた 値に 1 を加え た 値 を出力する	print ( vmax - vmin + 1 )	print ( maxv - minv + 1 ) <eos>
0 を point の Y 番目の X 番目 にする	point [ Y ] [ X ] = "0"	point [ Y ] [ X ] = 0 <eos>
an s を ' D ' だけ 増加 させる	ans += 'D'	ans += 'D' <eos>
1 を mp の y 番目の x 番目 にする	mp [ y ] [ x ] = 1	mp [ y ] [ x ] = 1 <eos>
何も しない	pass	<unk> <eos>
root ( p rt [ x ] ) を p rt の x 番目 とする を y とする	y = prt [ x ] = root ( prt [ x ] )	x = root ( prt [ x ] ) y = root ( p [ x ] ) <eos>
pow _ re m ( m , n ) を出力する	print ( pow_rem ( m , n ) )	print ( _pow ( m , n ) ) <eos>
0 を dist ance の start _ ver t ex 番目 にする	distance [ start_vertex ] = 0	distance [ <unk> ] = 0 <eos>
an s を 100 分 の 一 にする	ans // = 100	ans /= 100 <eos>
無限 の 整数 列 を出力する	print ( count )	print ( count ) <eos>
a を s とする	s = a	s = a <eos>
os . path の 末尾に _ path を追加する	path . append ( _path )	path . append ( path ) <eos>
( 500 、 100 、 50 、 10 、 5 、 1 ) からなる 列 を c とする	c = [ 500 , 100 , 50 , 10 , 5 , 1 ]	c = [ 500 , 100 , 50 , 10 , 5 , 1 ] <eos>
prime の 、 つまり 先頭から array の i 番目 に 1 を加え た 値 までの 部分 列 の 総 和 を出力する	print ( sum ( prime [ : array [ i ] + 1 ] ) )	print ( sum ( prime [ : i + 1 ] ) ) <eos>
g a p s を 順に g a p として 、 繰 り 返す	for gap in gaps :	for gap in gaps : <eos>
1 を d p の 先頭の 0 番目 にする	dp [ 0 ] [ 0 ] = 1	dp [ 0 ] [ 0 ] = 1 <eos>
b の real 、 b の imag を出力する	print ( b . real , b . imag )	print ( b . real , b . imag ) <eos>
' inf ' を出力する	print ( 'inf' )	print ( 'inf' ) <eos>
x a から xb を 引 いた 値に x a から xb を 引 いた 値を 掛け た 値に y a から y b を 引 いた 値に y a から y b を 引 いた 値を 掛け た 値 を加え た 値を d とする	d = ( xa - xb ) * ( xa - xb ) + ( ya - yb ) * ( ya - yb )	y = xa - xb * ( xb - ya ) + ( yb - ya ) * ( ya - yb ) <eos>
- get In t ( ) を Q の end 番目 にする	Q [ end ] = - getInt ( )	Q [ end ] = - <unk> ( ) <eos>
Y に i に 1 を加え た 値を 追加した 集 まり	Y . add ( i + 1 )	Y . add ( i + 1 ) <eos>
s が " " と 等しくない 間 、 次 を 繰 り 返す	while s != "" :	while s != " : <eos>
max He a p ify ( key , j )	maxHeapify ( key , j )	maxHeapify ( key , j ) <eos>
e 1 が -1 と 等しい とき 、	if e1 == - 1 :	if e1 == - 1 : <eos>
a の c 番目の 総 和 を出力する	print ( sum ( a [ c ] ) )	print ( sum ( a [ c ] ) ) <eos>
p と m の 論理 積 と s の 論理和 を n _ p とする	n_p = p & m | s	n_p = p | ( m ) <eos>
j が 0 以上 かつ a の j 番目 が v より大きい 間 、 次 を 繰 り 返す	while j >= 0 and a [ j ] > v :	while j >= 0 and a [ j ] > v : <eos>
i を u とする	u = i	u = i <eos>
s の i 番目 が ' x ' と 等 し く かつ s の i に 1 を加え た 値 番目 が ' x ' と 等しい とき 、	if s [ i ] == 'x' and s [ i + 1 ] == 'x' :	if s [ i ] == 'x' and s [ i + 1 ] == 'x' : <eos>
( ( i , 0 ) 、 ( g , 0 ) ) からなる 辞書を step とする	step = { i : 0 , g : 0 }	step = { i : 0 , 0 } <eos>
score _ b を 2 で 割 った 商 を b とする	b = score_b // 2	b = score_b // 2 <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 " inf " の 浮動小数点数の 列 を d とする	d = [ float ( "inf" ) for i in range ( n ) ]	d = [ float ( "inf" ) for i in range ( n ) ] <eos>
v が p 1 と 等しい とき 、	if v == p1 :	if v == p1 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 順に x として 、 繰 り 返す	for x in map ( int , input ( ) . split ( ) ) :	for x in map ( int , input ( ) . split ( ) ) : <eos>
S 2 に d 2 の S 1 の i 番目 番目 を加え た 値を S 2 とする	S2 = S2 + d2 [ S1 [ i ] ]	S2 = S2 + d2 [ S1 [ i ] ] <eos>
0 を res とする	res = 0	res = 0 <eos>
k に m を加え た 値を j で 割 った 余 り を k とする	k = ( k + m ) % j	k = ( k + m ) % j <eos>
0 から 、 つまり 入力された 文字列の 整数値 未 満 までの 数 列 の各要素 を _ と し 、 input ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 して の 複素数 の 列 を p とする	p = [ complex ( * map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( input ( ) ) ) ]	p = [ complex ( * map ( int , input ( ) . split ( ) ) for _ in range ( int ( input ( ) ) ) ] <eos>
入力された 文字列の 整数値 を C とする	C = int ( input ( ) )	C = int ( input ( ) ) <eos>
pre order の先頭 を node _ no とする	node_no = preorder [ 0 ]	node_no = preorder [ 0 ] <eos>
file _ input から 読み込んだ 一行 の 整数値 を n とする	n = int ( file_input . readline ( ) )	n = int ( file_input . readline ( ) ) <eos>
0 から 9 未 満 までの 数 列 の各要素 を i と し 、 ( 0 、 " X " ) からなる 列 の 列 のリスト を card とする	card = list ( [ [ 0 , "X" ] for i in range ( 9 ) ] )	card = [ list ( [ 0 , " " ) ] for i in range ( 9 ) ] <eos>
1 を visit ed の s 番目 にする	visited [ s ] = 1	visited [ s ] = 1 <eos>
self . d f s ( u )	self . dfs ( u )	self . dfs ( u ) <eos>
N の l 番目 を "," で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ x 、 y 、 s とする	x , y , s = [ int ( i ) for i in N [ l ] . split ( "," ) ]	x , y , s = [ int ( i ) for i in N [ l ] . split ( "," ) ] <eos>
n r が 0 より 小さく または n r が h 以上 または n c が 0 より 小さく または n c が w 以上の とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if nr < 0 or nr >= h or nc < 0 or nc >= w : <blk> continue </blk>	if nr < 0 or nr >= n or nc >= 0 or nc >= w : <blk> continue </blk> <eos>
p 2 を p とする	p = p2	p = p2 <eos>
g r id の 末尾に 入力された 文字列を 空白 で 分割 した 字句 列 のリスト を追加する	grid . append ( list ( input ( ) . split ( ) ) )	grid . append ( list ( input ( ) . split ( ) ) ) <eos>
c を i で 割 った 値の 切り捨て 整数値 が c を i で 割 った 値の 切り 上 げ 整数値 と 等しい とき 、	if math . floor ( c / i ) == math . ceil ( c / i ) :	if math . ceil ( ( c / i ) / c ) == math . ceil ( math . c ) : <eos>
m が M より大きい とき 、 <blk> M を 60 だけ 増加 させる </blk>	if m > M : <blk> M += 60 </blk>	if m > M : <blk> M += 60 </blk> <eos>
res _ list の b l d _ num 番目の floor _ num 番目の r oo m _ num 番目 を io _ head c n t だけ 増加 させる	res_list [ bld_num ] [ floor_num ] [ room_num ] += io_headcnt	res [ bk_init ] [ <unk> ] [ num ] += <unk> <eos>
空 列 を exc h 3 とする	exch3 = [ ]	exch3 = [ ] <eos>
m ark が " S " と 等しい とき 、	if mark == "S" :	if marker == "S" : <eos>
a の c 番目 が '1' と 等しい とき 、	if a [ c ] == '1' :	if a [ c ] == '1' : <eos>
an s に 11 を加え た 値が 21 以下の とき 、	if ans + 11 <= 21 :	if ans + 11 <= 21 : <eos>
G の v 番目 を 順に w として 、 繰 り 返す	for w in G [ v ] :	for w in G [ v ] : <eos>
line の 1 番目の imag から line の 先頭の imag を 引 いた 値に [ MASK ] を加え た 値に line の 先頭の real から b の real を 引 いた 値を 掛け た 値	+ ( line [ 1 ] . imag - line [ 0 ] . imag ) * ( line [ 0 ] . real - b . real )	( line [ 1 ] . imag - line [ 0 ] . real ) * ( line [ 0 ] . real - b . real ) + line [ 0 ] . real ) <eos>
\\\\\ ' \\\\ \\\\ n ' を 区切り として r に q の 余 弦 を 掛け た 値の 整数値 、 r に q の 正 弦 を 掛け た 値の 整数値 を出力する \\\\\	\\\\\print ( int ( r * math . cos ( q ) ) , int ( r * math . sin ( q ) ) , sep = '\\\\\\\\n' )\\\\\	\\\\\print ( int ( math . cos ( r ) , 2.0 * q ) , r = '\\\\\\\\n' )\\\\ <eos>\
message を 文字 コード 97 に d を加え た 値の 文字 だけ 増加 させる	message += chr ( 97 + d )	message += chr ( 97 + d ) <eos>
print _ flag で ないとき 、	if not print_flag :	if not print_flag : <eos>
num を _ pow ( 10 , 8 ) で 割 った 余 り を num とする	num = num % _pow ( 10 , 8 )	num = num % _pow ( 10 , 8 ) <eos>
1 を com b の i 番目の i 番目 とする を com b の i 番目の 0 番目 にする	comb [ i ] [ 0 ] = comb [ i ] [ i ] = 1	comb [ i ] [ b ] = comb [ i ] [ 0 ] = 1 <eos>
s . popleft ( ) を b とする	b = s . popleft ( )	b = s . popleft ( ) <eos>
tree _ walk ( tree _ walk ( 0 ) , 1 )	tree_walk ( tree_walk ( 0 ) , 1 )	tree_walk_1 ( 0 , 1 ) <eos>
p _ root を self の table の c _ root 番目 にする	self . table [ c_root ] = p_root	self . table [ c_root ] = p_root <eos>
sys の version _ info の先頭 が 3 以上の とき 、 <blk> 入力された 文字列を raw _ input とする </blk>	if sys . version_info [ 0 ] >= 3 : <blk> raw_input = input </blk>	if sys . post_order_search [ 0 ] >= 3 : <blk> <unk> = input ( ) </blk> <eos>
d i grap h の n 番目 を 順に e として 、 繰 り 返す	for e in digraph [ n ] :	for e in digraph [ n ] : <eos>
s _ out を出力する	print ( s_out )	print ( <unk> ) <eos>
add _ parent _ node _ and _ depth ( node s , -1 , root _ no , 0 )	add_parent_node_and_depth ( nodes , - 1 , root_no , 0 )	add_parent_node_and_depth ( nodes , root_node_no , depth - 1 , - 1 ) <eos>
n から k を 引 いた 値 から n 未 満 までの 数 列 を 順に r として 、 繰 り 返す	for r in range ( n - k , n ) :	for r in range ( n - k , n ) : <eos>
i が w と 等しい とき 、 <blk> 無限 の 整数 列 を 1 だけ 増加 させる </blk>	if i == w : <blk> count += 1 </blk>	if i == w : <blk> count += 1 </blk> <eos>
x に ( b + r ) * 15 を加え た 値に g に 7 を 掛け た 値 を加え た 値に y に 13 を 掛け た 値 を加え た 値に c に 2 を 掛け た 値 を加え た 値 から z に 3 を 掛け た 値を 引 いた 値を a とする	a = x + ( b + r ) * 15 + g * 7 + y * 13 + c * 2 - z * 3	a = x + b * 15 + 7 * 7 + c * 7 + a * 7 + c - a * 2 <eos>
g ame に ' A ' を加え た 値が g ame s に 含まれない とき 、	if game + 'A' not in games :	if game + 'A' not in games : <eos>
tree . delete ( int ( in p [ 1 ] ) )	tree . delete ( int ( inp [ 1 ] ) )	tree . <unk> ( int ( inp [ 1 ] ) ) <eos>
a の 末尾に i に w を加え た 値 を追加する	a . append ( i + w )	a . append ( i + w ) <eos>
s を Q の 先頭の 1 番目 だけ 減 少 させる	s -= Q [ 0 ] [ 1 ]	s -= Q [ 0 ] [ 1 ] <eos>
m に 1.0 5 を 掛け た 値を 1000 で 割 った 値の 切り 上 げ 整数値 に 1000 を 掛け た 値を m とする	m = math . ceil ( ( m * 1.05 ) / 1000 ) * 1000	m = math . ceil ( ( m * 1.05 / 1000 ) * 1000 ) <eos>
a を 10 で 割 った 余 り が b を 10 で 割 った 余 り と 等しい とき 、	if a % 10 == b % 10 :	if a % 10 == b % 10 : <eos>
board の x 番目の i 番目 が n と 等しい とき 、	if board [ x ] [ i ] == n :	if board [ x ] [ i ] == n : <eos>
end が 、 つまり 真 と 等しい とき 、	if end == True :	if end == True : <eos>
0 から n に 4 を加え た 値 未 満 までの 数 列 を 順に r として 、 繰 り 返す <blk> '#' を a の r 番目の c 番目 にする </blk>	for r in range ( n + 4 ) : <blk> a [ r ] [ c ] = '#' </blk>	for r in range ( n + 4 ) : <blk> a [ r ] [ c ] = '#' </blk> <eos>
p a g の buf の 、 つまり 現在の 日時 番目 番目の 1 番目 を b t n とする	btn = pag [ buf [ now ] ] [ 1 ]	nt = gap [ buf ] [ now ] <eos>
e の 3 番目 から 、 つまり 末 尾 までの 部分 列 を 順に ot 、 n として 、 繰 り 返す	for ot , n in e [ 3 : ] :	for ot , n in e [ 3 : ] : <eos>
elapsed _ time を time だけ 増加 させる	elapsed_time += time	elapsed_time += time <eos>
0 から a の i を n で 割 った 余 り 番目 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( a [ i % n ] ) :	for j in range ( a [ i % n ] ) : <eos>
2 に i を 掛け た 値を l とする	l = 2 * i	l = 2 * i <eos>
x の 4 番目 を 1 だけ 増加 させる	x [ 4 ] += 1	x [ 4 ] += 1 <eos>
p 1 の先頭 を i とする	i = p1 [ 0 ]	i = p1 [ 0 ] <eos>
空 列 を M とする	M = [ ]	M = [ ] <eos>
SS の各要素 を x v 、 a v 、 y v 、 b v と し 、 ( x v を a v で 割 った 値 、 y v を b v で 割 った 値 ) の 組 の 列 を P S とする	PS = [ ( xv / av , yv / bv ) for xv , av , yv , bv in SS ]	PS = [ ( xv , yv , v ) / ( PS , v / v ) for v , minv in SS ] <eos>
w を w _ len とする	w_len = w	<unk> = w <eos>
is P r im e ( x ) の とき 、	if isPrime ( x ) :	if <unk> ( x ) : <eos>
n の集合 の 長さが 1 と 等しい とき 、	if len ( set ( n ) ) == 1 :	if len ( set ( n ) ) == 1 : <eos>
A を 順に a として 、 繰 り 返す	for a in A :	for a in A : <eos>
i 、 normal を出力する	print ( i , normal )	print ( i , normal ) <eos>
0 を r とする	r = 0	r = 0 <eos>
2 から 10 47 43 の 0.5 乗 の 整数値 に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 2 , int ( 104743 ** 0.5 ) + 1 ) :	for i in range ( 2 , int ( <unk> ** 0.5 ) + 1 ) : <eos>
re t 、 re c ( 1 << u , u ) に c ake s の u 番目 を加え た 値の 最小 値を re t とする	ret = min ( ret , rec ( 1 << u , u ) + cakes [ u ] )	ret = min ( ret , u | ( 1 << u ) + rec [ u ] ) <eos>
s が 3 以上の とき 、	if s >= 3 :	if s >= 3 : <eos>
ed ge s の v 番目 を 順に i として 、 繰 り 返す	for i in edges [ v ] :	for i in edges [ v ] : <eos>
out の逆 順 を返す	return out [ : : - 1 ]	return out [ : - 1 ] <eos>
u の 末尾に point _ list の 1 番目 を追加する	u . append ( point_list [ 1 ] )	u . append ( point_list [ 1 ] ) <eos>
d p _ j に p を加え た 値を d p の k 番目 にする	dp [ k ] = dp_j + p	dp [ k ] = dp_j + p <eos>
( -1 ) からなる 列 の self の V 回 分 の 列 を self の level にする	self . level = [ - 1 ] * self . V	self . level = [ - 1 ] * self . V <eos>
N の i 番目 から i に 2 を加え た 値 までの 部分 列 の 整数値 が me s に含まれる とき 、 <blk> word を me s の N の i 番目 から i に 2 を加え た 値 までの 部分 列 の 整数値 番目 だけ 増加 させる </blk>	if int ( N [ i : i + 2 ] ) in mes : <blk> word += mes [ int ( N [ i : i + 2 ] ) ] </blk>	if int ( N [ i : i + 2 ] ) in mem [ i : N + 2 ] : <blk> s += s [ i + 2 ] </blk> <eos>
( 1 ) からなる 列 を g とする	g = [ 1 ]	g = [ 1 ] <eos>
0 から n から 1 を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> f の i に 1 を加え た 値 番目 を f の i 番目 だけ 増加 させる </blk>	for i in range ( n - 1 ) : <blk> f [ i + 1 ] += f [ i ] </blk>	for i in range ( n - 1 ) : <blk> f [ i + 1 ] += f [ i ] </blk> <eos>
e が " H IT " と 等しい とき 、	if e == "HIT" :	if e == "HIT" : <eos>
d r に d c を加え た 値 と d r 、 d c の 最小 値の コン ビ ネ ーション を k だけ 左 シフト した 値を 10 000000 7 で 割 った 余 り を出力する	print ( ( comb ( dr + dc , min ( dr , dc ) ) << k ) % 100000007 )	print ( min ( ( <unk> + d + c , r % 7 ) , ( k ) ) <eos>
card s の 末尾に 入力された 文字列 を追加する	cards . append ( input ( ) )	cards . append ( input ( ) ) <eos>
an s が 、 つまり 無限 の 整数 列 以下の とき 、 <blk> 無限大 を返す </blk>	if ans <= count : <blk> return inf </blk>	if ans <= count : <blk> return inf </blk> <eos>
self の ALL _ OFF を self の FLAGS にする	self . FLAGS = self . ALL_OFF	self . FLAGS ALL_ON = self . ALL_OFF <eos>
d f s ( i + 1 , u , i + 1 , a 10 , a 01 , a 11 ) の とき 、	if dfs ( i + 1 , u , i + 1 , a10 , a01 , a11 ) :	if dfs ( i + 1 , u , a00 , a10 , i + 1 , a11 ) : <eos>
( 0.0 ) からなる 列 の 2 回 分 の 列 を s とする	s = [ 0.0 ] * 2	s = [ 0.0 ] * 2 <eos>
d is の 末尾に b f s ( i , j ) を追加する	dis . append ( bfs ( i , j ) )	dis . append ( bfs ( i , j ) ) <eos>
t が 0 以上の とき 、	if t >= 0 :	if t >= 0 : <eos>
i の 文字列を si とする	si = str ( i )	si = str ( i ) <eos>
0 から y 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 入力された 文字列の 整数値 の 列 のリスト を B とする	B = list ( [ int ( input ( ) ) for i in range ( y ) ] )	B = list ( [ int ( input ( ) ) for i in range ( y ) ] ) <eos>
an s を r you k in ( x , y , h , w ) だけ 増加 させる	ans += ryoukin ( x , y , h , w )	ans += <unk> ( x , y , w ) <eos>
x の 末尾に s を追加する	x . append ( s )	x . append ( s ) <eos>
1 から M 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 1 , M ) :	for j in range ( 1 , M ) : <eos>
1 を tb l の k と 1 の 論理 積 番目 にする	tbl [ k & 1 ] = 1	tbl [ k & 1 ] = 1 <eos>
\\\\\ write ( " N E K O \\\\ \\\\ n " ) \\\\\	\\\\\write ( "NEKO\\\\\\\\n" )\\\\\	\\\\\write ( <unk> )\\\\ <eos>\
ma 0 から mi 0 を 引 いた 値が D 以下の とき 、	if ma0 - mi0 <= D :	if x0 - x0 <= D : <eos>
' 2' を a の r 番目の n c 番目 にする	a [ r ] [ nc ] = '2'	a [ nr ] [ nc ] = '2' <eos>
s 1 を 順に s として 、 繰 り 返す	for s in s1 :	for s in s1 : <eos>
f _ i から 読み込んだ 一行 の末尾 から 空白 改行 を取り 除 いた 文字列を A _ s とする	A_s = f_i . readline ( ) . rstrip ( )	<unk> = f_i . readline ( ) . rstrip ( ) <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ V 、 d とする </blk>	try : <blk> V , d = map ( int , input ( ) . split ( ) ) </blk>	try : <blk> V , d = map ( int , input ( ) . split ( ) ) </blk> <eos>
( b の 0 番目 から a の先頭 を 引 いた 値 、 b の 1 番目 から a の 1 番目 を 引 いた 値 ) からなる 列 を返す	return [ b [ 0 ] - a [ 0 ] , b [ 1 ] - a [ 1 ] ]	return [ b [ 0 ] - a [ 0 ] , [ b [ 1 ] - a [ 1 ] ] <eos>
0 . を a とする	a = 0 .	a = 0 . <eos>
p の 末尾に p の先頭 を追加する	p . append ( p [ 0 ] )	p . append ( p [ 0 ] ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト の 総 和 を m とする	m = sum ( list ( map ( int , input ( ) . split ( ) ) ) )	m = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
s q _ max の各要素 に max を 適用 した 列 の 最大 値を an s とする	ans = max ( map ( max , sq_max ) )	ans = max ( map ( max ( map ( max , sq_max ) ) ) <eos>
N の l 番目 を S 1 とする	S1 = N [ l ]	S1 = N [ l ] <eos>
c ir c le を 順に j として 、 繰 り 返す	for j in circle :	for j in circles : <eos>
d の 末尾に ( i に y の k 番目 を加え た 値 、 j に x の k 番目 を加え た 値 ) からなる 列 を追加する	d . append ( [ i + y [ k ] , j + x [ k ] ] )	d . append ( [ i + y [ j ] , x [ k + k ] ] ) <eos>
入力された 文字列の 整数値 を s とする	s = int ( input ( ) )	s = int ( input ( ) ) <eos>
an s 1 、 an s 2 の 最小 値 を出力する	print ( min ( ans1 , ans2 ) )	print ( min ( ans1 , ans2 ) ) <eos>
arr の r 番目の c 番目 が 0 と 等しい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if arr [ r ] [ c ] == 0 : <blk> continue </blk>	if arr [ r ] [ c ] == 0 : <blk> continue </blk> <eos>
n が " 6 17 4 " と 等しくない 間 、 次 を 繰 り 返す	while n != "6174" :	while n != <unk> : <eos>
n 内の 全ての要素 を 取り除く	n . clear ( )	n . clear ( ) <eos>
K o ch ( A x , A y , C x , C y , n -1 )	Koch ( Ax , Ay , Cx , Cy , n - 1 )	Koch ( A , x , y , C , - 1 ) <eos>
2 に x 2 から x 1 を 引 いた 値を 掛け た 値を a とする	a = 2 * ( x2 - x1 )	a = 2 * ( x2 - x1 ) <eos>
M は グローバル変数 とする	global M	global M <eos>
e 1 _ c p  の cp と 等しい 要素の 最初の 位置 を cp _ id x とする	cp_idx = e1_cp . index ( cp )	cp_idx = e1_cp . index ( cp ) <eos>
x 2 から x 1 を 引 いた 値の 2 乗 に y 2 から y 1 を 引 いた 値の 2 乗 を加え た 値 の平方根 を b とする	b = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 )	b = math . sqrt ( ( ( x2 - x1 ) ** 2 + ( y1 - y2 ) ** 2 ) <eos>
0 を dist ance の u 番目 にする	distance [ u ] = 0	distance [ u ] = 0 <eos>
区切り なしで 改行 せずに ' z ' に - e w を 掛け た 値 を出力する	print ( 'z' * ( - ew ) , sep = '' , end = '' )	print ( <unk> * z , end = '' ) <eos>
0.0 17 45 32 9 25 1 99 4 32 95 76 9 2 36 9 07 68 4 89 を M とする	M = 0.01745329251994329576923690768489	<unk> = <unk> <eos>
l im e を an s とする	ans = "lime"	ans = lim <eos>
readline ( ) を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ _ 、 m 、 t p 、 d とする	_ , m , tp , d = readline ( ) . split ( )	p , t , d , t = readline ( ) . split ( ) <eos>
S を i の 先頭の i の 1 番目 に 1 を加え た 値 乗 から 1 を 引 いた 値を i の 先頭から 1 を 引 いた 値で 割 った 値 倍 にする	S *= ( i [ 0 ] ** ( i [ 1 ] + 1 ) - 1 ) / ( i [ 0 ] - 1 )	S *= ( i [ 0 ] ** ( i + 1 ) - 1 ) / ( i - 1 ) <eos>
S の n r 番目の n c 番目 が " ST " に含まれる とき 、	if S [ nr ] [ nc ] in "ST" :	if S [ nr ] [ nc ] in ST : <eos>
d i j k str a ( n , 0 ) を dist an t とする	distant = dijkstra ( n , 0 )	distant = dijkstra ( n , 0 ) <eos>
( 0 ) からなる 列 の 、 つまり 入力された 文字列の 整数値 回 分 の 列 の各要素 を _ と し 、 、 つまり 入力された 文字列の 整数値 の 列 を ソート した 列 を a とする	a = sorted ( [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] )	a = sorted ( [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] ) <eos>
a を b で 割 った 値を f とする	f = a / b	f = a / b <eos>
tmp _ node を self の cursor の pre v の next にする	self . cursor . prev . next = tmp_node	self . cursor . next = tmp_node <eos>
c の i 番目 と 1 の 論理 積 の とき 、 <blk> ' N G ' を出力する <sep> 繰り返し を 中断 する </blk>	if c [ i ] & 1 : <blk> print ( 'NG' ) <sep> break </blk>	if c [ i ] & 1 : <blk> print ( 'NG' ) <sep> break </blk> <eos>
r 、 c を r 2 、 c 2 とする	r2 , c2 = r , c	r2 , c2 = r , c <eos>
( ( color 1 , 1 ) ) からなる 辞書を d とする	d = { color1 : 1 }	d = { color : 1 } <eos>
Q の 末尾に ( r 、 c ) の 組 を追加する	Q . append ( ( r , c ) )	Q . append ( ( r , c ) ) <eos>
1 に d p の r から 1 を 引 いた 値 番目の c から 1 を 引 いた 値 番目 、 d p の r 番目の c から 1 を 引 いた 値 番目 、 d p の r から 1 を 引 いた 値 番目の c 番目の 最小 値 を加え た 値を t とする	t = 1 + min ( dp [ r - 1 ] [ c - 1 ] , dp [ r ] [ c - 1 ] , dp [ r - 1 ] [ c ] )	t = min ( 1 + min ( dp [ r - 1 ] [ c - 1 ] , dp [ r - 1 ] [ c ] ) ) <eos>
i を 2 で 割 った 余 り が 0 と 等しい とき 、 <blk> k が 1 と 等しい とき " | " 、 そうでなければ " . " を C の i 番目の 1 に j に 2 を 掛け た 値 を加え た 値 番目 にする </blk>	if i % 2 == 0 : <blk> C [ i ] [ 1 + j * 2 ] = "|" if k == 1 else "." </blk>	if i % 2 == 0 : <blk> C [ i + 1 ] [ j + 1 ] = 2 * C if i == 0 else "C" </blk> <eos>
card の 末尾に i に 1 を加え た 値 を追加する	card . append ( i + 1 )	card . append ( i + 1 ) <eos>
{ 0 : . 10 f } { 1 : . 10 f } を 書式 として cp の real 、 cp の imag で 整 形 した 文字列 を出力する	print ( "{0:.10f} {1:.10f}" . format ( cp . real , cp . imag ) )	print ( "{0:.8f} {1:.8f}" . format ( cp , cp . real ) ) <eos>
0 から H 未 満 までの 数 列 の各要素 を j と し 、 ( abs ( i - j ) を 2 で 割 った 余 り が 0 と 等しい とき '#' 、 そうでなければ 0 から W 未 満 までの 数 列 の各要素 を i と し 、 '.' の 列 ) からなる 列 の 列 を frame とする	frame = [ [ '#' if ( abs ( i - j ) % 2 == 0 ) else [ '.' for i in range ( W ) ] ] for j in range ( H ) ]	frame = [ [ '#' if ( i - j ) % 2 == '.' for i in range ( W - 2 ) ] if [ j == 0 ] ] else [ '#' ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ p 、 h h 、 w w とする	p , hh , ww = [ int ( i ) for i in input ( ) . split ( ) ]	p , h , w = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
tmp  の " ^ " と 等しい 要素の 最初の 位置 を M e _ w とする	Me_w = tmp . index ( "^" )	Me_w = tmp . index ( "^" ) <eos>
number の 末尾に N を追加する	number . append ( N )	number . append ( N ) <eos>
0 が n r 以下 かどうか が H より 小さく なく または 0 が n c 以下 かどうか が W より 小さく なく または S の n r 番目の n c 番目 が " X " と 等しい とき 、	if not 0 <= nr < H or not 0 <= nc < W or S [ nr ] [ nc ] == "X" :	if not 0 <= nr < H or not 0 <= nc < W or S [ nr ] [ nc ] == "X" : <eos>
list _ n の 総 和 を sum _ n とする	sum_n = sum ( list_n )	sum_n = sum ( list_n ) <eos>
a の i 番目の 1 番目 が a の i に 1 を加え た 値 番目の 1 番目 と 等 し く かつ a の i 番目の 2 番目 が a の i に 1 を加え た 値 番目の 2 番目 より大きい とき 、	if a [ i ] [ 1 ] == a [ i + 1 ] [ 1 ] and a [ i ] [ 2 ] > a [ i + 1 ] [ 2 ] :	if a [ i ] [ 1 ] == a [ i + 1 ] [ 1 ] and a [ i + 1 ] [ 2 ] > a [ i ] [ i ] : <eos>
k 1 が k 2 より小さい とき 、 <blk> k 2 を k 1 とする </blk>	if k1 < k2 : <blk> k1 = k2 </blk>	if k1 < k2 : <blk> k2 = k2 </blk> <eos>
10 47 30 を n とする	n = 104730	n = 104743 <eos>
p 、 15 20 * ( a // 5 ) + 3 80 * ( a % 5 ) に 18 70 * ( b // 4 ) を加え た 値に 55 0 に ( b % 4 ) を 掛け た 値 を加え た 値に 22 44 に c を 3 で 割 った 商 を 掛け た 値 を加え た 値に 8 50 に c を 3 で 割 った 余 り	p = min ( p , 1520 * ( a // 5 ) + 380 * ( a % 5 ) + 1870 * ( b // 4 ) + 550 * ( b % 4 ) + 2244 * ( c // 3 ) + 850 * ( c % 3 ) )	p , b = max ( p , 15 * 3 // 3 + a * 380 ) // 3 + <unk> % 3 * 850 ) + ( a // 3 * 850 ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を b r 3 とする	br3 = list ( map ( int , input ( ) . split ( ) ) )	bridge = list ( map ( int , input ( ) . split ( ) ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ h _ s 、 m _ s 、 s _ s 、 h _ e 、 m _ e 、 s _ e とする	h_s , m_s , s_s , h_e , m_e , s_e = map ( int , input ( ) . split ( ) )	<unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , s = map ( int , input ( ) . split ( ) ) <eos>
v が t と 等しい とき 、 <blk> f を返す </blk>	if v == t : <blk> return f </blk>	if v == t : <blk> return f </blk> <eos>
0 を t とする	t = 0	t = 0 <eos>
1 に c  の c の 最大 値 と 等しい 要素の 最初の 位置 を加え た 値 を出力する	print ( 1 + c . index ( max ( c ) ) )	print ( 1 + max ( c . index ( max ( c ) ) ) ) <eos>
'' を l c s とする	lcs = ''	lcs = '' <eos>
% . 10 f % . 10 f を ( x 、 y ) の 組 で 割 った 余 り を出力する	print ( "%.10f %.10f" % ( x , y ) )	print ( "%.10f <unk> <unk> % ( x , y ) ) <eos>
heappop ( h q ) を event とする	event = heappop ( hq )	event = heappop ( hq ) <eos>
Ma p の h 番目の w 番目 が "*" と 等しくな く かつ Ma p の h 番目の w 番目 が " # " と 等しくな く かつ 0 が h より小さい 間 、 次 を 繰 り 返す	while Map [ h ] [ w ] != "*" and Map [ h ] [ w ] != "#" and 0 < h :	while Map [ h ] [ w ] != "*" and Map [ h ] [ w ] != "#" and h < "#" and h [ h ] [ h < "#" : <eos>
0 から N 10 未 満 までの 数 列 を 順に state として 、 繰 り 返す	for state in range ( N10 ) :	for state in range ( 10 ) : <eos>
d の 末尾に _ d を追加する	d . append ( _d )	d . append ( g_d ) <eos>
( 2 50000 ) からなる 列 の n に 1 を加え た 値 回 分 の 列 を dist ance とする	distance = [ 250000 ] * ( n + 1 )	distance = [ <unk> ] * ( n + 1 ) <eos>
1 を N だけ 左 シフト した 値 から 1 を 引 いた 値を ALL とする	ALL = ( 1 << N ) - 1	ALL = ( 1 << ( N << ( N ) - 1 ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ d 、 l とする	d , l = map ( int , input ( ) . split ( ) )	d , l = map ( int , input ( ) . split ( ) ) <eos>
a の j 番目 、 a の i 番目 を a の i 番目 、 a の j 番目 とする	a [ i ] , a [ j ] = a [ j ] , a [ i ]	a [ i ] , a [ j ] = a [ j ] , a [ i ] <eos>
1 を 辞書の S の i 番目 番目 にする	dict [ S [ i ] ] = 1	dict [ S [ i ] ] = 1 <eos>
N から 1 を 引 いた 値の ビット 長 を l v とする	lv = ( N - 1 ) . bit_length ( )	lv = ( N - 1 ) . bit_length ( ) <eos>
self の id の self の id の i 番目 番目 を self の id の i 番目 にする	self . id [ i ] = self . id [ self . id [ i ] ]	self . id [ i ] = self . id [ i ] <eos>
mul の j に 1 を加え た 値 番目の end 番目 を down とする	down = mul [ j + 1 ] [ end ]	end = mul [ j + 1 ] [ end ] <eos>
text の arg 0 番目 から arg 1 に 1 を加え た 値 までの 部分 列 を出力する	print ( text [ arg0 : arg1 + 1 ] )	print ( text [ arg0 : arg0 ] + 1 ) <eos>
x 0 に y 1 を 掛け た 値 から x 1 に y 0 を 掛け た 値を 引 いた 値を s v とする	sv = x0 * y1 - x1 * y0	v0 = x0 * y1 - x1 * y0 <eos>
queue の 、 つまり 先頭から 、 つまり 末 尾 までの 部分 列 の各要素 を x と し 、 done の x の先頭 番目の ときの queue  内の x と 等しい 要素を 取り除く の 列	[ queue . remove ( x ) for x in queue [ : ] if done [ x [ 0 ] ] ]	queue . remove ( [ x [ 0 ] for x in queue if x [ : ] ] ) <eos>
n から -1 未 満 までの -1 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( n , - 1 , - 1 ) :	for i in range ( n , - 1 , - 1 ) : <eos>
k i が 、 つまり 辞書 に含まれる とき 、 <blk> 空 列 を 辞書の k i 番目 にする </blk>	if ki in dict : <blk> dict [ ki ] = [ ] </blk>	if ki in dict : <blk> dict [ ki ] = [ ] </blk> <eos>
tmp の逆 順 の各要素 を _ と し 、 _ の 列 を string の a 番目 から b に 1 を加え た 値 までの 部分 列 にする	string [ a : b + 1 ] = [ _ for _ in tmp [ : : - 1 ] ]	string [ a : b + 1 ] = [ : _ + 1 ] <eos>
b が a と 等しい とき 、 <blk> c を出力する <sep> ' ' を 間 に入れ て b の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する <sep> 何も 返さ ない </blk>	if b == a : <blk> print ( c ) <sep> print ( ' ' . join ( map ( str , b ) ) ) <sep> return </blk>	if b == a : <blk> print ( ' ' . join ( map ( str , b ) ) <sep> return </blk> <eos>
x 3 、 y 3 、 z 3 、 w 3 を出力する	print ( x3 , y3 , z3 , w3 )	print ( x3 , y3 , w3 , w3 ) <eos>
str B の 整数値 に 10 の 4 から str B の 長さ を 引 いた 値 乗 を 掛け た 値を b とする	b = int ( strB ) * ( 10 ** ( 4 - len ( strB ) ) )	b = int ( <unk> ) * 10 ** 4 - len ( B ) <eos>
x を パラメータ として x の先頭 を返す 関数を キー として d の キーと値 の集まり を ソート した 列 を 順に k として 、 繰 り 返す	for k in sorted ( d . items ( ) , key = lambda x : x [ 0 ] ) :	for k in sorted ( d . items ( ) , key = lambda x : x [ 0 ] ) : <eos>
b を 36 00 で 割 った 余 り を 60 で 割 った 余 り を b _ S とする	b_S = ( b % 3600 ) % 60	b_T = b % 3600 % 60 <eos>
b が n より大きい とき 、 <blk> b を n とする </blk>	if b > n : <blk> n = b </blk>	if b > n : <blk> b = b </blk> <eos>
prime _ table を 順に i として 、 繰 り 返す	for i in prime_table :	for i in prime_table : <eos>
b 、 a に b を加え た 値を a 、 b とする	a , b = b , a + b	a , b = b , a + b <eos>
cmath モジュール を用い る	from cmath import rect	from cmath import phase , pi <eos>
入力された 文字列を " " で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を S とする	S = [ int ( i ) for i in input ( ) . split ( " " ) ]	S = [ int ( i ) for i in input ( ) . split ( " " ) ] <eos>
s を a の i を n で 割 った 余 り 番目 だけ 減 少 させる	s -= a [ i % n ]	s -= a [ i % n ] <eos>
i が L より小さい 間 、 次 を 繰 り 返す	while i < L :	while i < L : <eos>
p の x 番目の y 番目の W 番目の S 番目 を p の x から 1 を 引 いた 値 番目の y 番目の W 番目の W 番目 だけ 増加 させる	p [ x ] [ y ] [ W ] [ S ] += p [ x - 1 ] [ y ] [ W ] [ W ]	p [ x ] [ y ] [ W ] [ W ] [ W ] [ x - 1 ] += p [ y ] [ W ] [ W ] <eos>
D を 順に d r 、 d c として 、 繰 り 返す	for dr , dc in D :	for dr , dc in D : <eos>
play er を 無限 に 繰り返し た 列 、 an s の 要素を それぞれ 組 に した 列 を 順に p 、 a として 、 繰 り 返す	for p , a in zip ( cycle ( player ) , ans ) :	for a , p , a in zip ( player ) : <eos>
4 から N 未 満 までの 2 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 4 , N , 2 ) :	for i in range ( 4 , N , 2 ) : <eos>
is _ prime の集合 を prime _ set とする	prime_set = set ( is_prime )	prime_set = set ( ) <eos>
self から self . project ion _ on ( v ) を 引 いた 値を返す	return self - self . projection_on ( v )	return self . projection ( self . vertices ) - self . <eos>
2 を k とする	k = 2	k = 2 <eos>
'' を 間 に入れ て t を 連結 した 文字列を t t とする	tt = '' . join ( t )	t = '' . join ( t ) <eos>
m _ sum を min _ sum とする	min_sum = m_sum	<unk> = sum_m <eos>
集合 を ge m s とする	gems = set ( )	gems = set ( ) <eos>
n が 1 と 等しい とき 、 <blk> s が 10 より小さい とき 1 、 そうでなければ 0 を返す </blk>	if n == 1 : <blk> return ( 1 if s < 10 else 0 ) </blk>	if n == 1 : <blk> return 0 if n == 1 else 0 </blk> <eos>
d p の l 番目の j 番目 に d p の j 番目の r 番目 を加え た 値を d p の l 番目の r 番目 にする	dp [ l ] [ r ] = dp [ l ] [ j ] + dp [ j ] [ r ]	dp [ l ] [ j ] = dp [ l ] [ j ] + dp [ j ] [ r ] <eos>
print _ p ( p )	print_p ( p )	printA ( p ) <eos>
que の先頭 の先頭 を res 0 とする	res0 = que [ 0 ] [ 0 ]	res = que [ 0 ] [ 0 ] <eos>
p が c 以下の とき 、	if p <= c :	if p <= c : <eos>
que r ies の i 番目 を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ com 、 b 、 c とする	com , b , c = queries [ i ] . split ( )	com , b , c = queries [ i ] . split ( ) <eos>
y を direction の 正 弦 だけ 増加 させる	y += math . sin ( direction )	y += math . sin ( direction ) <eos>
真 を first とする	first = True	first = True <eos>
'1' が g r id の i 番目の j 番目 以下 かつ g r id の i 番目の j 番目 が ' 9 ' 以下の とき 、	if '1' <= grid [ i ] [ j ] and grid [ i ] [ j ] <= '9' :	if '1' <= grid [ i ] [ j ] and grid [ i ] [ j ] <= '9' : <eos>
stack を S とする	S = stack	S = stack <eos>
os . path の 0 番目 が source と 等しくない 間 、 次 を 繰 り 返す	while path [ 0 ] != source :	while path [ 0 ] != source : <eos>
x が y 以上の とき 、	if x >= y :	if x >= y : <eos>
s の各要素 を c と し 、 c の 整数値 の 列 の 総 和 を出力する	print ( sum ( [ int ( c ) for c in s ] ) )	print ( sum ( [ int ( c ) for c in s ] ) ) <eos>
b から a を 引 いた 値を co st とする	cost = b - a	cost = b - a <eos>
V を 順に i 、 j として 、 繰 り 返す	for i , j in V :	for i , j in V : <eos>
no が p と 等しい かどうか が 0 と 等しい とき 、	if no == p == 0 :	if no == p == 0 : <eos>
( 0 ) からなる 列 の h 回 分 の 列 を a とする	a = [ 0 ] * h	a = [ 0 ] * h <eos>
num を _ pow ( 10 , 24 ) で 割 った 商 を _ num とする	_num = num // _pow ( 10 , 24 )	_num = num // _pow ( 10 , 24 ) <eos>
a の 総 和 を 2 で 割 った 余 り が 0 と 等しい とき 、	if sum ( a ) % 2 == 0 :	if sum ( a ) % 2 == 0 : <eos>
m を ソート する	m . sort ( )	m . sort ( ) <eos>
( 0 ) からなる 列 の 10 回 分 の 列 を c n t とする	cnt = [ 0 ] * 10	cnt = [ 0 ] * 10 <eos>
3 から 10 1 未 満 までの 数 列 の各要素 を i と し 、 a の i 番目 を 2 で 割 った 余 り の 列 の 総 和 を c とする	c = sum ( [ a [ i ] % 2 for i in range ( 3 , 101 ) ] )	c = sum ( [ a [ i ] for i in range ( 3 , 1 ) ] ) % sum ( a [ i ] ) <eos>
s witch _ node _ no を node s の del _ node の parent 番目の left にする	nodes [ del_node . parent ] . left = switch_node_no	nodes [ del_node . left ] . left = <unk> <eos>
m を a の r 番目の k から 1 を 引 いた 値 から r を 引 いた 値 番目 にする	a [ r ] [ k - 1 - r ] = m	a [ r ] [ k - 1 ] = m <eos>
( 0 ) からなる 列 の n 回 分 の 列 、 空 列 を f 、 tb l とする	f , tbl = [ 0 ] * n , [ ]	f , tbl = [ 0 ] * n , [ ] <eos>
count s に対応する 値 、 もし 存在し なければ word 、 0 に 1 を加え た 値を count s の word 番目 にする	counts [ word ] = counts . get ( word , 0 ) + 1	counts [ word ] = counts . get ( word , 0 ) + 1 <eos>
偽 を res とする	res = False	res = False <eos>
0 から a の 長さ 未 満 までの 2 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 0 , len ( a ) , 2 ) :	for i in range ( 0 , len ( a ) , 2 ) : <eos>
0 を c を b を a とすると すると する を an s とする	ans = a = b = c = 0	ans = b = c = a = b = 0 <eos>
n t が node の n r 番目の n c 番目の nd 番目 より小さい とき 、	if nt < node [ nr ] [ nc ] [ nd ] :	if nt < node [ nr ] [ nc ] [ nd ] : <eos>
( d 、 w 、 h ) からなる 列 を ソート した 列 の先頭 を len _ 1 とする	len_1 = sorted ( [ d , w , h ] ) [ 0 ]	_next = sorted ( [ d , w [ 0 ] , w [ 1 ] ] ) <eos>
d ice . N ( )	dice . N ( )	dice . N ( ) <eos>
C の i 番目の j 番目 が S に含まれる とき 、	if C [ i ] [ j ] in S :	if C [ i ] [ j ] in S : <eos>
o が 3 と 等しい とき 、 <blk> n を 1 だけ 減 少 させる <sep> ( 0 ) からなる 列 の 3 回 分 の 列 を b とする <sep> s を出力する <sep> 0 を s とする を o とする </blk>	if o == 3 : <blk> n -= 1 <sep> b = [ 0 ] * 3 <sep> print ( s ) <sep> o = s = 0 </blk>	if o == 3 : <blk> s = [ 0 ] * n <sep> b = 0 <sep> b = 0 <sep> </blk> <eos>
d が 0 と 等しい とき 、 <blk> an s を ' ' に w を 掛け た 値 だけ 増加 させる </blk>	if d == 0 : <blk> ans += ' ' * w </blk>	if d == 0 : <blk> ans += <unk> * w </blk> <eos>
c up 内の y を x で 置き換え た 文字列を c up とする	cup = cup . replace ( y , x )	cup = cup . replace ( x , y ) <eos>
readline ( ) の 整数値 を K とする	K = int ( readline ( ) )	K = int ( readline ( ) ) <eos>
maximum が a の i 番目 より小さい とき 、	if ( maximum < a [ i ] ) :	if maximum < a [ i ] : <eos>
ub から l b を 引 いた 値が e p s 以上の 間 、 次 を 繰 り 返す	while ub - lb >= eps :	while ub - lb >= speed : <eos>
sys の stdin から 読み込んだ 一行 を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ p _ name 、 r _ time とする	p_name , r_time = sys . stdin . readline ( ) . split ( )	name , p_q , time_m = sys . stdin . readline ( ) . split ( ) <eos>
q  内の cmd の 7 番目 から 、 つまり 末 尾 までの 部分 列 と 等しい 要素を 取り除く	q . remove ( cmd [ 7 : ] )	q . remove ( cmd [ 7 : ] ) <eos>
1 を used の i 番目 にする	used [ i ] = 1	used [ i ] = 1 <eos>
base から w 2 を w で 割 った 値を 引 いた 値を b 1 とする	b1 = base - w2 / w	b1 = base - ( w2 - w1 ) / 1 <eos>
next _ line の nl 番目 を nl とする	nl = next_line [ nl ]	nl = next_line [ nl ] <eos>
v を an c の un it e ( v , w ) 番目 にする	anc [ unite ( v , w ) ] = v	anc [ unite ( v , w ) ] = v <eos>
r の j 番目 を sh e et の i 番目の j 番目 にする	sheet [ i ] [ j ] = r [ j ]	sheet [ i ] [ j ] = r [ j ] <eos>
{} : {} : {} を出力する	print ( { s // 3600 } : { s % 3600 // 60 } : { s % 60 } )	print ( { ch } ) <eos>
y 2 から y 1 を 引 いた 値を s とする	s = y2 - y1	s = y2 - y1 <eos>
v 1 に x を 掛け た 値を an s とする	ans = v1 * x	ans = v1 * x <eos>
c を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ a 、 b とする	a , b = c . split ( )	a , b = c . split ( ) <eos>
1 から 10 1 未 満 までの 数 列 の各要素 を i と し 、 a 内の i の 出現 回数 の 列 を d とする	d = [ a . count ( i ) for i in range ( 1 , 101 ) ]	d = [ a . count ( i ) for i in range ( 1 , 101 ) ] <eos>
item set s の i 番目 が item set s の i から 1 を 引 いた 値 番目 と 等しい とき 、	if itemsets [ i ] == itemsets [ i - 1 ] :	if itemsets [ i ] == itemsets [ i - 1 ] : <eos>
r r の buf の j 番目の 順序 数 から A を 引 いた 値 番目 、 c c の buf の j 番目の 順序 数 から A を 引 いた 値 番目 を r 、 c とする	r , c = rr [ ord ( buf [ j ] ) - A ] , cc [ ord ( buf [ j ] ) - A ]	r , c = r [ ord ( buf [ j ] ) - A [ j ] , cc [ j - A ] <eos>
S or t ed _ List  の List の q 番目 と 等しい 要素の 最初の 位置 に 1 を加え た 値 を出力する	print ( Sorted_List . index ( List [ q ] ) + 1 )	print ( <unk> <unk> . index ( List [ q ] ) + 1 ) <eos>
l を 順に i として 、 繰 り 返す	for i in l :	for i in l : <eos>
' ' を 間 に入れ て per の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する	print ( ' ' . join ( map ( str , per ) ) )	print ( ' ' . join ( map ( str , perm ) ) ) <eos>
0 から N 未 満 までの 数 列 の各要素 を __ と し 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 の 列 を blocks とする	blocks = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for __ in range ( N ) ]	blocks = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for __ in range ( N ) ] <eos>
0 が n x 以下 かどうか が A より 小さく なく または 0 が n y 以下 かどうか が B より 小さく なく または 0 が n z 以下 かどうか が C より 小さく ないとき 、	if not 0 <= nx < A or not 0 <= ny < B or not 0 <= nz < C :	if not 0 <= nx < A or not 0 <= ny < 0 or not 0 <= ny < C : <eos>
k en j ir o を出力する	print ( "kenjiro" )	print ( <unk> ) <eos>
a が 0 と 等しい とき 、 <blk> 1 を f とする </blk>	if a == 0 : <blk> f = 1 </blk>	if a == 0 : <blk> f = 1 </blk> <eos>
0 x 7 f ffffff を IN F とする	INF = 0x7fffffff	INF = <unk> <eos>
( 、 つまり 偽 ) からなる 列 の V 回 分 の 列 を is _ v is it ed とする	is_visited = [ False ] * V	is_visited = [ False ] * V <eos>
i から j を 引 いた 値に an s を 掛け た 値を M O D で 割 った 余 り を an s とする	ans = ( i - j ) * ans % MOD	ans = ( i - j ) * M % <unk> <eos>
n を 60 で 割 った 商 から hour に 60 を 掛け た 値を 引 いた 値を minute とする	minute = n // 60 - hour * 60	minute = n // 60 - 60 * minute <eos>
book s を 順に b として 、 繰 り 返す	for b in books :	for b in number : <eos>
a を S とする	S = a	S = a <eos>
改行 せずに str ( tmp [ j ] ) . r just ( 5 ) を出力する	print ( str ( tmp [ j ] ) . rjust ( 5 ) , end = "" )	print ( str ( tmp [ j ] ) . rjust ( 5 ) , end = "" ) <eos>
act in id ia _ y ok o  内の ( i 、 0 ) からなる 列 と 等しい 要素を 取り除く	actinidia_yoko . remove ( [ i , 0 ] )	actinidia_yoko . remove ( [ 0 , i ] ) <eos>
post _ from _ pre _ in ( pre order _ right , in order _ right )	post_from_pre_in ( preorder_right , inorder_right )	post_from_pre_in ( preorder_left , <unk> ) <eos>
s in k を v とする	v = sink	v = <unk> <eos>
conv ex _ c ut ( s eg , p o ) を p o とする	po = convex_cut ( seg , po )	po = <unk> ( s , po ) <eos>
G 2 の x 番目 に y を 追加した 集 まり	G2 [ x ] . add ( y )	G2 [ x ] . add ( y ) <eos>
1 を used の p 番目 にする	used [ p ] = 1	used [ p ] = 1 <eos>
a の x 番目 が 0 と 等しい とき 、 <blk> 1 を a の x 番目 にする <sep> x を出力する </blk>	if a [ x ] == 0 : <blk> a [ x ] = 1 <sep> print ( x ) </blk>	if a [ x ] == 0 : <blk> print ( x [ 1 ] ) <sep> a [ x ] = x </blk> <eos>
( 0 ) からなる 列 の 12 回 分 の 列 を f とする	f = [ 0 ] * 12	f = [ 0 ] * 12 <eos>
a d j の V から 1 を 引 いた 値 番目 を 順に s 、 d として 、 繰 り 返す	for s , d in adj [ V - 1 ] :	for s , d in adj [ V - 1 ] : <eos>
c を 1 だけ 増加 させる	c += 1	c += 1 <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を A とする	A = list ( map ( int , f_i . readline ( ) . split ( ) ) )	A = list ( map ( int , f_i . readline ( ) . split ( ) ) ) <eos>
fact s の n 番目 を返す	return facts [ n ]	return facts [ n ] <eos>
P が 2 と 等しい とき 、	if P == 2 :	if P == 2 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を 展開 し 、 それぞれ d 、 a とする	d , a = [ int ( _ ) for _ in input ( ) . split ( ) ]	d , a = [ int ( _ ) for _ in input ( ) . split ( ) ] <eos>
1 から n 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 1 , n ) :	for j in range ( 1 , n ) : <eos>
d s の先頭 を 除 いた 部分 列 を 順に d として 、 繰 り 返す	for d in ds [ 1 : ] :	for d in ds [ 1 : ] : <eos>
self の FLAGS を self の Ma s k s の m 番目の 補 数 と の 論理 積 にする	self . FLAGS & = ~ self . Masks [ m ]	self . FLAGS & = ~ self . Masks [ m ] <eos>
i を 開始 番号 として imag e の i 番目 から 、 つまり 末 尾 までの 部分 列 に 番号 付 した 組 の 列 を 順に i 、 row として 、 繰 り 返す	for i , row in enumerate ( image [ i : ] , start = i ) :	for i , row in enumerate ( e [ : ] , start = i ) : <eos>
f 、 t を f 0 、 t 0 とする	f0 , t0 = f , t	f , t = f , 0 <eos>
r を 2 で 割 った 値を s から a を 引 いた 値で 割 った 値に s に d を加え た 値 から r を 引 いた 値 から e を 引 いた 値 から f を 引 いた 値を 掛け た 値を r 1 とする	r1 = r / 2 / ( s - a ) * ( s + d - r - e - f )	r = r / 2 / ( s - a ) * ( s - d - 1 ) <eos>
p u z z le の 末尾に row を追加する	puzzle . append ( row )	puzzle . append ( row ) <eos>
tree の 0 番目 が ' (' と 等しい とき 、	if tree [ 0 ] == '(' :	if tree [ 0 ] == '(' : <eos>
k が 0 より小さい とき 、 <blk> 繰り返し を 中断 する </blk>	if k < 0 : <blk> break </blk>	if k < 0 : <blk> break </blk> <eos>
sys の stdin から 読み込んだ データを input _ str とする	input_str = sys . stdin . read ( )	str_list = sys . stdin . read ( ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を C とする	C = list ( map ( int , input ( ) . split ( ) ) )	C = list ( map ( int , input ( ) . split ( ) ) ) <eos>
cur が 0 より大きい とき 、	if cur > 0 :	if cur > 0 : <eos>
cd を p に 1 を加え た 値 だけ 右 シフト した 値に 3 を 掛け た 値 と 1 を q - p から 1 を 引 いた 値 だけ 左 シフト した 値に 3 を 掛け た 値 から 1 を 引 いた 値の 論理 積 を b 2 とする	b2 = ( cd >> ( p + 1 ) * 3 ) & ( ( 1 << ( q - p - 1 ) * 3 ) - 1 )	b = ( cd >> ( p + 1 << 3 ) * ( p - 1 ) + ( q - 1 ) * q - 1 ) <eos>
h が 0 と 等 し く または h が H から 1 を 引 いた 値 と 等しい とき 、	if h == 0 or h == H - 1 :	if h == 0 or h == H - 1 : <eos>
c n t 1 を 1 だけ 増加 させる	cnt1 += 1	cnt += 1 <eos>
load _ cap が 0 より大きい 間 、 次 を 繰 り 返す	while load_cap > 0 :	while load_cap > 0 : <eos>
T e am s の 末尾に T e am ( id , score ) を追加する	Teams . append ( Team ( id , score ) )	Teams . append ( Teams ( T , score ) ) <eos>
( ( max _ d ) からなる 列 の i に ( 0 ) からなる 列 を加え た 値に ( max _ d ) からなる 列 の range ( V ) の各要素 を i と し 、 ( V - i -1 ) の 列 回 分 の 列 を加え た 値 回 分 の 列 ) からなる 列 を A とする	A = [ [ max_d ] * i + [ 0 ] + [ max_d ] * [ ( V - i - 1 ) for i in range ( V ) ] ]	V = [ [ max ( V ) + [ i - 1 ] * V + [ - 1 ] * V for i in [ - 1 ] ] ] <eos>
空 列 を top 3 とする	top3 = [ ]	top3 = [ ] <eos>
s が go al と 等しい とき 、 <blk> x に h の go al 番目 を加え た 値 から t に 2 を 掛け た 値を 引 いた 値を返す </blk>	if s == goal : <blk> return x + h [ goal ] - t * 2 </blk>	if s == goal : <blk> return ( goal + ( x - 2 * goal ) </blk> <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 入力された 文字列の 整数値 の 列 を A とする	A = [ int ( input ( ) ) for i in range ( n ) ]	A = [ int ( input ( ) ) for i in range ( n ) ] <eos>
T の集合 を T とする	T = set ( T )	T = set ( T ) <eos>
self の IN F を res とする	res = self . INF	res = self . INF <eos>
not _ used _ verti ce s を返す	return not_used_vertices	return not_used_vertices <eos>
i に 1 を加え た 値を max P l a y er とする	maxPlayer = i + 1	minPlayer = i + 1 <eos>
an s を A 0 の v 番目 に cur から ts の v 番目 を 引 いた 値を 掛け た 値 、 A 1 の v 番目 に A 2 の v 番目 を加え た 値の 最小 値 だけ 増加 させる	ans += min ( A0 [ v ] * ( cur - ts [ v ] ) , A1 [ v ] + A2 [ v ] )	ans += min ( min ( A [ v0 ] * v [ cur ] - A [ cur + v ] , A [ 1 ] ) ) <eos>
d の pip の 0 番目 が top と 等 し く かつ d の pip の 1 番目 が f r on t と 等しい とき 、	if d . pip [ 0 ] == top and d . pip [ 1 ] == front :	if d . pip [ 0 ] == top [ 1 ] and f [ t == front : <eos>
空 辞書を points とする	points = { }	points = { } <eos>
' import math '	'import math'	<unk> <eos>
空 列 を d 1 とする	d1 = [ ]	d1 = [ ] <eos>
Point ( x 2 , y 2 ) を P 2 とする	P2 = Point ( x2 , y2 )	P = Point ( x2 , y2 ) <eos>
8 に a に n を加え た 値を 掛け た 値 を出力する	print ( 8 * ( a + n ) )	print ( 8 * a + n * n ) <eos>
node s の 長さが 0 より大きい 間 、 次 を 繰 り 返す	while len ( nodes ) > 0 :	while len ( nodes ) > 0 : <eos>
group _ num を groups の u 番目 にする	groups [ u ] = group_num	groups [ u ] = group_num <eos>
f w d _ init の 末尾に '' を追加する	fwd_init . append ( '' )	fwd_init . append ( '' ) <eos>
' internal node ' を node の type にする	node . type = 'internal node'	node . type = <unk> <unk> <eos>
def i cient number を d とする	d = "deficient number"	d = <unk> <eos>
inter est を high とする	high = interest	high = interest <eos>
a の i 番目 を m で 割 った 余 り にする	a [ i ] % = m	a [ i ] % = m <eos>
0 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> heapq . heap ify ( p q [ i ] ) </blk>	for i in range ( n ) : <blk> heapq . heapify ( pq [ i ] ) </blk>	for i in range ( n ) : <blk> heapq . heapify ( pq [ i ] ) </blk> <eos>
3.14 1 59 2 65 35 89 を pi とする	pi = 3.141592653589	<unk> = <unk> <eos>
0 から L V 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( LV ) :	for k in range ( LV ) : <eos>
node 1 が self の ed ge s に 含 まれ なく または node 2 が self の ed ge s の node 1 番目 に 含まれない とき 、	if node1 not in self . edges or node2 not in self . edges [ node1 ] :	if node1 in self . edges [ node2 ] or self . edges not in self . edges : <eos>
mp の d 番目 を 1 だけ 増加 させる	mp [ d ] += 1	mp [ d ] += 1 <eos>
a を b で 割 った 商 を出力する	print ( a // b )	print ( a // b ) <eos>
self の level の t 番目 が 0 より小さい とき 、 <blk> 繰り返し を 中断 する </blk>	if self . level [ t ] < 0 : <blk> break </blk>	if self . level [ t ] < 0 : <blk> break </blk> <eos>
stack の 長さが 0 と 等 し く または stack の -1 番目 が - x と 等しくない とき 、	if len ( stack ) == 0 or stack [ - 1 ] != - x :	if len ( stack ) == 0 or ( stack [ - 1 ] != - x [ - 1 ] ) : <eos>
x を パラメータ として - x の 1 番目 を返す 関数を キー として 無限 の 整数 列 の キーと値 の集まり を ソート した 列 を ソート した 列 を 順に key 、 value として 、 繰 り 返す	for key , value in sorted ( sorted ( count . items ( ) ) , key = lambda x : - x [ 1 ] ) :	for key , value in sorted ( count . items ( ) , key = lambda x : x [ 1 ] ) : <eos>
Q の キーと値 の集まり を 順に v 、 m として 、 繰 り 返す	for v , m in Q . items ( ) :	for v , m in Q . items ( ) : <eos>
s tamp s を 順に m 、 s として 、 繰 り 返す	for m , s in stamps :	for m , s in stamps : <eos>
R の y から l を 引 いた 値 番目 を e とする	e = R [ y - l ]	e = R [ y - l ] <eos>
入力された 文字列のリスト を S とする	S = list ( input ( ) )	S = list ( input ( ) ) <eos>
T の i 番目 が array に含まれる とき 、	if ( T [ i ] in array ) :	if T [ i ] in array : <eos>
p を board の i 番目 にする	board [ i ] = p	board [ i ] = p <eos>
0 から e の v 番目の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( e [ v ] ) ) :	for i in range ( len ( e [ v ] ) ) : <eos>
^ を Ma p の M e _ h から 1 を 引 いた 値 番目の M e _ w 番目 にする	Map [ Me_h - 1 ] [ Me_w ] = "^"	Map [ Me_h ] [ Me_w - 1 ] = "^" <eos>
S 3 を出力する	print ( S3 )	print ( S3 ) <eos>
改行 せずに table の s の i 番目の 整数値 番目 を出力する	print ( table [ int ( s [ i ] ) ] , end = "" )	print ( int ( table [ s ] [ i ] ) , end = "" ) <eos>
真 を table の i に 1 を加え た 値 番目の j に 1 を加え た 値 番目 にする	table [ i + 1 ] [ j + 1 ] = True	table [ i + 1 ] [ j + 1 ] = True <eos>
( IN F ) からなる 列 の 256 回 分 の 列 を d p 1 とする	dp1 = [ INF ] * 256	dp1 = [ INF ] * 256 <eos>
0 から 2 に n を 掛け た 値 未 満 までの 2 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 0 , 2 * n , 2 ) :	for i in range ( 0 , 2 * n , 2 ) : <eos>
s を n だけ 増加 させる	s += n	s += n <eos>
self の Node s の 1 番目 を self の cursor にする	self . cursor = self . Nodes [ 1 ]	self . cursor = self . GetNodes ( ) <eos>
self の t が other の t より小さい かどうか を返す	return self . t < other . t	return self . t < other . t <eos>
q が N より 小さく かつ S の q 番目 が " B " と 等しい 間 、 次 を 繰 り 返す	while q < N and S [ q ] == "B" :	while q < N and S [ q ] == "B" : <eos>
de g の w 番目 が 0 と 等しい とき 、	if deg [ w ] == 0 :	if deg [ w ] == 0 : <eos>
in _ node の key を node s の parent _ node _ no 番目の right にする	nodes [ parent_node_no ] . right = in_node . key	nodes [ parent_node_no ] . right = in_node . key <eos>
q が s 以上の 間 、 次 を 繰 り 返す	while q >= s :	while q >= s : <eos>
r が r 1 より小さい とき 、 <blk> r を r 1 とする </blk>	if r < r1 : <blk> r1 = r </blk>	if r < r1 : <blk> r1 = 1 </blk> <eos>
s を arr の n 番目の c 番目 にする	arr [ n ] [ c ] = s	arr [ n ] [ c ] = s <eos>
can _ load ( num _ ba g g age s , b a g g age s , num _ t ru c k s , m id ) の とき 、	if can_load ( num_baggages , baggages , num_trucks , mid ) :	if <unk> ( num_baggages , <unk> , num_baggages , <unk> ) : <eos>
g が 50000 以下の とき 、	if g <= 50000 :	if g <= <unk> : <eos>
k が 1 より小さい とき 、 <blk> 繰り返し を 中断 する </blk>	if k < 1 : <blk> break </blk>	if k < 1 : <blk> break </blk> <eos>
c n t L の check ( l ) 番目 を 1 だけ 増加 させる	cntL [ check ( l ) ] += 1	cntR [ check ( l ) ] += 1 <eos>
add _ parent _ node _ and _ depth ( node s , node _ no , child , depth + 1 )	add_parent_node_and_depth ( nodes , node_no , child , depth + 1 )	add_parent_node_and_depth ( nodes , nodes , node_no = add_parent_node_and_depth ( nodes , depth + 1 , nodes ) ) <eos>
set _ info ( a , b , i , d + 1 )	set_info ( a , b , i , d + 1 )	<unk> ( a , b , i + 1 , d ) <eos>
P S の 末尾に mp の v 番目 を追加する	PS . append ( mp [ v ] )	PS . append ( mp [ v ] ) <eos>
2 に x m を 掛け た 値 から x q を 引 いた 値を x r とする	xr = 2 * xm - xq	xr = 2 * x - q <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ year 、 name とする	year , name = input ( ) . split ( )	name , inorder = input ( ) . split ( ) <eos>
n _ max から n _ min を 引 いた 値 を出力する	print ( n_max - n_min )	print ( n_min - n_min ) <eos>
x を 58 だけ 増加 させる	x += 58	x += <unk> <eos>
a が d ic に含まれる とき 、 <blk> d ic の a 番目 を p の 整数値 だけ 増加 させる </blk>	if a in dic : <blk> dic [ a ] += int ( p ) </blk>	if a in dic : <blk> dic [ a ] += int ( p ) </blk> <eos>
a の 3 番目 に 36 00 を 掛け た 値に a の 4 番目 に 60 を 掛け た 値 を加え た 値に a の 5 番目 を加え た 値を x とする	x = a [ 3 ] * 3600 + a [ 4 ] * 60 + a [ 5 ]	x = a [ 3 ] * 3600 + a [ 4 ] * 60 + a [ 4 ] <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列の 整数値 を m とする </blk>	try : <blk> m = int ( input ( ) ) </blk>	try : <blk> m = int ( input ( ) ) </blk> <eos>
j に j に x を 掛け た 値を 100 で 割 った 値 を加え た 値の 整数値 を j _ t a x とする	j_tax = int ( j + j * x / 100 )	i_tax = int ( j + j * x / 100 ) <eos>
OFF を r o op とする	roop = "OFF"	roop = "OFF" <eos>
not Updated の とき 、	if notUpdated :	if notUpdated : <eos>
self の 先頭から y を探し て 見つかった 位置 を y _ root とする	y_root = self . find ( y )	y_root = self . find ( y ) <eos>
tmp を re t とする	ret = tmp	ret = tmp <eos>
ll を l とする	l = ll	l = ll <eos>
T から 1 を 引 いた 値 、 0 を T 、 an s とする	T , ans = T - 1 , 0	T , ans = T - 1 , 0 <eos>
逆 順に points の キー の集まり のリスト を ソート した 列 を rank とする	rank = sorted ( list ( points . keys ( ) ) , reverse = True )	rank = sorted ( list ( points . keys ( ) ) ) [ : ] <eos>
st one から a の k 番目 を 引 いた 値を st one とする	stone = stone - a [ k ]	stone = stone - a [ k ] <eos>
H が 0 と 等 し く かつ W が 0 と 等しい とき 、	if H == 0 and W == 0 :	if H == 0 and W == 0 : <eos>
0 から 、 つまり 入力された 文字列の 整数値 未 満 までの 数 列 の各要素 を j と し 、 、 つまり 入力された 文字列の 整数値 の 列 のリスト を 順に i として 、 繰 り 返す	for i in list ( [ int ( input ( ) ) for j in range ( int ( input ( ) ) ) ] ) :	for i , i in list ( [ int ( input ( ) ) for j in range ( int ( input ( ) ) ) ] ) : <eos>
l ca ( 0 ) を an s とする	ans = lca ( 0 )	ans = lca ( 0 ) <eos>
get ( y ) を v とする	v = get ( y )	v = get ( y ) <eos>
l m 0 を l m とする	lm = lm0	lcm = <unk> <eos>
0 から 1000 未 満 までの 数 列 の各要素 を _ と し 、 ' Hello World ' を出力する の 列	[ print ( 'Hello World' ) for _ in range ( 1000 ) ]	print ( [ 'Hello World' for _ in range ( 1000 ) ] ) <eos>
42 80 から 11 50 に 12 50 を加え た 値に 1 400 を加え た 値に n から 30 を 引 いた 値に 16 0 を 掛け た 値 を加え た 値を 引 いた 値を返す	return 4280 - ( 1150 + 1250 + 1400 + ( n - 30 ) * 160 )	return 4280 - ( 1150 + 1250 + 1400 + ( n - 30 ) * 160 <eos>
0 が i に p を加え た 値 以下 かどうか が 8 より小さい とき 、	if 0 <= i + p < 8 :	if 0 <= i + p < 8 : <eos>
step が n step より小さい とき 、	if step < nstep :	if step < n : <eos>
( 1 、 -1 、 W に 2 を加え た 値 、 - W から 2 を 引 いた 値 ) の 組 を move とする	move = ( 1 , - 1 , W + 2 , - W - 2 )	move = ( 1 , - 1 , W + 2 , - W , - 2 ) <eos>
d p の state 0 番目 を d 0 とする	d0 = dp [ state0 ]	d0 = dp [ state0 ] <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列に '@' を加え た 値を b とする </blk>	try : <blk> b = input ( ) + '@' </blk>	try : <blk> b = str ( input ( ) ) + '@' </blk> <eos>
0 を v とする	v = 0	v = 0 <eos>
d の 2 番目 を x の i 番目 から y の i 番目 を 引 いた 値の 絶対値 の 3 乗 だけ 増加 させる	d [ 2 ] += abs ( x [ i ] - y [ i ] ) ** 3	d [ 2 ] += abs ( x [ i ] - y [ i ] ) ** 3 <eos>
改行 せずに " H " を出力する	print ( "H" , end = "" )	print ( " " , end = "" ) <eos>
U	U	U <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 を f _ line とする	f_line = file_input . readline ( ) . split ( )	<unk> = file_input . readline ( ) . split ( ) <eos>
Q 0 を展開し 、 それぞれ x 2 、 y 2 とする Q 1 を展開し 、 それぞれ a 2 、 b 2 とする	x2 , y2 = Q0 a2 , b2 = Q1	x2 , y2 = Q0 <eos>
N が l c m と 等しくない とき 、	if ( N != lcm ) :	if N != lcm : <eos>
s 内の si の 出現 回数 を re t val の i 番目 にする	retval [ i ] = s . count ( si )	retval [ i ] = s . count ( si ) <eos>
\\\\\ ' \\\\ \\\\ n ' を 間 に入れ て d の key 番目 を 連結 した 文字列を an s の i 番目 にする \\\\\	\\\\\ans [ i ] = '\\\\\\\\n' . join ( d [ key ] )\\\\\	\\\\\ans [ i ] = '\\\\\\\\n' . join ( [ str ( key ] ) ) <eos>\
Open を出力する	print ( "Open" )	print ( sum ) <eos>
_ num が 0 と 等しくない とき 、	if _num != 0 :	if _num != 0 : <eos>
G の y から 1 を 引 いた 値 番目の 末尾に x から 1 を 引 いた 値 を追加する	G [ y - 1 ] . append ( x - 1 )	G [ y - 1 ] . append ( x - 1 ) <eos>
3 から S Q RT 未 満 までの 2 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 3 , SQRT , 2 ) :	for i in range ( 3 , QS , 2 ) : <eos>
v の 末尾に v w の 先頭の 整数値 を追加する	v . append ( int ( vw [ 0 ] ) )	v . append ( int ( v [ 0 ] ) ) <eos>
a の i 番目 を 展開 して を出力する	print ( * a [ i ] )	print ( * a [ i ] ) <eos>
' D ' を そうでなければ 、 とする	else = 'D'	else = 'D' <eos>
' no ' を answer s の i 番目 にする	answers [ i ] = 'no'	answers [ i ] = 'no' <eos>
S の集合 を S とする	S = set ( S )	S = set ( S ) <eos>
day を limit _ day とする	limit_day = day	limit_day = day <eos>
i を 順に num として 、 繰 り 返す	for num in i :	for num in i : <eos>
辞書を self の table にする	self . table = dict ( zip ( dataset , [ 1 ] * len ( dataset ) ) )	self . table = dict ( ) <eos>
0 から V 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を parent とする	parent = [ [ ] for i in range ( V ) ]	parent = [ [ ] for i in range ( V ) ] <eos>
( " S " 、 " H " 、 " C " 、 " D " ) からなる 列 を 順に c として 、 繰 り 返す	for c in [ "S" , "H" , "C" , "D" ] :	for c in [ "S" , "H" , "C" , "D" ] : <eos>
_ d ice 2 を 深く コピー した 結果を d ice 2 とする	dice2 = copy . deepcopy ( _dice2 )	dice2 = copy . deepcopy ( dice2 ) <eos>
stack の 長さが 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if len ( stack ) == 0 : <blk> break </blk>	if len ( stack ) == 0 : <blk> break </blk> <eos>
改行 せずに s y m 2 を出力する	print ( sym2 , end = "" )	print ( <unk> , end = "" ) <eos>
関数 connect ed を self 、 x 、 y を パラメータ として 定義する self の 先頭から x を探し て 見つかった 位置 が self の 先頭から y を探し て 見つかった 位置 と 等しい かどうか を返す	def connected ( self , x , y ) : return self . find ( x ) == self . find ( y )	def visited ( x , y ) : return self . find ( y , self . find ( x ) ) == self . find ( y ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を b r 1 とする	br1 = list ( map ( int , input ( ) . split ( ) ) )	b1 = list ( map ( int , input ( ) . split ( ) ) ) <eos>
leaf s を追加して node s を更新する	nodes . update ( leafs )	nodes . update ( leafs . nodes ) <eos>
an s が IN F と 等しい とき 、	if ans == INF :	if ans == INF : <eos>
( 0 ) からなる 列 の N に 1 を加え た 値 回 分 の 列 を an s とする	ans = [ 0 ] * ( N + 1 )	ans = [ 0 ] * ( N + 1 ) <eos>
a の末尾 を 展開 して を出力する	print ( * a [ - 1 ] )	print ( * a [ - 1 ] ) <eos>
1 を出力する	print ( "1" )	print ( 1 ) <eos>
p at i ent 、 high を出力する	print ( patient , high )	print ( "node high , high ) <eos>
\\\\\ ' \\\\ \\\\ n ' を 間 に入れ て 0 から q 未 満 までの 数 列 の各要素 を i と し 、 b l ( A , int ( f _ i . readline ( ) ) ) の 文字列の 列 を 連結 した 文字列 を出力する \\\\\	\\\\\print ( '\\\\\\\\n' . join ( [ str ( bl ( A , int ( f_i . readline ( ) ) ) ) for i in range ( q ) ] ) )\\\\\	\\\\\print ( '\\\\\\\\n' . join ( [ str ( f_i . readline ( ) ) for i in range ( q ) ] , int ( q ) ) )\\\\ <eos>\
X の x に w を加え た 値 番目 を 1 だけ 減 少 させる	X [ x + w ] -= 1	X [ x + w ] -= 1 <eos>
r 2 から r 1 を 引 いた 値を rw とする	rw = r2 - r1	<unk> = r2 - 1 <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の 総 和 を出力する </blk>	try : <blk> print ( sum ( map ( int , input ( ) . split ( ) ) ) ) </blk>	try : <blk> print ( sum ( map ( int , input ( ) . split ( ) ) ) </blk> <eos>
s を v だけ 増加 させる	s += v	s += v <eos>
0 から t の 長さ 未 満 までの 数 列 の各要素 を i と し 、 t の i 番目 から 、 つまり 末 尾 までの 部分 列 の先頭 が p で始まる ときの i を出力する の 列	[ print ( i ) for i in range ( len ( t ) ) if t [ i : ] . startswith ( p ) ]	[ print ( <unk> ( t [ i : ] ) for i in range ( len ( t ) if t [ i : ] ) if t [ 0 : ] ] ) <eos>
self の ed ge の f r 番目の 長さ 、 self の ed ge の to 番目の 長さ を f 、 t とする	f , t = len ( self . edge [ fr ] ) , len ( self . edge [ to ] )	self . to = len ( self . edge [ fr ] ) , len ( self . edge [ to ] ) <eos>
link ed list の arg の先頭に [ MASK ] を 挿入 する	linkedlist . insert ( arg [ 0 ] )	linkedlist . insert ( arg [ 0 ] ) <eos>
f _ i から 読み込んだ 一行 の 整数値 を n 0 とする	n0 = int ( f_i . readline ( ) )	n0 = int ( f_i . readline ( ) ) <eos>
len を出力する	print ( len )	print ( len ( len ) ) <eos>
p x 、 py を x 、 y とする	x , y = px , py	px , y = px , py <eos>
k を 2 だけ 増加 させる	k += 2	k += 2 <eos>
2 * ( y 1 - y 3 ) * py から x 1 ** 2 を 引 いた 値 から y 1 の 2 乗 を 引 いた 値に x 3 の 2 乗 を加え た 値に y 3 の 2 乗 を加え た 値を 2 に x 3 から x 1 を 引 いた 値を 掛け た 値で 割 った 値を p x とする	px = ( 2 * ( y1 - y3 ) * py - x1 ** 2 - y1 ** 2 + x3 ** 2 + y3 ** 2 ) / ( 2 * ( x3 - x1 ) )	py = ( 2 * ( y1 - y3 ) + x1 ** 2 - y1 ** 2 + x2 ** 2 - x1 ) / ( y1 - x2 ) <eos>
入力された 文字列の 英 大 小文字 を 交換 した 文字列 を出力する	print ( input ( ) . swapcase ( ) )	print ( input ( ) . swapcase ( ) ) <eos>
ip ( coord 2 , coord 3 ) を展開し 、 それぞれ x 2 、 y 2 とする	x2 , y2 = ip ( coord2 , coord3 )	x2 , y2 = ip ( ip , coord3 ) <eos>
i を m で 割 った 余 り の とき 、 <blk> an s を p の i から 1 を 引 いた 値 番目 だけ 増加 させる </blk>	if i % m : <blk> ans += p [ i - 1 ] </blk>	if i % m : <blk> ans += p [ i - 1 ] </blk> <eos>
exc h 1 を 順に l 1 、 l 2 として 、 繰 り 返す	for l1 , l2 in exch1 :	for l1 , l2 in exch3 : <eos>
op が '/ ' と 等しい とき 、	if op == '/' :	if op == '/' : <eos>
a d j _ list の 2 番目の 先頭 を 削 除 する	del adj_list [ 2 ] [ 0 ]	del adj_list [ 2 ] [ 0 ] <eos>
1 から n を 2 で 割 った 商 に 1 を加え た 値 未 満 までの 数 列 を 反 転 した 列 を 順に i として 、 繰 り 返す	for i in reversed ( range ( 1 , n // 2 + 1 ) ) :	for i in reversed ( range ( 1 , n // 2 + 1 ) ) : <eos>
入力された 文字列 の浮動小数点数 を N とする	N = float ( input ( ) )	N = float ( input ( ) ) <eos>
a d j _ cross _ point の リストを cp _ list とする	cp_list = list ( adj_cross_point )	cp_list = list ( adj_cross_point ) <eos>
n が 2 より小さい とき 、	if n < 2 :	if n < 2 : <eos>
i に i を 掛け た 値 から MAX 未 満 までの i 間 隔 の数 列 を 順に j として 、 繰 り 返す	for j in range ( i * i , MAX , i ) :	for j in range ( i * i , MAX , i ) : <eos>
0 から v 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( v ) :	for k in range ( v ) : <eos>
0 から group 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( group ) :	for i in range ( group ) : <eos>
R の i 番目の m 番目 が 、 つまり 未 定 値 と 等しくない とき 、	if R [ i ] [ m ] != None :	if R [ i ] [ m ] is None : <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ Ex 、 E y 、 E z とする	Ex , Ey , Ez = map ( int , f_i . readline ( ) . split ( ) )	<unk> , E , <unk> = map ( int , f_i . readline ( ) . split ( ) ) <eos>
d p の 1 を V から 1 を 引 いた 値 だけ 左 シフト した 値 から 1 を 引 いた 値 番目 を d p _ comp とする	dp_comp = dp [ ( 1 << ( V - 1 ) ) - 1 ]	<unk> = dp [ 1 << ( V - 1 ) - d ] <eos>
lines の 1 番目 から 1 に n を加え た 値 までの 部分 列 の各要素 に string _ to _ complex を 適用 した 列 に 番号 付 した 組 の 列 を ed ge s とする	edges = enumerate ( map ( string_to_complex , lines [ 1 : 1 + n ] ) )	edges = enumerate ( map ( string_to_complex , lines [ 1 : 1 + n ] ) ) <eos>
( 0 ) からなる 列 の W に 1 を加え た 値 回 分 の 列 を w とする	w = [ 0 ] * ( W + 1 )	w = [ 0 ] * ( W + 1 ) <eos>
ma 、 d の 最大 値を ma とする	ma = max ( ma , d )	ma = max ( ma , d ) <eos>
res 、 d f s ( n y , n x , count + 1 ) の 最小 値を res とする	res = min ( res , dfs ( ny , nx , count + 1 ) )	res = min ( res , dfs ( n + dy , x + 1 ) ) <eos>
a の 1 番目の 整数値 を y とする	y = int ( a [ 1 ] )	y = int ( a [ 1 ] ) <eos>
C x 、 C y を出力する	print ( Cx , Cy )	print ( "Case " , y ) <eos>
side を cur の j 番目 にする	cur [ j ] = side	cur [ j ] = side <eos>
stack の 末尾に in p を追加する	stack . append ( inp )	stack . append ( inp ) <eos>
1 を dir の y 番目の x 番目 にする	dir [ y ] [ x ] = 1	dir [ dir ] [ x ] = 1 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を __ と し 、 __ の 整数値 の 列 を 展開 し 、 それぞれ tea m 、 m 1 、 s 1 、 m 2 、 s 2 、 m 3 、 s 3 、 m 4 、 s 4 とする	team , m1 , s1 , m2 , s2 , m3 , s3 , m4 , s4 = [ int ( __ ) for __ in input ( ) . split ( ) ]	teams , 1 , x2 , y2 , m3 , s3 = [ int ( __ ) for __ in input ( ) . split ( ) ] <eos>
a 、 b 、 c の 最小 値を z とする	z = min ( a , b , c )	z = min ( a , b , c ) <eos>
i に 1 を加え た 値が buf の 長さ 以上の とき 、	if i + 1 >= len ( buf ) :	if i + 1 >= len ( buf ) : <eos>
0 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> tea m の i 番目の 2 番目 を出力する </blk>	for i in range ( n ) : <blk> print ( team [ i ] [ 2 ] ) </blk>	for i in range ( n ) : <blk> print ( team [ i ] [ 2 ] ) </blk> <eos>
p の各要素 を x と し 、 ' ' を 間 に入れ て x を 連結 した 文字列 を出力する の 列	[ print ( ' ' . join ( x ) ) for x in p ]	print ( ' ' . join ( [ ' . join ( x ) for x in p ] ) ) <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ N 、 C とする	N , C = map ( int , f_i . readline ( ) . split ( ) )	N , C = map ( int , f_i . readline ( ) . split ( ) ) <eos>
N が high _ max より大きい とき 、 <blk> N を high _ max とする </blk>	if N > high_max : <blk> high_max = N </blk>	if N > max_high : <blk> max_high = N </blk> <eos>
tm に ts を加え た 値を s l v g _ t m とする	slvg_tm = tm + ts	slvg_tm = tm + ts <eos>
d _ list 、 v _ list の 要素を それぞれ 組 に した 列 の各要素 を d 、 v と し 、 m v に d を 掛け た 値を v で 割 った 商 の 列 を x とする	x = [ mv * d // v for d , v in zip ( d_list , v_list ) ]	x = ( [ d * v for v , d in zip ( d_list , dv ) // d ) ] <eos>
0 から 2 に n を 掛け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の各要素 を i と し 、 max _ v の 列 を A とする	A = [ max_v for i in range ( 2 * n - 1 ) ]	A = [ [ INF for i in range ( 2 * n - 1 ) ] for i in range ( 2 * n - 1 ) ] <eos>
A が 、 つまり 未 定 値 と 等しくない とき 、	if A is None :	if A is None : <eos>
0 を min _ i とする	min_i = 0	min_i = 0 <eos>
( frame 、 未 定 値 ) からなる 列 を output s の v t x 番目 にする	outputs [ vtx ] = [ frame , None ]	outputs [ vtx ] = [ None , None ] <eos>
d i j k str a ( g 1 , a d j _ back , n ) を d 2 とする	d2 = dijkstra ( g1 , adj_back , n )	d2 = dijkstra ( g1 , adj_back , n ) <eos>
v を 10 倍 にする	v *= 10	v *= 10 <eos>
a 2 を g 1 で 割 った 商 、 - d 1 を g 1 で 割 った 商 を p 、 q とする	p , q = a2 // g1 , - d1 // g1	p , q = a2 // g1 , ( a2 - d // g1 ) <eos>
{ 0 } : を 書式 として M で 整 形 した 文字列に " " を 間 に入れ て iter の リストを ソート した 列 の各要素 を i と し 、 i の 文字列の 列 を 連結 した 文字列 を加え た 値を d の M 番目 にする	d [ M ] = "{0}: " . format ( M ) + " " . join ( [ str ( i ) for i in sorted ( list ( iter ) ) ] )	M [ dic [ i ] = sorted ( list ( "" . join ( sorted ( sorted ( M ) ) ) ) for i in G0 ] ) <eos>
M を 順に m として 、 繰 り 返す	for m in M :	for m in M : <eos>
round が 9 より小さい とき 、	if round < 9 :	if round < 9 : <eos>
X の 0 番目 を 1 だけ 増加 させる	X [ 0 ] += 1	X [ 0 ] += 1 <eos>
i に 2 を 掛け た 値が n より小さい とき 、 <blk> 改行 せずに ' left key = % d , ' を a の i に 2 を 掛け た 値 番目 で 割 った 余 り を出力する </blk>	if i * 2 < n : <blk> print ( 'left key = %d, ' % a [ i * 2 ] , end = '' ) </blk>	if i * 2 < n : <blk> print ( <unk> key = %d, ' ' * a [ i ] , end = '' ) </blk> <eos>
L の x 番目の 末尾に num を追加する	L [ x ] . append ( num )	L [ x ] . append ( num ) <eos>
x の 絶対値 が 0.0 000 1 より小さい とき 、	if abs ( x ) < 0.00001 :	if abs ( x ) < <unk> : <eos>
a 、 b 、 c の 最大 値を v とする	v = max ( a , b , c )	v = max ( a , b , c ) <eos>
プログラムを 正 常 終了 する	sys . exit ( )	sys . exit ( ) <eos>
d p の i 番目の l im から 1 を 引 いた 値 番目 が w より小さい とき 、 <blk> d p の i 番目の l im から 1 を 引 いた 値 番目 を w とする </blk>	if dp [ i ] [ lim - 1 ] < w : <blk> w = dp [ i ] [ lim - 1 ] </blk>	if dp [ i ] [ lim - 1 ] < w : <blk> w = dp [ l ] [ i - 1 ] </blk> <eos>
Time の 3 番目の 1 番目の 浮動小数点数 が h ok et s u _ 2 の 1 番目の 浮動小数点数 より小さい とき 、	if float ( Time [ 3 ] [ 1 ] ) < float ( hoketsu_2 [ 1 ] ) :	if float ( Time [ 3 ] [ 1 ] ) < float ( hoketsu_1 [ 2 ] ) : <eos>
( R の 先頭から P の先頭 を 引 いた 値 、 R の 1 番目 から P の 1 番目 を 引 いた 値 ) からなる 列 を P R とする	PR = [ R [ 0 ] - P [ 0 ] , R [ 1 ] - P [ 1 ] ]	P = [ R [ 0 ] - P [ 0 ] , P [ 1 ] - P [ 1 ] ] <eos>
2 から d の . 5 乗 の 整数値 に 1 を加え た 値 未 満 までの 数 列 を 順に x として 、 繰 り 返す	for x in range ( 2 , int ( d ** . 5 ) + 1 ) :	for x in range ( 2 , int ( d ** . 5 ) + 1 ) : <eos>
s と a の k 番目 を 割 ったとき の ( 商 を 展開 し 、 それぞれ c 、 s とする	c , s = divmod ( s , a [ k ] )	s , c = divmod ( s , a [ k ] ) <eos>
1 を a 2 とする	a2 = 1	a2 = 1 <eos>
d 2 を m at の y 番目の x 番目 にする	mat [ y ] [ x ] = d2	mat [ y ] [ x ] = d2 <eos>
decode ( encode ( input ( ) ) ) を出力する	print ( decode ( encode ( input ( ) ) ) )	print ( decode ( input ( ) ) ) <eos>
x が ' I ' と 等しい とき 、	if x == 'I' :	if x == 'I' : <eos>
d に i を加え た 値を 4 で 割 った 余 り を nd とする	nd = ( d + i ) % 4	nd = ( d + i ) % 4 <eos>
y 1 から y 0 を 引 いた 値の 絶対値 が 1 より大きい とき 、	if abs ( y1 - y0 ) > 1 :	if abs ( y1 - y0 ) > 1 : <eos>
1 から W に 1 を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 1 , W + 1 ) :	for j in range ( 1 , W + 1 ) : <eos>
0 から s から 1 を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( s - 1 ) :	for i in range ( s - 1 ) : <eos>
x 1 に w 2 を 掛け た 値に y 1 に z 2 を 掛け た 値 を加え た 値 から z 1 に y 2 を 掛け た 値を 引 いた 値に w 1 に x 2 を 掛け た 値 を加え た 値を a 4 とする	a4 = x1 * w2 + y1 * z2 - z1 * y2 + w1 * x2	aa = x1 * w2 + y1 * z2 - z1 * z2 - x1 * z2 <eos>
insert ion S or t ( A , n , G [ k ] )	insertionSort ( A , n , G [ k ] )	insertionSort ( A , n , G [ k ] ) <eos>
1 から n に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , n + 1 ) :	for i in range ( 1 , n + 1 ) : <eos>
items を 順に item として 、 繰 り 返す	for item in items :	for item in items : <eos>
1 00000 を S とする	S = 100000	S = 100000 <eos>
n が 30 より大きい とき 、	if n > 30 :	if n > 30 : <eos>
e が IN F 以上の とき 、 <blk> -1 を e とする </blk>	if e >= INF : <blk> e = - 1 </blk>	if e >= INF : <blk> e = - 1 </blk> <eos>
{ 0 : . 8 f } { 1 : . 8 f } を 書式 として s x 、 s y で 整 形 した 文字列 を出力する	print ( "{0:.8f} {1:.8f}" . format ( sx , sy ) )	print ( "{0:.8f} {1:.8f}" . format ( sx , sy ) ) <eos>
s の 長さ を a とする	a = len ( s )	a = len ( s ) <eos>
p の y に 1 を加え た 値 番目の x から 1 を 引 いた 値 番目 に 1 を加え た 値を p の y に 1 を加え た 値 番目の x から 1 を 引 いた 値 番目 にする	p [ y + 1 ] [ x - 1 ] = p [ y + 1 ] [ x - 1 ] + 1	p [ y + 1 ] [ x - 1 ] = p [ y + 1 ] [ x - 1 ] + 1 <eos>
b の i 番目 が a の j 番目 と 等しい とき 、	if b [ i ] == a [ j ] :	if b [ i ] == a [ j ] : <eos>
an s が 0 より小さい とき 、 <blk> 0 を an s とする </blk>	if ans < 0 : <blk> ans = 0 </blk>	if ans < 0 : <blk> ans = 0 </blk> <eos>
k y o を返す	return "kyo"	return <unk> <eos>
lists の arg の先頭 番目 内の 全ての要素 を 取り除く	lists [ arg [ 0 ] ] . clear ( )	<unk> [ arg [ 0 ] ] . clear ( ) <eos>
x を パラメータ として ( x の先頭 、 x の 2 番目 ) の 組 を返す 関数を key として events を ソート する	events . sort ( key = lambda x : ( x [ 0 ] , x [ 2 ] ) )	events . sort ( key = lambda x : ( x [ 0 ] , x [ 2 ] ) ) <eos>
target _ list の i 番目 を target とする	target = target_list [ i ]	target = <unk> [ i ] <eos>
s の i 番目 を a の i i 番目 だけ 増加 させる	s [ i ] += a [ ii ]	s [ i ] += a [ i ] <eos>
'{: . 10 f } ' を 書式 として time で 整 形 した 文字列 を出力する	print ( '{:.10f}' . format ( time ) )	print ( '{:.6f}' . format ( time ) ) <eos>
dist ance _ g g ( p o ly 0 , tmp ) に e p s を加え た 値が L より大きい とき 、	if distance_gg ( poly0 , tmp ) + eps > L :	if <unk> ( poly0 , ep + tmp ) > L : <eos>
x が 0 以下 または x に y を加え た 値が q 1 より小さい とき 、	if x <= 0 or x + y < q1 :	if x <= 0 or x + y < q : <eos>
\\\\\ write ( " % d \\\\ \\\\ n " % sum ( mk ) ) \\\\\	\\\\\write ( "%d\\\\\\\\n" % sum ( mk ) )\\\\\	\\\\\write ( "%d\\\\\\\\n" % sum ( mk ) )\\\\ <eos>\
an s に 2 を 掛け た 値 から i に i を 掛け た 値を 引 いた 値を an s とする	ans = ans * 2 - i * i	ans = ans * 2 - i * i <eos>
x -1 + y -1 に 1 を加え た 値の 整数値 に g cd を 掛け た 値に 1 を加え た 値 を出力する	print ( int ( x - 1 + y - 1 + 1 ) * gcd + 1 )	print ( int ( ( x + 1 - 1 ) * gcd ( y + 1 ) ) ) <eos>
n と 1 の 論理 積 の とき 、 <blk> 繰り返し を 中断 する </blk>	if n & 1 : <blk> break </blk>	if n & 1 : <blk> break </blk> <eos>
E 2 を E 1 とする	E1 = E2	E1 = E2 <eos>
c が a より小さい とき 、	if c < a :	if c < a : <eos>
n が 0 と 等 し く かつ x が 0 と 等しい とき 、	if n == 0 and x == 0 :	if n == 0 and x == 0 : <eos>
0 から direction の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( direction ) ) :	for i in range ( len ( direction ) ) : <eos>
k が 0 と 等しい とき 、	if k == 0 :	if k == 0 : <eos>
tea m の a 番目の 1 番目 を 1 だけ 増加 させる	team [ a ] [ 1 ] += 1	team [ a ] [ 1 ] += 1 <eos>
( 1 ) からなる 列 の 30 1 回 分 の 列 を d p とする	dp = [ 1 ] * 301	dp = [ 1 ] * 30 <eos>
R の i 番目の j 番目の とき 、	if R [ i ] [ j ] :	if R [ i ] [ j ] : <eos>
( 0 ) からなる 列 の 4 回 分 の 列 を c n t とする	cnt = [ 0 ] * 4	cnt = [ 0 ] * 4 <eos>
n に n から 1 を 引 いた 値を 掛け た 値を 2 で 割 った 値の 整数値 を rt _ n とする	rt_n = int ( n * ( n - 1 ) / 2 )	<unk> = int ( n * ( n - 1 ) / 2 ) <eos>
空 列 を s ch とする	sch = [ ]	sch = [ ] <eos>
c _ in p が s に含まれる とき 、	if c_inp in s :	if c_inp in s : <eos>
b が 0 と 等しくない 間 、 次 を 繰 り 返す	while b != 0 :	while b != 0 : <eos>
区切り なしで 改行 せずに " " 、 of の i 番目の j 番目 を出力する	print ( " " , of [ i ] [ j ] , sep = "" , end = "" )	print ( " " , i , sep = "" , end = "" ) <eos>
numbers を 1 を 初期値 として l c m _ base で 集 約 した 列 を返す	return reduce ( lcm_base , numbers , 1 )	return reduce ( <unk> , numbers ) <eos>
p 2 の 長さが 0 より大きい とき 、	if len ( p2 ) > 0 :	if len ( p2 ) > 0 : <eos>
空 列 を vec t or とする	vector = [ ]	t_cost = [ ] <eos>
' ' を 間 に入れ て an s の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する	print ( ' ' . join ( map ( str , ans ) ) )	print ( ' ' . join ( map ( str , ans ) ) ) <eos>
math モジュール を用い る	from math import hypot	from math import cos , cos , radians <eos>
er a の i 番目 、 data を 10 000 で 割 った 商 から start _ data の i -1 番目 を 10 000 で 割 った 商 を 引 いた 値に 1 を加え た 値 、 m 、 d を出力する	print ( era [ i ] , data // 10000 - start_data [ i - 1 ] // 10000 + 1 , m , d )	print ( era [ i ] , data [ 10000 - 1 ] // 10000 - 1 , data [ i - 1 ] // 10000 + d ) <eos>
p の 2 乗 を p 2 とする	p2 = p ** 2	p = p ** 2 <eos>
board の i 番目の j 番目 が b より大きい とき 、	if board [ i ] [ j ] > b :	if board [ i ] [ j ] > b : <eos>
r 0 が a 以下 かどうか が r 1 以下の とき 、	if r0 <= a <= r1 :	if r0 <= a <= r1 : <eos>
1 を self の de gree にする	self . degree = 1	self . degree = 1 <eos>
file _ input から 読み込んだ 一行 の末尾 から 空白 改行 を取り 除 いた 文字列を first _ line とする	first_line = file_input . readline ( ) . rstrip ( )	first = file_input . readline ( ) . rstrip ( ) <eos>
i が 7 以上の とき 、 <blk> 繰り返し を 中断 する </blk>	if i >= 7 : <blk> break </blk>	if i >= 7 : <blk> break </blk> <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ N 、 M 、 P とする	N , M , P = map ( int , input ( ) . split ( ) )	N , M , P = map ( int , input ( ) . split ( ) ) <eos>
self の move を move とする	move = self . move	move = self . move <eos>
v s _ x に x 1 を 追加した 集 まり	vs_x . add ( x1 )	vs . add ( x1 ) <eos>
op の 2 番目の 整数値 を t とする	t = int ( op [ 2 ] )	t = int ( op [ 2 ] ) <eos>
co st を i だけ 増加 させる	cost += i	cost += i <eos>
table の i から 1 を 引 いた 値 番目の j 番目 が 1 と 等しい とき 、	if table [ i - 1 ] [ j ] == 1 :	if table [ i - 1 ] [ j ] == 1 : <eos>
{} : {} : {} を出力する	print ( { h } : { m } : { s } )	print ( { ch } ) <eos>
0 から M に 1 を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( M + 1 ) :	for j in range ( M + 1 ) : <eos>
verti ce s の値 の集まり の各要素 を val と し 、 v t x が val に含まれる ときの val  内の v t x と 等しい 要素を 取り除く の 列	[ val . remove ( vtx ) for val in vertices . values ( ) if vtx in val ]	[ vtx for vtx in vertices . keys ( ) if val in <unk> . values ( ) ] <eos>
\\\\\ write ( " % d % d % d % d \\\\ \\\\ n " % ( p s [ 0 ] + p s [ 1 ] ) ) \\\\\	\\\\\write ( "%d %d %d %d\\\\\\\\n" % ( ps [ 0 ] + ps [ 1 ] ) )\\\\\	\\\\\write ( "%d %d % dp [ 0 ] + ponds [ 1 ] % facts [ 1 ] ) )\\\\ <eos>\
x を y だけ 減 少 させる	x -= y	x -= y <eos>
0 から 10 未 満 までの 数 列 の各要素 を _ と し 、 input ( ) の 整数値 の 列 を ソート した 列 の 、 つまり 先頭から 6 番目 までの -1 間 隔 による 部分 列 の各要素 を i と し 、 i を出力する の 列	[ print ( i ) for i in ( sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : 6 : - 1 ] ) ]	print ( sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : - 1 ] ) <eos>
n と 1 の 論理 積 が 0 と 等しい とき 、 <blk> n を 1 だけ 減 少 させる </blk>	if ( n & 1 ) == 0 : <blk> n -= 1 </blk>	if n & 1 == 0 : <blk> n -= 1 </blk> <eos>
1 、 0 を k 、 j とする	k , j = 1 , 0	k , j = 1 , 0 <eos>
h ok et s u _ 1 を展開し て を出力する	print ( * hoketsu_1 )	print ( * hoketsu_1 ) <eos>
pos の 11 番目 を L とする	L = pos [ 11 ]	L = pos [ 11 ] <eos>
s を 36 00 で 割 った 商 を h とする	h = s // 3600	h = s // 3600 <eos>
root の a 番目 が root の b 番目 と 等しい とき 、	if root [ a ] == root [ b ] :	if root [ a ] == root [ b ] : <eos>
sum に s を加え た 値が 1 50 以下の とき " OK " 、 そうでなければ " N G " を出力する	print ( "OK" if sum + s <= 150 else "NG" )	print ( "OK" if sum + s + 1 else "NG" ) <eos>
c up 内の " D " を y で 置き換え た 文字列を c up とする	cup = cup . replace ( "D" , y )	cup = cup . replace ( y , <unk> ) <eos>
空 辞書を S とする	S = { }	S = { } <eos>
f を a に M を 掛け た 値 から t を 引 いた 値 だけ 増加 させる	f += a * M - t	f += a * M - t <eos>
time _ re c の 最小 値 を出力する	print ( min ( time_rec ) )	print ( min ( time_rec ) ) <eos>
obj の 先頭の 整数値 を obj の先頭に する	obj [ 0 ] = int ( obj [ 0 ] )	obj [ 0 ] = int ( obj [ 0 ] ) <eos>
n を 一 旦 、 返す	yield n	yield n <eos>
X に x から r を 引 いた 値を 追加した 集 まり	X . add ( x - r )	X . add ( x - r ) <eos>
M の E 1 番目 を tasks とする	tasks = M [ E1 ]	E1 = M [ 1 ] <eos>
d c が c から d c を 引 いた 値 より大きい とき 、 <blk> c から d c を 引 いた 値を d c とする </blk>	if dc > c - dc : <blk> dc = c - dc </blk>	if dc > c - d : <blk> c = c - d </blk> <eos>
v が K より小さい とき 、 <blk> an s を 1 だけ 増加 させる </blk>	if v < K : <blk> ans += 1 </blk>	if v < K : <blk> ans += 1 </blk> <eos>
t の 最大 値を max _ val とする	max_val = max ( t )	max_val = max ( t ) <eos>
t _ re c のコピー を pre v とする	prev = t_rec . copy ( )	prev = <unk> . copy ( ) <eos>
times の 末尾に B us time ( line 2 [ 2 * i + 1 ] , line 2 [ 2 * i + 2 ] ) を追加する	times . append ( Bustime ( line2 [ 2 * i + 1 ] , line2 [ 2 * i + 2 ] ) )	times . append ( <unk> ( line [ 2 * i + 1 ] , line2 [ i + 2 ] ) ) <eos>
空 辞書を both とする	both = { }	both = { } <eos>
{} {} {} を出力する	print ( { d } { f } { a / b : . 5 f } )	print ( { x } { y } ) <eos>
a に h を 掛け た 値を 2 で 割 った 値を s とする	s = a * h / 2	s = a * h / 2 <eos>
( 0 ) からなる 列 の N 回 分 の 列 を input _ ed ge とする	input_edge = [ 0 ] * N	input_edge = [ 0 ] * N <eos>
( ( ' A ' , 0 ) 、 ( ' B ' , 0 ) 、 ( ' A B ' , 0 ) 、 ( ' O ' , 0 ) ) からなる 辞書を count s とする	counts = { 'A' : 0 , 'B' : 0 , 'AB' : 0 , 'O' : 0 }	counts = { 'A' : 0 , 'B' : 0 , 'O' : 0 } <eos>
node の i 番目の 2 番目 を 1 だけ 増加 させる	node [ i ] [ 2 ] += 1	node [ i ] [ 2 ] += 1 <eos>
table の max top 番目 を 削 除 する	del table [ maxtop ]	del table [ maxtop ] <eos>
score _ list の j 番目 を 1 だけ 増加 させる	score_list [ j ] += 1	score_list [ j ] += 1 <eos>
y q 3 から y q から y q 3 を 引 いた 値を 引 いた 値を y q 2 とする	yq2 = yq3 - ( yq - yq3 )	yq2 = yq - y3 - yq <eos>
score を ソート する	score . sort ( )	score . sort ( ) <eos>
Ma p の 末尾に tmp を追加する	Map . append ( tmp )	Map . append ( tmp ) <eos>
in p の 、 つまり 先頭から 10 番目 までの 部分 列 を l とする	l = inp [ 0 : 10 ]	l = inp [ : 10 ] <eos>
0 から 20 1 未 満 までの 数 列 の各要素 を r と し 、 0 から 20 1 未 満 までの 数 列 の各要素 を c と し 、 0 の 列 の 列 を arr とする	arr = [ [ 0 for c in range ( 201 ) ] for r in range ( 201 ) ]	arr = [ [ 0 for c in range ( 20 ) ] for r in range ( 20 ) ] <eos>
P 1 の k 1 から 1 を 引 いた 値 番目 を q 0 とする P 1 の k 1 番目 を q 1 とする	q0 = P1 [ k1 - 1 ] q1 = P1 [ k1 ]	q0 = P1 [ k1 - 1 ] q1 [ q0 ] <eos>
m が 1 と 等しい とき 、 <blk> 0 を返す </blk>	if m == 1 : <blk> return 0 </blk>	if m == 1 : <blk> return 0 </blk> <eos>
( ( b , 1 から 5 未 満 までの 数 列 の各要素 を b と し 、 ( [ 0 ] の 10 回 分 の 列 、 [ 0 ] の 10 回 分 の 列 、 [ 0 ] の 10 回 分 の 列 ) からなる 列 の 列 ) ) からなる 辞書を build ing とする	building = { b : [ [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 ] for b in range ( 1 , 5 ) ] }	b = { b : [ 10 ] * [ 10 for b in [ 0 ] * 10 for 1 , 5 ] * 10 in [ 10 ] ] } <eos>
t _ d を a d j の t 番目の s 番目 にする	adj [ t ] [ s ] = t_d	adj [ t ] [ s ] = t_d <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を B とする	B = [ int ( _ ) for _ in input ( ) . split ( ) ]	B = [ int ( _ ) for _ in input ( ) . split ( ) ] <eos>
sys の stdin の各要素 に 整数 を 適用 した 列 を 順に n として 、 繰 り 返す	for n in map ( int , sys . stdin ) :	for n in map ( int , sys . stdin ) : <eos>
n を min _ high とする	min_high = n	high_low = n <eos>
a i 1 333 に " 3 " に year を 掛け た 値 を加え た 値 を出力する	print ( "ai1333" + "3" * year )	print ( <unk> * <unk> + " " * year ) <eos>
turn 2 ( p )	turn2 ( p )	<unk> ( p ) <eos>
0 、 q len を i 、 k とする	i , k = 0 , qlen	i , k = 0 , qlen <eos>
y が n 以上の とき 、	if y >= n :	if y >= n : <eos>
c c w ( p j , p k , p s ) の とき 、	if ccw ( pj , pk , ps ) :	if ccw ( p , k , s , p ) : <eos>
verti ce s を self の verti ce s にする	self . vertices = vertices	self . vertices = vertices <eos>
p rt の p 0 番目 が p rt の p 1 番目 と 等しい とき 、	if prt [ p0 ] == prt [ p1 ] :	if prt [ p0 ] == prt [ p1 ] : <eos>
co ls の v 0 番目 を c v とする	cv = cols [ v0 ]	cv = cols [ v0 ] <eos>
m at _ tmp の j 番目 を b の i 番目の j 番目 にする	b [ i ] [ j ] = mat_tmp [ j ]	b [ i ] [ j ] = tmp_row [ j ] <eos>
diff s が ( 1 ) からなる 列 の L から 1 を 引 いた 値 回 分 の 列 と 等しい かどうか を返す	return diffs == [ 1 ] * ( L - 1 )	return [ diff ] * ( L - 1 ) == L <eos>
cur _ node _ no を parent _ node _ no とする	parent_node_no = cur_node_no	parent_node_no = cur_node_no <eos>
C 1 に C 2 を加え た 値を point とする	point = C1 + C2	point = C1 + C2 <eos>
m の m の 長さ から 1 を 引 いた 値 番目 から m の先頭 を 引 いた 値 を出力する	print ( m [ len ( m ) - 1 ] - m [ 0 ] )	print ( m [ len ( m ) - 1 ] ) <eos>
s を ', ' で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ custom er 、 day とする	customer , day = map ( int , s . split ( ',' ) )	er , er , day = map ( int , s . split ( ',' ) ) <eos>
parent _ node _ no を node s の node _ no 番目の parent にする	nodes [ node_no ] . parent = parent_node_no	nodes [ node_no ] . parent = parent_node_no <eos>
single _ row が an s より大きい とき 、	if single_row > ans :	if <unk> > ans : <eos>
an s の 末尾に out の k 番目 を追加する	ans . append ( out [ k ] )	ans . append ( out [ k ] ) <eos>
co st の i 番目 、 co st の v 番目 に table の v 番目の i 番目 を加え た 値の 最小 値を co st の i 番目 にする	cost [ i ] = min ( cost [ i ] , cost [ v ] + table [ v ] [ i ] )	cost [ i ] = min ( cost [ i ] , cost [ v ] [ i ] + cost [ i ] ) <eos>
an s の 長さが N より小さい 間 、 次 を 繰 り 返す	while len ( ans ) < N :	while len ( ans ) < N : <eos>
c _ n が " print " と 等しい とき 、	if c_n == "print" :	if <unk> == "print" : <eos>
N を C で 割 った 余 り が 0 と 等しい とき 、	if N % C == 0 :	if N % C == 0 : <eos>
a の先頭 、 IN F を s 、 p とする	s , p = a [ 0 ] , INF	s , p = a [ 0 ] , INF <eos>
f _ in p の y 番目の x から 2 を 引 いた 値 番目の とき 、	if f_inp [ y ] [ x - 2 ] :	if f_inp [ y ] [ x - 2 ] : <eos>
line の i 番目の j 番目 が 1 と 等しい とき 、	if line [ i ] [ j ] == 1 :	if line [ i ] [ j ] == 1 : <eos>
G を ソート する	G . sort ( )	G . sort ( ) <eos>
s が '.' と 等しい とき 、	if s == '.' :	if s == '.' : <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を f とする </blk>	try : <blk> f = input ( ) </blk>	try : <blk> f = input ( ) </blk> <eos>
j から R の i - k 番目 を 引 いた 値が k より大きい かどうか が i 以下 かどうか が L から k を 引 いた 値 より小さい 間 、 次 を 繰 り 返す	while j - R [ i - k ] > k <= i < L - k :	while j - R [ i ] <= L - k < L - i : <eos>
tb l の i 番目の 1 番目 が tb l の i から 1 を 引 いた 値 番目の 1 番目 より小さい とき 、 <blk> ord を 1 だけ 増加 させる </blk>	if tbl [ i ] [ 1 ] < tbl [ i - 1 ] [ 1 ] : <blk> ord += 1 </blk>	if tbl [ i ] [ 1 ] < tbl [ i - 1 ] [ 1 ] : <blk> tbl [ 1 ] </blk> <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を ns とする	ns = list ( map ( str , input ( ) . split ( ) ) )	ns = list ( map ( int , input ( ) . split ( ) ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を tmp _ row とする	tmp_row = list ( map ( int , input ( ) . split ( ) ) )	tmp_row = list ( map ( int , input ( ) . split ( ) ) ) <eos>
a を n の i 番目 だけ 増加 させる	a += n [ i ]	a += n [ i ] <eos>
0 から d の 絶対値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( abs ( d ) ) :	for i in range ( abs ( d ) ) : <eos>
( ( e , x s に 番号 付 した 組 の 列 の各要素 を i 、 e と し 、 i の 列 ) ) からなる 辞書を m x とする	mx = { e : [ i for i , e in enumerate ( xs ) ] }	<unk> = { e : [ i for i , e in enumerate ( sorted ( s ) ) ] } <eos>
ソートされた 順序 を 保 った まま x を arr に 挿入 できる 位置 を l _ id x とする	l_idx = bisect . bisect_left ( arr , x )	l_idx = bisect . bisect_left ( arr , x ) <eos>
data を 順に m ark 、 num として 、 繰 り 返す <blk> m ark 、 num を出力する </blk>	for mark , num in data : <blk> print ( mark , num ) </blk>	for mark , num in data : <blk> print ( mark , num ) </blk> <eos>
number を " " だけ 増加 させる	number += " "	number += " " <eos>
2 を出力する	print ( 2 )	print ( <unk> ) <eos>
third の とき 、	if third :	if third : <eos>
入力された 文字列を " " で 分割 した 字句 列 を 展開 し 、 それぞれ word 、 page とする	word , page = input ( ) . split ( " " )	word , page = input ( ) . split ( " " ) <eos>
ソートされた 順序 を 保 った まま query の 2 番目 を Q の query の 1 番目 番目 に 挿入 できる 位置 を index とする	index = bisect . bisect_left ( Q [ query [ 1 ] ] , query [ 2 ] )	index = bisect . bisect_left ( Q [ 2 ] , Q [ query [ 1 ] ] ) <eos>
{} {} {} を出力する	print ( { x : . 03 f } { y : . 03 f } { r : . 03 f } )	print ( { x } { y } ) <eos>
y を 2 だけ 増加 させる	y += 2	y += 2 <eos>
a の先頭 を min v とする	minv = a [ 0 ]	minv = a [ 0 ] <eos>
inter section ( p [ i ] , p [ j ] ) を展開し 、 それぞれ p 1 、 p 2 とする	p1 , p2 = intersection ( p [ i ] , p [ j ] )	p1 , p2 = intersection ( p [ i ] , p [ j ] ) <eos>
itertools モジュール を用い る	from itertools import product	from itertools import permutations <eos>
B _ c ir c les の 先頭の a x is 1 番目 から B _ c ir c les の先頭 の先頭 を 引 いた 値を B _ ed ge とする	B_edge = B_circles [ 0 ] [ axis1 ] - B_circles [ 0 ] [ 0 ]	B_circles = B_circles [ 0 ] [ 1 ] - B [ 0 ] <eos>
m の 2 に i を 掛け た 値に 1 を加え た 値 番目 を 2 で 割 った 商 を k とする	k = m [ 2 * i + 1 ] // 2	k = m [ 2 * i + 1 // 2 ] <eos>
- E P S が s a 以下 かつ s a が E P S 以下の とき 、 <blk> 偽 を返す </blk>	if - EPS <= sa and sa <= EPS : <blk> return False </blk>	if - EPS <= sa and sa <= EPS : <blk> return False </blk> <eos>
cmath モジュール を用い る	from cmath import phase , rect , pi	from cmath import phase , pi <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を s とする </blk>	try : <blk> s = input ( ) </blk>	try : <blk> s = input ( ) </blk> <eos>
0 から 10 未 満 までの 数 列 を 順に l として 、 繰 り 返す	for l in range ( 10 ) :	for l in range ( 10 ) : <eos>
board の k 番目の j 番目 を d だけ 増加 させる	board [ k ] [ j ] += d	board [ k ] [ j ] += d <eos>
times の 末尾に B us time ( line 1 [ 2 * i + 1 ] , line 1 [ 2 * i + 2 ] ) を追加する	times . append ( Bustime ( line1 [ 2 * i + 1 ] , line1 [ 2 * i + 2 ] ) )	times . append ( <unk> ( line [ 1 ] * line2 [ i + 1 ] , line2 [ i + 1 ] ) ) <eos>
c ( self . value - other . value ) を返す	return c ( self . value - other . value )	return c ( self . value - other . value ) <eos>
A を s hop _ name とする	shop_name = "A"	shop_name = "A" <eos>
1 を 開始 番号 として P の 、 つまり 先頭から -2 番目 までの 部分 列 に 番号 付 した 組 の 列 を 順に i 、 b p として 、 繰 り 返す	for i , bp in enumerate ( P [ : - 2 ] , start = 1 ) :	for i , b in enumerate ( P [ : - 2 ] , start = 1 ) : <eos>
y を self の y 座 標 にする	self . y = y	self . y = y <eos>
最初 から もう 一度 、 繰 り 返す	continue	for continue in continue : <eos>
check ( a , n )	check ( a , n )	check ( a , n ) <eos>
( 、 つまり 入力された 文字列の 整数値 、 1 ) からなる 列 を a とする	a = [ int ( input ( ) ) , 1 ]	a = [ int ( input ( ) ) , 1 ] <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を quest ion とする	question = map ( int , file_input . readline ( ) . split ( ) )	question_lines = map ( int , file_input . readline ( ) . split ( ) ) <eos>
v . mul ( self . do t _ product ( v ) / v . qua d r ance ( ) ) を返す	return v . mul ( self . dot_product ( v ) / v . quadrance ( ) )	return abs ( v . dot ( self . dot ( v ) / d ) ) <eos>
n を 100 だけ 増加 させる	n += 100	n += 100 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を y とする	y = map ( int , input ( ) . split ( ) )	y = map ( int , input ( ) . split ( ) ) <eos>
n が 1 以下の とき 、 <blk> 繰り返し を 中断 する </blk>	if n <= 1 : <blk> break </blk>	if n <= 1 : <blk> break </blk> <eos>
1 を re t とする	ret = 1	ret = 1 <eos>
rect _ stack でなく または h が rect _ stack の末尾 の先頭 より大きい とき 、	if ( not rect_stack ) or ( h > rect_stack [ - 1 ] [ 0 ] ) :	if not rect_stack . rect_stack ( rect_stack [ - 1 ] [ 0 ] ) : <eos>
co st を c だけ 増加 させる	cost += c	cost += c <eos>
c n t が A より小さい とき 、	if cnt < A :	if cnt < A : <eos>
pos が 0 より大きい 間 、 次 を 繰 り 返す	while pos > 0 :	while pos > 0 : <eos>
0 から n に 1 を加え た 値 未 満 までの 数 列 を 順に r として 、 繰 り 返す	for r in range ( n + 1 ) :	for r in range ( n + 1 ) : <eos>
- b 12 から b q r を 引 いた 値を a 12 から a q r を 引 いた 値で 割 った 値を x m とする	xm = - ( b12 - bqr ) / ( a12 - aqr )	xr = - ( b2 - aqr ) / ( xq - a12 ) <eos>
s q [ now y ] [ now x ] が 0 と 等 し く かつ 0 が now x 以下 かつ now x が n より 小さく かつ 0 が now y 以下 かつ now y が n より小さい とき 、	if sq [ nowy ] [ nowx ] == 0 and 0 <= nowx and nowx < n and 0 <= nowy and nowy < n :	if sq [ nowy ] == 0 and nowy < 0 and nowy < nowx and nowy < n and nowy < 0 and nowx ) : <eos>
play ers の play er 番目 を 1 に table を加え た 値 だけ 増加 させる	players [ player ] += 1 + table	players [ player ] += 1 + table <eos>
c を e だけ 減 少 させる	c -= e	c -= e <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を b とする	b = input ( ) . split ( )	b = input ( ) . split ( ) <eos>
get _ color ( c c ) を出力する	print ( get_color ( cc ) )	print ( <unk> ( c ) ) <eos>
偽 を u の i 番目 にする	u [ i ] = False	u [ i ] = False <eos>
s 内の " apple " を " p e ach " で 置き換え た 文字列を s とする	s = s . replace ( "apple" , "peach" )	s = s . replace ( "apple" , "peach" ) <eos>
ls の先頭に lt の先頭 を追加する	ls . appendleft ( lt [ 0 ] )	ls . appendleft ( ls [ 0 ] ) <eos>
A の 末尾に ( node 、 parent 、 depth 、 name 、 root ) からなる 列 を追加する	A . append ( [ node , parent , depth , name , root ] )	A . append ( [ node , parent , depth , root ] ) <eos>
de e p en _ x の先頭 を取り出し た 値を pre _ x とする	pre_x = deepen_x . pop ( )	pre_x = <unk> . pop ( ) <eos>
S を 10 で 割 った 値の 切り捨て 整数値 を S とする	S = math . floor ( S / 10 )	S = math . floor ( S / 10 ) <eos>
self . roll ( ' E ' )	self . roll ( 'E' )	self . roll ( 'E' ) <eos>
( 0 ) からなる 列 の MAX に 1 を加え た 値 回 分 の 列 を tb l とする	tbl = [ 0 ] * ( MAX + 1 )	tbl = [ 0 ] * ( MAX + 1 ) <eos>
n を出力する	print ( n )	print ( n ) <eos>
s 1 の v 1 番目 を w 1 とする	w1 = s1 [ v1 ]	w1 = s1 [ v1 ] <eos>
con tra c t _ cycle ( d i grap h , C , r )	contract_cycle ( digraph , C , r )	<unk> ( graph , r , C ) <eos>
p を 順に p 1 として 、 繰 り 返す	for p1 in p :	for p1 in p : <eos>
空 列 を tuple s とする	tuples = [ ]	tuples = [ ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を n とする	n = input ( ) . split ( )	n = input ( ) . split ( ) <eos>
入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を M とする	M = list ( map ( int , input ( ) . strip ( ) . split ( ) ) )	M = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <eos>
d 0 を S の b 番目の c 番目 だけ 増加 させる	d0 += S [ b ] [ c ]	d0 += S [ b ] [ c ] <eos>
n が 0 と 等しい とき 、	if n == 0 :	if n == 0 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト に ( -1 ) からなる 列 を加え た 値を p とする	p = list ( map ( int , input ( ) . split ( ) ) ) + [ - 1 ]	p = [ list ( map ( int , input ( ) . split ( ) ) ) ] + [ - 1 ] <eos>
total _ cal を t _ cal の i 番目 だけ 増加 させる	total_cal += t_cal [ i ]	total_cost += <unk> [ i ] <eos>
Y に 19 25 を加え た 値 を出力する	print ( Y + 1925 )	print ( Y + 1925 ) <eos>
an s の 、 つまり 先頭から j から 1 を 引 いた 値 までの 部分 列 を返す	return ans [ 0 : j - 1 ]	return ans [ : j - 1 ] <eos>
( 0 ) からなる 列 の 3 回 分 の 列 、 ( 0 ) からなる 列 の 3 回 分 の 列 、 ( 0 ) からなる 列 の 3 回 分 の 列 を n 、 k 、 f とする	n , k , f = [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3	f , f , f = [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ p 0 _ x 、 p 0 _ y 、 p 1 _ x 、 p 1 _ y とする	p0_x , p0_y , p1_x , p1_y = map ( int , input ( ) . split ( ) )	p0_x , p0_y , p1_x , p1_y = map ( int , input ( ) . split ( ) ) <eos>
B を A で 割 った 商 を出力する	print ( B // A )	print ( B // A ) <eos>
n の間 、 次 を 繰 り 返す	while n :	while n : <eos>
move Node ( node _ now , space , -1 ) を node _ tmp とする	node_tmp = moveNode ( node_now , space , - 1 )	node_tmp = moveNode ( node_now , space - 1 , - 1 ) <eos>
r が w と 等しい かどうか が c と 等しい かどうか が r r と 等しい かどうか が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if r == w == c == rr == 0 : <blk> break </blk>	if r == w == c == r == 0 : <blk> break </blk> <eos>
0 を level の start 番目 にする	level [ start ] = 0	level [ start ] = 0 <eos>
' full h ous e ' を出力する	print ( 'full house' )	print ( "full house" ) <eos>
a と b の 最大 公 約 数 を g cd とする	gcd = math . gcd ( a , b )	gcd = gcd ( a , b ) <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ n 、 w 、 h とする </blk>	try : <blk> n , w , h = map ( float , input ( ) . split ( ',' ) ) </blk>	try : <blk> h , w , h = map ( float , input ( ) . split ( ',' ) ) </blk> <eos>
d を l で 割 った 値に d を l で 割 った 余 り を加え た 値の 整数値 を s とする	s = int ( d / l + d % l )	s = int ( d / l + d ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を S とする	S = list ( map ( int , input ( ) . split ( ) ) )	S = list ( map ( int , input ( ) . split ( ) ) ) <eos>
i に i に 1 を加え た 値を 掛け た 値に i に 2 を加え た 値を 掛け た 値を 6 で 割 った 商 を t とする	t = i * ( i + 1 ) * ( i + 2 ) // 6	t = i * ( i + 1 ) // 2 + i * i <eos>
> が tmp に含まれる とき 、	if ">" in tmp :	if cur in tmp : <eos>
E を block とする	block = "E"	block = "E" <eos>
x を パラメータ として ( - x の 2 番目 、 x の 1 番目 ) の 組 を返す 関数を キー として tb l を ソート した 列 を 順に i として 、 繰 り 返す <blk> 区切り なしで i の先頭 、 ', ' 、 i の 2 番目 を出力する </blk>	for i in sorted ( tbl , key = lambda x : ( - x [ 2 ] , x [ 1 ] ) ) : <blk> print ( i [ 0 ] , ',' , i [ 2 ] , sep = '' ) </blk>	for i , x in sorted ( tbl , key = lambda x : ( - x [ 2 ] , x [ 1 ] , 16 ) ) : <blk> print ( i [ 2 ] , end = lambda i [ 0 ] ) </blk> <eos>
M を c n t とする	cnt = M	cnt = M <eos>
id x が n から 1 を 引 いた 値 より小さい とき 、	if idx < n - 1 :	if idx < n - 1 : <eos>
1 から 2 6 未 満 までの 2 間 隔 の数 列 を 順に a として 、 繰 り 返す	for a in range ( 1 , 26 , 2 ) :	for a in range ( 1 , 6 , 2 ) : <eos>
1 を i だけ 左 シフト した 値を b とする	b = 1 << i	b = 1 << i <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ b 、 e 、 t とする	b , e , t = map ( int , f_i . readline ( ) . split ( ) )	b , e , t = map ( int , f_i . readline ( ) . split ( ) ) <eos>
入力された 文字列のリスト を card とする	card = list ( input ( ) )	card = list ( input ( ) ) <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ p x 、 py 、 v x 、 v y とする	px , py , vx , vy = map ( float , file_input . readline ( ) . split ( ) )	px , py , vx , vy = map ( float , file_input . readline ( ) . split ( ) ) <eos>
so l ve ( )	solve ( )	solve ( ) <eos>
0 を n _ p とする	n_p = 0	n_p = 0 <eos>
t の 長さ を b とする	b = len ( t )	b = len ( t ) <eos>
s qua re ( an s + [ i ] , rest - i , i )	square ( ans + [ i ] , rest - i , i )	square ( ans + i [ i ] , - rest , - w [ i ] ) <eos>
line の リストを 順に i として 、 繰 り 返す	for i in list ( line ) :	for i in list ( line ) : <eos>
num の 1 番目の 整数値 を H とする	H = int ( num [ 1 ] )	H = int ( num [ 1 ] ) <eos>
i が m と 等しくない とき 、 <blk> a の m 番目 と a の i 番目 を 入れ替え る <sep> c を 1 だけ 増加 させる </blk>	if i != m : <blk> a [ m ] , a [ i ] = a [ i ] , a [ m ] <sep> c += 1 </blk>	if i != m : <blk> a [ i ] += a [ c ] <sep> c [ i ] += 1 </blk> <eos>
0 を flag とする	flag = 0	flag = 0 <eos>
b を a 倍 にする a を 2 分 の 一 にする j を 1 だけ 増加 させる	b *= a a /= 2 j += 1	b *= a // 2 <eos>
n から pre に d を 掛け た 値を 引 いた 値を m とする	m = n - pre * d	m = n - d * d <eos>
F の v 番目の w 番目 と 1 の 排 他 論理和 を F の w 番目の v 番目 とする を F の v 番目の w 番目 にする	F [ v ] [ w ] = F [ w ] [ v ] = F [ v ] [ w ] ^ 1	v [ w ] [ v ] [ cur [ w ] = F [ v ] [ 1 ] <eos>
真 を visit ed の current 番目 にする	visited [ current ] = True	visited [ current ] = True <eos>
an s の とき " yes " 、 そうでなければ " no " を出力する	print ( "yes" if ans else "no" )	print ( "yes" if ans else "no" ) <eos>
self の par の x 番目 を self の par の y 番目 だけ 増加 させる	self . par [ x ] += self . par [ y ]	self . par [ x ] += self . par [ y ] <eos>
pi に r 1 、 r 2 の 最小 値の 2 乗 を 掛け た 値を返す	return pi * min ( r1 , r2 ) ** 2	return min ( pi * r1 , r2 ** 2 ) ** 2 <eos>
a の i 番目の とき 、	if a [ i ] :	if a [ i ] : <eos>
% d % d を ( x 、 y ) の 組 で 割 った 余 り を出力する	print ( "%d %d" % ( x , y ) )	print ( "%d %d %d" % ( y , x ) ) <eos>
偽 を prime の i 番目 にする	prime [ i ] = False	prime [ i ] = False <eos>
que を ソート する	que . sort ( )	que . sort ( ) <eos>
step が H に W を 掛け た 値に 5 を加え た 値 より大きい とき 、	if step > H * W + 5 :	if step > H * W + 5 : <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を 展開 し 、 それぞれ s 、 g 、 V 、 P とする	s , g , V , P = list ( map ( int , input ( ) . split ( ',' ) ) )	s , g , V , P = list ( map ( int , input ( ) . split ( ',' ) ) ) <eos>
入力された 文字列を seq とする	seq = input ( )	seq = input ( ) <eos>
an s の 末尾に ( tmp の i 番目 に in p の i 番目 を加え た 値 、 tmp の i + 1 番目 に in p の i 番目 を加え た 値 ) からなる 列 の 最大 値 を追加する	ans . append ( max ( [ tmp [ i ] + inp [ i ] , tmp [ i + 1 ] + inp [ i ] ] ) )	ans . append ( [ max ( tmp [ i + 1 ] , inp [ i + 1 ] ) ] ) <eos>
internal node を t とする	t = "internal node"	t = <unk> <eos>
d を 13 で 割 った 余 り にする	d % = 13	d % = 13 <eos>
ch _ list 内の ch _ list の l 番目の 出現 回数 が 1 より大きい とき 、 <blk> 1 を check の j に 3 を 掛け た 値に l を 3 で 割 った 余 り を加え た 値 番目の k に 3 を 掛け た 値に l を 3 で 割 った 商 を加え た 値 番目 にする </blk>	if ch_list . count ( ch_list [ l ] ) > 1 : <blk> check [ j * 3 + l % 3 ] [ k * 3 + l // 3 ] = 1 </blk>	if ch_list . count ( ch_list ) > 1 : <blk> check [ l ] [ k ] [ j + 1 ] = 3 * l [ j // 3 + l // 3 </blk> <eos>
( next ( A ) ) からなる 列 を L とする	L = [ next ( A ) ]	L = [ next ( A ) ] <eos>
P の 末尾に cp 1 を追加する	P . append ( cp1 )	P . append ( cp1 ) <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ co st 、 amount とする	cost , amount = map ( int , input ( ) . split ( ',' ) )	cost , <unk> = map ( int , input ( ) . split ( ',' ) ) <eos>
play er の 長さが 1 より大きい 間 、 次 を 繰 り 返す	while len ( player ) > 1 :	while len ( player ) > 1 : <eos>
0 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> f の 、 つまり 入力された 文字列の 整数値 番目 を 1 だけ 増加 させる </blk>	for i in range ( n ) : <blk> f [ int ( input ( ) ) ] += 1 </blk>	for i in range ( n ) : <blk> f [ int ( input ( ) ) ] += 1 </blk> <eos>
w が 0 と 等しい とき 、	if w == 0 :	if w == 0 : <eos>
OFF を first とする	first = "OFF"	first = "OFF" <eos>
n を 50 だけ 増加 させる	n += 50	n += 50 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を words とする	words = input ( ) . split ( )	words = input ( ) . split ( ) <eos>
t の先頭 を r とする	r = t [ 0 ]	r = t [ 0 ] <eos>
p の i 番目 が P より大きく または q の i 番目 が Q より大きく または r の i 番目 が R より大きく または c が C より大きい とき 、 <blk> 何も しない </blk>	if p [ i ] > P or q [ i ] > Q or r [ i ] > R or c > C : <blk> pass </blk>	if p [ i ] > P [ q ] or Q > Q > Q [ i ] or q > C [ i ] or C : <blk> a [ r ] > C : <blk> C </blk> <eos>
逆 順に List の集合 のリスト を ソート した 列 を S or t ed _ List とする	Sorted_List = sorted ( list ( set ( List ) ) , reverse = True )	<unk> = sorted ( list ( set ( S ) ) ) <eos>
a の y 番目 を 1 だけ 増加 させる	a [ y ] += 1	a [ y ] += 1 <eos>
5 に t q を 掛け た 値に r q を加え た 値を p とする	p = 5 * tq + rq	p = 5 * qt + q <eos>
1 を an s の 先頭の 0 番目 にする	ans [ 0 ] [ 0 ] = 1	ans [ 0 ] [ 0 ] = 1 <eos>
find _ group ( groups , q 2 ) を g 2 とする	g2 = find_group ( groups , q2 )	g2 = <unk> ( groups , q2 ) <eos>
空 列 を one s とする	ones = [ ]	ones = [ ] <eos>
x を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ suit 、 num とする	suit , num = x . split ( )	suit , num = x . split ( ) <eos>
op e が " insert " と 等しい とき 、	if ope == "insert" :	if ope == "insert" : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ X の l 番目 、 Y の l 番目 とする	X [ l ] , Y [ l ] = [ int ( i ) for i in input ( ) . split ( ) ]	X [ l ] , Y [ l ] = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
R の 末尾に sentinel を追加する	R . append ( sentinel )	R . append ( sentinel ) <eos>
t . in _ order _ traversal ( )	t . in_order_traversal ( )	t . in_order_search ( ) <eos>
two pair を an s とする	ans = "two pair"	ans = <unk> <eos>
( ' A ' 、 ' B ' 、 ' C ' 、 ' D ' 、 ' E ' 、 ' F ' ) からなる 列 を 順に t として 、 繰 り 返す	for t in [ 'A' , 'B' , 'C' , 'D' , 'E' , 'F' ] :	for t in [ 'A' , 'B' , 'C' , 'D' ] : <eos>
ed ge 2 を 順に e として 、 繰 り 返す	for e in edge2 :	for e in edge : <eos>
x に b を 掛け た 値に y に p を 掛け た 値 を加え た 値 、 x * max ( b , 5 ) に y * max ( p , 2 ) を加え た 値に 8 を 掛け た 値を 10 で 割 った 商 の 最小 値 を出力する	print ( min ( x * b + y * p , ( x * max ( b , 5 ) + y * max ( p , 2 ) ) * 8 // 10 ) )	print ( min ( x * b + y * y + max ( p * max ( p , max ( b * x ) // 2 ) , max ( p ) // 10 ) ) ) <eos>
f ( t * 3 )	f ( t * 3 )	f ( t * 3 ) <eos>
root を返す	return root	return root <eos>
l の i 番目 を 順に node として 、 繰 り 返す	for node in l [ i ] :	for node in l [ i ] : <eos>
( a に 2 に c を 掛け た 値 を加え た 値を 3 で 割 った 値 、 b に 2 に d を 掛け た 値 を加え た 値を 3 で 割 った 値 ) からなる 列 を返す	return [ ( a + 2 * c ) / 3 , ( b + 2 * d ) / 3 ]	return [ a + 2 * c + d / 3 , b * 2 ] <eos>
d _ man h at t an ( node _ list ) を self の h にする	self . h = d_manhattan ( node_list )	self . hash_table = <unk> ( ) <eos>
x を パラメータ として x の先頭 を返す 関数を key として 1 を reverse として P を ソート する	P . sort ( key = lambda x : x [ 0 ] , reverse = 1 )	P . sort ( key = lambda x : x [ 0 ] , reverse = True ) <eos>
num を 10 の 4 から i を 引 いた 値 乗 で 割 った 余 り を num とする	num = num % 10 ** ( 4 - i )	num = num % 10 ** ( 4 - i ) <eos>
空 列 を search _ queue とする	search_queue = [ ]	search_queue = [ ] <eos>
g ame を出力する	print ( game )	print ( game ) <eos>
self . Get Node s ( ) の各要素 を node と し 、 self . In De gree ( node ) が 0 と 等しい ときの node の 列 を S とする	S = [ node for node in self . GetNodes ( ) if self . InDegree ( node ) == 0 ]	S = self . GetNodes ( ) for node in self . GetNodes ( ) if self . GetNodes ( ) == 0 ] <eos>
blue の 末尾に M から S 内の " B " の 出現 回数 を 引 いた 値に blue の末尾 を加え た 値 を追加する	blue . append ( M - S . count ( "B" ) + blue [ - 1 ] )	blue . append ( M - S . count ( "W" ) + blue [ - 1 ] ) <eos>
( -1 ) からなる 列 の size 回 分 の 列 を self の table にする	self . table = [ - 1 ] * size	self . table = [ - 1 ] * size <eos>
0 から Q 未 満 までの 数 列 の各要素 を i と し 、 file _ input から 読み込んだ 一行 の 整数値 の 列 を query とする	query = [ int ( file_input . readline ( ) ) for i in range ( Q ) ]	query = [ int ( file_input . readline ( ) ) for i in range ( Q ) ] <eos>
( 0 ) からなる 列 の L 回 分 の 列 を D とする	D = [ 0 ] * L	D = [ 0 ] * L <eos>
Q の 末尾に to を追加する	Q . append ( to )	Q . append ( to ) <eos>
L の 末尾に ( i 、 c ) からなる 列 を追加する	L . append ( [ i , c ] )	L . append ( [ i , c ] ) <eos>
max _ a re a を出力する	print ( max_area )	print ( max_area ) <eos>
self の p t 1 の y 座 標 に t を self の abs で 割 った 値に self の vec t or の y 座 標 を 掛け た 値 を加え た 値を y とする	y = self . pt1 . y + t / self . abs * self . vector . y	y = self . pt1 . y + self . y * self . y <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を an im al s とする	animals = input ( ) . split ( )	<unk> = input ( ) . split ( ) <eos>
self の right が 、 つまり 未 定 値 と 等しくない とき 、 <blk> self . right . pre order ( ) </blk>	if self . right != None : <blk> self . right . preorder ( ) </blk>	if self . right is None : <blk> self . preorder ( self . right ) </blk> <eos>
0 が i より小さい とき 、 <blk> ' ' を 間 に入れ て per m の i から 1 を 引 いた 値 番目 の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する </blk>	if 0 < i : <blk> print ( ' ' . join ( map ( str , perm [ i - 1 ] ) ) ) </blk>	if 0 < i : <blk> print ( ' ' . join ( map ( str , perm [ i - 1 ] ) ) </blk> <eos>
文字 コード a に x を 掛け た 値に b を加え た 値を M で 割 った 余 り に A を加え た 値の 文字 を返す	return chr ( ( a * x + b ) % M + A )	return chr ( ( ( a * x + b ) % M + A ) <eos>
ref _ a d j の i 番目 を 展開 し 、 それぞれ at i 、 a li とする	ati , ali = ref_adj [ i ]	a12 , a = adj_cross_point [ i ] <eos>
E E EN E E EN E E E SEE E SEE EN E E EN を 順に op として 、 繰 り 返す	for op in "EEENEEENEEESEEESEEENEEEN" :	for <unk> in E : <eos>
t が group _ tmp に含まれる とき 、	if t in group_tmp :	if t in group : <eos>
_ x を x に r の 正 弦 を 掛け た 値 だけ 増加 させる	_x += x * sin ( r )	x_now += math . sin ( x ) * cos ( r ) <eos>
a を 空白 で 分割 した 字句 列 を x とする	x = a . split ( )	x = a . split ( ) <eos>
l が H 以下 かつ A の l 番目 が A の i 番目 より大きい とき 、	if l <= H and A [ l ] > A [ i ] :	if l <= H and A [ l ] > A [ i ] : <eos>
an s を ' U ' だけ 増加 させる	ans += 'U'	ans += 'U' <eos>
op e の 0 番目 が 0 と 等しい とき 、	if ope [ 0 ] == 0 :	if ope [ 0 ] == 0 : <eos>
m に 1 を加え た 値を sh el f とする	shelf = m + 1	shelf = m + 1 <eos>
process の 0 を取り出し た 値	process . pop ( 0 )	process . pop ( 0 ) <eos>
a に b を加え た 値を s とする	s = a + b	s = a + b <eos>
m id に h _ i _ s n を加え た 値を s _ c とする	s_c = mid + h_i_sn	s_c = mid + h_i_sn <eos>
( ( 1 , 6 000 ) 、 ( 2 , 4 000 ) 、 ( 3 , 3 000 ) 、 ( 4 , 2000 ) ) からなる 辞書を price とする	price = { 1 : 6000 , 2 : 4000 , 3 : 3000 , 4 : 2000 }	price = { 1 : 6000 , 2 : 4000 , 4 : 2000 } <eos>
F を block とする	block = "F"	block = "F" <eos>
d が 0 より小さい とき 、 <blk> " I m possibl e " を出力する <sep> 最初 から もう 一度 、 繰 り 返す </blk>	if d < 0 : <blk> print ( "Impossible" ) <sep> continue </blk>	if d . cross ( 0 ) < m : <blk> print ( "Impossible" ) <sep> continue </blk> <eos>
W が H と 等しい かどうか が 0 と 等しい とき 、	if W == H == 0 :	if W == H == 0 : <eos>
s に s を加え た 値を s とする	s = s + s	s = s + s <eos>
s witch に 番号 付 した 組 の 列 を 順に m 、 s w _ m として 、 繰 り 返す	for m , sw_m in enumerate ( switch ) :	for m , <unk> in enumerate ( switch ) : <eos>
Point ( vec _ self _ to _ other . y / vec _ abs , - vec _ self _ to _ other . x / vec _ abs ) に abs _ from _ p t を 掛け た 値を in v とする	inv = Point ( vec_self_to_other . y / vec_abs , - vec_self_to_other . x / vec_abs ) * abs_from_pt	vec_self_to_other = Point ( self . abs ( ) - pow ( self . abs ( ) / vec_abs , self . abs ( ) ) ) <eos>
x を 10 分 の 一 にする	x // = 10	x // = 10 <eos>
( ( 0 ) からなる 列 の 0 から H に 1 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 W に 1 を加え た 値の 列 回 分 の 列 ) からなる 列 を M T とする	MT = [ [ 0 ] * [ ( W + 1 ) for i in range ( H + 1 ) ] ]	T = [ [ 0 ] * [ ( M + 1 ) for i in range ( H + 1 ) ] ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ w 、 h 、 n とする	w , h , n = map ( int , input ( ) . split ( ) )	w , h , w = map ( int , input ( ) . split ( ) ) <eos>
p の j 番目 が h の i に j を加え た 値 番目 以上の とき 、 <blk> c を h の i に j を加え た 値 番目 だけ 増加 させる </blk>	if p [ j ] >= h [ i + j ] : <blk> c += h [ i + j ] </blk>	if p [ j ] >= h [ i + j ] : <blk> h [ i + j ] += h </blk> <eos>
color を be st とする	best = color	best = color <eos>
未 定 値を swap _ node の right にする	swap_node . right = None	swap_node . right = None <eos>
string が D に含まれる とき " yes " 、 そうでなければ " no " を出力する	print ( "yes" if string in D else "no" )	print ( "yes" if string in D else "no" ) <eos>
UF . un it e ( a , b )	UF . unite ( a , b )	UF . unite ( a , b ) <eos>
line _ cross _ point ( p 0 , p 1 , q 0 , q 1 ) を r とする	r = line_cross_point ( p0 , p1 , q0 , q1 )	q0 = <unk> ( p0 , p1 , q0 , q1 ) <eos>
a を A とする	A = a	A = a <eos>
heappush ( h q , ( s l v g _ t m , ' d ' , en ) )	heappush ( hq , ( slvg_tm , 'd' , en ) )	heappush ( hq , ( t , v , d ) ) <eos>
score の -1 を取り出し た 値	score . pop ( - 1 )	score . pop ( - 1 ) <eos>
( ' N A ' 、 ' B ' ) からなる 列 の s の 長さが 2 に s 内の ' Q =' の 出現 回数 を 掛け た 値 と 等 し く かつ s の 長さが 0 より大きい かどうか 番目 を a とする	a = [ 'NA' , 'B' ] [ len ( s ) == 2 * s . count ( 'Q=' ) and len ( s ) > 0 ]	s = [ ord ( 'A' ) , s [ 0 ] * 2 > s . count ( '1' ) and s [ 0 ] > a [ 0 ] <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を S とする	S = [ [ ] for i in range ( n ) ]	S = [ [ ] for i in range ( n ) ] <eos>
( op 、 v 1 、 d ) の 組 を S の line 番目 にする	S [ line ] = ( op , v1 , d )	S [ line ] = ( op , v1 , d ) <eos>
( r h o m b ic の先頭 の先頭 ) からなる 列 を sum s とする	sums = [ rhombic [ 0 ] [ 0 ] ]	sums = [ rhombic [ 0 ] [ 0 ] ] <eos>
p t _ array の 末尾に begin を追加する	pt_array . append ( begin )	pt_array . append ( begin ) <eos>
cd に i を加え た 値を 4 で 割 った 余 り を nd とする	nd = ( cd + i ) % 4	nd = ( cd + i ) % 4 <eos>
go al を 順に x 、 y として 、 繰 り 返す	for x , y in goal :	for x , y in goal : <eos>
c の i 番目 を c の i から 1 を 引 いた 値 番目 だけ 増加 させる	c [ i ] += c [ i - 1 ]	c [ i ] += c [ i - 1 ] <eos>
S 2 の先頭 を取り出し た 値	S2 . pop ( )	S2 . pop ( ) <eos>
lists [ arg [ 1 ] ] . s p lice ( lists [ arg [ 0 ] ] )	lists [ arg [ 1 ] ] . splice ( lists [ arg [ 0 ] ] )	<unk> [ 1 ] [ p [ 0 ] ] . <unk> ( [ 0 ] ) <eos>
r が dist の w 番目 より小さい とき 、	if r < dist [ w ] :	if r < dist [ w ] : <eos>
( 0 ) からなる 列 の 10 1 回 分 の 列 を see n とする	seen = [ 0 ] * 101	n = [ 0 ] * 10 <eos>
in side ( x a 2 , y a 2 , xb 1 , y b 1 , xb 2 , y b 2 ) の とき 、 <blk> 真 を返す </blk>	if inside ( xa2 , ya2 , xb1 , yb1 , xb2 , yb2 ) : <blk> return True </blk>	if inside ( xa1 , ya2 , xb1 , yb1 , xb2 , yb2 ) : <blk> return True </blk> <eos>
Point ( x 2 , y 2 ) を p 2 とする	p2 = Point ( x2 , y2 )	p2 = Point ( x2 , y2 ) <eos>
self の キーと値 の集まり の self の キーと値 の集まり の 長さ から 1 を 引 いた 値 番目 を返す	return self . items [ len ( self . items ) - 1 ]	return len ( self . items ( ) - 1 ) [ 1 ] <eos>
入力された 文字列を cmd とする	cmd = input ( )	cmd = input ( ) <eos>
R を ソート する	R . sort ( )	R . sort ( ) <eos>
s を 100 で 割 った 余 り の 整数値 を s とする	s = int ( s % 100 )	s = int ( s % 100 ) <eos>
R 0 の 長さが 10 より大きい とき 、	if len ( R0 ) > 10 :	if len ( R0 ) > 10 : <eos>
line を返す	return line	return line <eos>
y の 末尾に a から b を 引 いた 値 を追加する	y . append ( a - b )	y . append ( a - b ) <eos>
x が s の k に 1 を加え た 値 番目 より大きい とき 、 <blk> y を x から s の k に 1 を加え た 値 番目 を 引 いた 値 だけ 増加 させる </blk>	if x > s [ k + 1 ] : <blk> y += x - s [ k + 1 ] </blk>	if x > s [ k + 1 ] : <blk> s [ x + 1 ] += s [ k - 1 </blk> <eos>
n を max _ high とする	max_high = n	max_high = n <eos>
W と H の 最大 公 約 数 を g とする	g = math . gcd ( W , H )	g = gcd ( W , H ) <eos>
u が g と 等しい とき 、	if u == g :	if u == g : <eos>
math モジュール を用い る	from math import acos , pi	from math import cos , cos , radians <eos>
0 、 0 、 0 、 0 、 0 を n 、 v 、 e 、 a 、 b とする	n , v , e , a , b = 0 , 0 , 0 , 0 , 0	a , b , c , v , a , b = 0 , 0 , 0 , 0 <eos>
o d の w 番目 が -1 と 等しくない とき 、	if od [ w ] != - 1 :	if od [ w ] != - 1 : <eos>
que en の r 番目 が initial の r 番目 と 等しくない とき 、	if queen [ r ] != initial [ r ] :	if queens [ r ] != initial [ r ] : <eos>
i を 2 で 割 った 商 、 i に 2 を 掛け た 値 、 i に 2 を 掛け た 値に 1 を加え た 値を parent 、 right 、 left とする	parent , right , left = i // 2 , i * 2 , i * 2 + 1	parent , left , right = i // 2 , i + 2 * i + 1 , i * i <eos>
x r 、 y r を出力する	print ( xr , yr )	print ( xr , yr ) <eos>
' C a se {} : {} ' を 書式 として n 、 x で 整 形 した 文字列 を出力する	print ( 'Case {}: {}' . format ( n , x ) )	print ( <unk> . format ( n , x ) ) <eos>
order の 末尾に node _ no を追加する	order . append ( node_no )	order . append ( node_no ) <eos>
v を出力する	print ( v )	print ( v ) <eos>
prime の i 番目 が 1 と 等しい とき 、	if prime [ i ] == 1 :	if prime [ i ] == 1 : <eos>
x の 0 番目 が ' i ' と 等しい とき 、	if x [ 0 ] == 'i' :	if x [ 0 ] == 'i' : <eos>
v を a の j に g を加え た 値 番目 にする	a [ j + g ] = v	a [ j + g ] = v <eos>
i _ b r id ge s を 順に a 、 b 、 c 、 d として 、 繰 り 返す	for a , b , c , d in i_bridges :	for a , b , c , d , c in i_bridges : <eos>
1 から 9 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , 9 ) :	for i in range ( 1 , 9 ) : <eos>
i が t の 長さ より 小さく かつ j が s の 長さ より小さい 間 、 次 を 繰 り 返す	while i < len ( t ) and j < len ( s ) :	while i < len ( t ) and j < len ( s ) : <eos>
2 23 を S Q RT とする	SQRT = 223	SQRT = 182 <eos>
-1 を depth の key 番目 にする	depth [ key ] = - 1	depth [ key ] = - 1 <eos>
i から g a p を 引 いた 値を j とする	j = i - gap	j = i - gap <eos>
0 を answer s の num _ an s 番目 にする	answers [ num_ans ] = 0	answers [ <unk> ] = 0 <eos>
x から 1 を 引 いた 値 、 y から 2 を 引 いた 値 、 depth に 1 を加え た 値 、 max _ depth において 正規表現 table が 最初 にマッチする 位置 の とき 、	if search ( table , x - 1 , y - 2 , depth + 1 , max_depth ) :	if search ( table , x - 1 , y - 2 , depth + 1 , max_depth ) : <eos>
id 、 d max を出力する	print ( id , dmax )	print ( id , dmax ) <eos>
k o ch ( n -1 , t , b )	koch ( n - 1 , t , b )	koch ( n - 1 , t , b ) <eos>
can d i date の index 番目 が b と 等しい とき 、	if candidate [ index ] == b :	if candidate [ index ] == b : <eos>
prime _ table の k に i を 掛け た 値 番目 が 0 と 等しい かどうか	prime_table [ k * i ] == 0	prime_table [ k * i == 0 ] <eos>
t が m と 等しい かどうか が s と 等しい かどうか が -1 と 等しい とき 、	if t == m == s == - 1 :	if t == m == s == - 1 : <eos>
s を a だけ 増加 させる	s += a	s += a <eos>
-1 を c n t とする	cnt = - 1	cnt = - 1 <eos>
h が w 1 以下の とき 、	if h <= w1 :	if h <= w1 : <eos>
a が 2 と 等しい とき 、	if a == 2 :	if a == 2 : <eos>
x が y より大きい とき 、	if x > y :	if x > y : <eos>
clause ( e [ 1 : -1 ] ) の とき 、	if clause ( e [ 1 : - 1 ] ) :	if <unk> ( e [ 1 : - 1 ] ) : <eos>
r . in _ order _ search ( )	r . in_order_search ( )	r . in_order_search ( ) <eos>
1 を frame とする	frame = 1	frame = 1 <eos>
s から p w を 引 いた 値を p h に p w を加え た 値で 割 った 余 り を s とする	s = ( s - pw ) % ( ph + pw )	s = ( s - ( w - h ) % ( p + w ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ m 、 r d 、 r r 、 cd 、 c r とする	m , rd , rr , cd , cr = map ( int , input ( ) . split ( ) )	r , m , r , c , d , cd = map ( int , input ( ) . split ( ) ) <eos>
i に 1 を加え た 値を d _ an s とする	d_ans = i + 1	ans = i + 1 <eos>
w を n から 20 を 引 いた 値に 1 40 を 掛け た 値 だけ 増加 させる	w += ( n - 20 ) * 140	w += ( n - 20 ) * 140 <eos>
g 4 の 末尾に g 2 の 2 番目 を追加する	g4 . append ( g2 [ 2 ] )	g4 . append ( g2 [ 2 ] ) <eos>
( self の IN F ) からなる 列 の 2 に self の n を 掛け た 値 から 1 を 引 いた 値 回 分 の 列 を self の lazy にする	self . lazy = [ self . INF ] * ( 2 * self . n - 1 )	self . lazy = [ self . INF ] * self . n - 1 <eos>
v s を 順に x として 、 繰 り 返す	for x in vs :	for x in vs : <eos>
at l as の 末尾に 入力された 文字列を " " で 分割 した 字句 列 の各要素 を j と し 、 ( j の 整数値 、 0 ) からなる 列 の 列 を追加する	atlas . append ( [ [ int ( j ) , 0 ] for j in input ( ) . split ( " " ) ] )	atlas . append ( [ int ( j ) for j in input ( ) . split ( " " ) ] ) <eos>
cp _ list で ないとき 、	if not cp_list :	if not cp_list : <eos>
t の i 番目の right が -1 と 等しくない とき 、 <blk> in order ( t [ i ] . right ) </blk>	if t [ i ] . right != - 1 : <blk> inorder ( t [ i ] . right ) </blk>	if t [ i ] . right != - 1 : <blk> inorder . right </blk> <eos>
を S 2 とする	S2 = ""	S2 = "" <eos>
mod が 0 と 等しい とき 、	if mod == 0 :	if mod == 0 : <eos>
0 から H 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( H ) :	for j in range ( H ) : <eos>
32 3 を S Q RT とする	SQRT = 323	SQRT = <unk> <eos>
conv ex _ h ul l の 長さ を出力する	print ( len ( convex_hull ) )	print ( len ( convex_hull ) ) <eos>
an c の w 番目 が -1 と 等しくな く かつ p v が root ( w ) と 等しくない とき 、	if anc [ w ] != - 1 and pv != root ( w ) :	if anc [ w ] != - 1 and root ( p ) and root ( w != v ) : <eos>
50 001 を n とする	n = 50001	n = <unk> <eos>
r 1 を 1 を C の i 番目の x 0 番目の 順序 数 から ' A ' の順序 数 を 引 いた 値 だけ 左 シフト した 値 と の 論理和 にする	r1 | = 1 << ( ord ( C [ i ] [ x0 ] ) - ord ( 'A' ) )	r1 | = 1 << ( ord ( C [ i ] [ x0 ] ) - ord ( 'A' ) ) <eos>
n 1 を c の i 番目 にする	c [ i ] = n1	c [ i ] = n1 <eos>
es の i 番目 を 展開 し 、 それぞれ v 、 w 、 _ とする	v , w , _ = es [ i ]	v , w , <unk> = es [ i ] <eos>
ten の i 番目 を second の i 番目 だけ 増加 させる	ten [ i ] += second [ i ]	ten [ i ] += second [ i ] <eos>
0 を sum m とする	summ = 0	sum_m = 0 <eos>
string の 先頭から pattern を探し て 見つかった 位置 を pos とする	pos = string . find ( pattern )	pos = string . find ( pattern ) <eos>
0 から A の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( A ) ) :	for i in range ( len ( A ) ) : <eos>
R を [ MASK ] で 割 った 剰余 を 展開 し 、 それぞれ x 、 d とする	x , d = remainder ( R )	x , d = R / 100 <eos>
p r v の cur 番目 を p とする	p = prv [ cur ]	p = prv [ cur ] <eos>
r の left を p の left にする	p . left = r . left	p . left = r . left <eos>
k i を key t b l に ソート 順 で 挿入 する	insort_left ( keytbl , ki )	dijkstra . insert ( keytbl , : - 1 ) <eos>
attack ( table , i , j )	attack ( table , i , j )	<unk> ( table , i , j ) <eos>
an s の 末尾に a の文字列 を追加する	ans . append ( str ( a ) )	ans . append ( str ( a ) ) <eos>
a の l 番目 から m 番目 までの 部分 列 を L とする	L = a [ l : m ]	L = a [ l : m ] <eos>
q が 0 より小さい とき 、 <blk> 繰り返し を 中断 する </blk>	if q < 0 : <blk> break </blk>	if q < 0 : <blk> break </blk> <eos>
string の j 番目の 順序 数 に i を加え た 値を x とする	x = ord ( string [ j ] ) + i	x = string [ j ] + ord ( string [ i ] ) <eos>
a num s の i 番目 を 3 だけ 減 少 させる	anums [ i ] -= 3	anums [ i ] -= 3 <eos>
an s 、 B F S ( add ) の 1 番目の 最大 値 を出力する	print ( max ( ans , BFS ( add ) [ 1 ] ) )	print ( max ( ans , B [ add ] ) ) <eos>
arr の 長さ の 文字列を an s の i 番目 にする	ans [ i ] = str ( len ( arr ) )	ans [ i ] = str ( len ( arr ) ) <eos>
go al の先頭 を go al とする	goal = goal [ 0 ]	goal = goal [ 0 ] <eos>
空 辞書を next _ line とする	next_line = { }	next_line = { } <eos>
cur を r だけ 増加 させる	cur += r	cur += r <eos>
\\\\\ write ( " % d \\\\ \\\\ n " % d f s ( 0 , 0 ) ) \\\\\	\\\\\write ( "%d\\\\\\\\n" % dfs ( 0 , 0 ) )\\\\\	\\\\\write ( "%d %d\\\\\\\\n" % ( 0 , s ) )\\\\ <eos>\
0 を _ t とする	_t = 0	_t = 0 <eos>
combination ( n + k -1 , n ) を mod で 割 った 余 り を出力する	print ( combination ( n + k - 1 , n ) % mod )	print ( combination ( n + k - 1 , mod ) % mod ) <eos>
c n t の 先頭の 1 番目 を n max とする	nmax = cnt [ 0 ] [ 1 ]	nmax = cnt [ 0 ] [ 1 ] <eos>
z の key が x の key より小さい とき 、	if z . key < x . key :	if z . key < x . key : <eos>
999999 99 を V とする	V = 99999999	V = <unk> <eos>
真 を un v is it ed の r ing 番目 にする	unvisited [ ring ] = True	unvisited [ ring ] = True <eos>
p の 0 番目 が 0 と 等 し く または p の 0 番目 が 3 と 等しい とき 、	if p [ 0 ] == 0 or p [ 0 ] == 3 :	if p [ 0 ] == 0 or p [ 3 ] == 0 : <eos>
0 から 2 未 満 までの 数 列 の各要素 を i と し 、 0 から 15 未 満 までの 数 列 の各要素 を j と し 、 0 の 列 の 列 を a とする	a = [ [ 0 for j in range ( 15 ) ] for i in range ( 2 ) ]	a = [ [ 0 for j in range ( 15 ) ] for i in range ( 2 ) ] <eos>
table の 9 番目の 先頭 を出力する	print ( table [ 9 ] [ 0 ] )	print ( table [ 9 ] [ 0 ] ) <eos>
order を 順に i として 、 繰 り 返す	for i in order :	for i in order : <eos>
min _ cos t を出力する	print ( min_cost )	print ( min_cost ) <eos>
n の 総 和 を b で 割 った 値を a とする	a = sum ( n ) / b	a = sum ( n ) / b <eos>
r s を d 0 に SS の state 0 番目 に P S の state 1 番目 を 掛け た 値を 掛け た 値 だけ 増加 させる	rs += d0 * ( SS [ state0 ] * PS [ state1 ] )	rr += d0 * state [ 0 ] <eos>
p の 整数値 が 0 と 等しい とき 、 <blk> w を 1 だけ 増加 させる </blk>	if int ( p ) == 0 : <blk> w += 1 </blk>	if int ( p ) == 0 : <blk> w += 1 </blk> <eos>
q の 1 番目 を d とする	d = q [ 1 ]	d = q [ 1 ] <eos>
y を 400 で 割 った 余 り が 0 と 等 し く または y を 4 で 割 った 余 り が 0 と 等 し く かつ y を 100 で 割 った 余 り が 0 と 等しくない とき 、	if y % 400 == 0 or y % 4 == 0 and y % 100 != 0 :	if y % 400 == 0 or ( y % 4 == 0 and y % 100 != 0 and y % 100 != 0 ) : <eos>
day を last _ day とする	last_day = day	last_day = day <eos>
真 を is S e ar ch ed の u 番目 にする	isSearched [ u ] = True	isSearched [ u ] = True <eos>
0 から 100 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 100 ) :	for j in range ( 100 ) : <eos>
空 列 を res とする	res = [ ]	res = [ ] <eos>
7 を L とする	L = 7	L = 7 <eos>
x が 10 より小さい とき 、	if x < 10 :	if x < 10 : <eos>
in d eg の i 番目の 先頭 が 0 と 等 し く かつ color の i 番目 が " white " と 等しい とき 、	if indeg [ i ] [ 0 ] == 0 and color [ i ] == "white" :	if indeg [ i ] [ 0 ] == color and color [ i ] == "white" : <eos>
空 辞書を mp とする	mp = { }	mp = { } <eos>
y の先頭 の先頭 を a とする	a = y [ 0 ] [ 0 ]	a = y [ 0 ] [ 0 ] <eos>
quick _ sort ( a , 0 , n -1 )	quick_sort ( a , 0 , n - 1 )	quick_sort ( a , 0 , n - 1 ) <eos>
an s の a 番目 を 1 だけ 増加 させる	ans [ a ] += 1	ans [ a ] += 1 <eos>
out を出力する	print ( out )	print ( out ) <eos>
d の 末尾に ( p 、 t から q を 引 いた 値 ) からなる 列 を追加する	d . append ( [ p , t - q ] )	d . append ( [ p , t - q ] ) <eos>
s が ' H IT ' と 等しい とき 、	if s == 'HIT' :	if s == 'H' : <eos>
( ( value , V AL U ES の キーと値 の集まり の各要素 を key 、 value と し 、 key の 列 ) ) からなる 辞書を IN V _ V AL U ES とする	INV_VALUES = { value : [ key for key , value in VALUES . items ( ) ] }	<unk> = { value : [ INF for key , value in <unk> . items ( ) ] } <eos>
score を 順に e として 、 繰 り 返す	for e in score :	for e in score : <eos>
a が 0 より大きい 間 、 次 を 繰 り 返す	while a > 0 :	while a > 0 : <eos>
table の c から i を 引 いた 値 から 1 を 引 いた 値 番目の i 番目 を table の c から i を 引 いた 値 から 1 を 引 いた 値 番目の i から 1 を 引 いた 値 番目 だけ 増加 させる	table [ c - i - 1 ] [ i ] += table [ c - i - 1 ] [ i - 1 ]	table [ c - i - 1 ] [ c - i ] += table [ i - 1 ] [ c - 1 ] <eos>
an s の n 番目 から an s の m から 1 を 引 いた 値 番目 を 引 いた 値 を出力する	print ( ans [ n ] - ans [ m - 1 ] )	print ( ans [ n ] - ans [ m - 1 ] ) <eos>
node s の値 の集まり の各要素 を val と し 、 val の left _ node _ no の 列 に node s の値 の集まり の各要素 を val と し 、 val の right _ node _ no の 列 を加え た 値 の集合 を children とする	children = set ( [ val . left_node_no for val in nodes . values ( ) ] + [ val . right_node_no for val in nodes . values ( ) ] )	nodes = set ( [ set ( ) . values ( ) for node_no in nodes . values ( ) ] ) <eos>
are a が 19 00000 以上の とき 、	if area >= 1900000 :	if area >= <unk> : <eos>
Q が rename の 先頭の 0 番目 より小さい とき 、	if Q < rename [ 0 ] [ 0 ] :	if Q < rename [ 0 ] [ 0 ] : <eos>
a 、 c 、 n の 最小 値が 0 より大きい 間 、 次 を 繰 り 返す	while min ( a , c , n ) > 0 :	while min ( a , n ) > 0 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ x 、 y 、 x x 、 y y とする	x , y , xx , yy = map ( float , input ( ) . split ( ) )	x , y , x , y = map ( float , input ( ) . split ( ) ) <eos>
a の i 番目 に x y z を 掛け た 値を m の i 番目 で 割 った 余 り を x y z とする	xyz = a [ i ] * xyz % m [ i ]	xyz = a [ i ] * z [ x % m <eos>
heappop ( q ) を展開し 、 それぞれ h _ cos t 、 pos とする	h_cost , pos = heappop ( q )	h_cost , next_pos = heappop ( q ) <eos>
a を ( ( 、 つまり 現在の 日時 の 1 番目 、 d ) からなる 列 ) からなる 列 だけ 増加 させる	a += [ [ now [ 1 ] , d ] ]	a += [ [ now , 1 ] ] <eos>
0 から 4 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 入力された 文字列の 整数値 の 列 の 総 和 を s とする	s = sum ( [ int ( input ( ) ) for i in range ( 4 ) ] )	s = sum ( [ int ( input ( ) ) for i in range ( 4 ) ] ) <eos>
c に t を 掛け た 値 を出力する	print ( c * t )	print ( c * t ) <eos>
indices の v 番目 で ないとき 、	if not indices [ v ] :	if not indices [ v ] : <eos>
e の 1 番目 を cur とする	cur = e [ 1 ]	cur = e [ 1 ] <eos>
- u の K から i を 引 いた 値 番目 、 d の K から i を 引 いた 値 番目の 最大 値を j 2 とする	j2 = max ( - u [ K - i ] , d [ K - i ] )	j2 = max ( - u [ i - K ] , K [ i ] [ j ] - i ) <eos>
m の 、 つまり 先頭から x 番目 までの 部分 列 を 削 除 する	del m [ 0 : x ]	del m [ : x ] <eos>
C G の i 番目の 末尾に j を追加する	CG [ i ] . append ( j )	CG [ i ] . append ( j ) <eos>
0 から tb l の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( tbl ) ) :	for i in range ( len ( tbl ) ) : <eos>
-1 を an s 2 とする	ans2 = - 1	ans2 = - 1 <eos>
a の 末尾に 2 を追加する	a . append ( 2 )	a . append ( 2 ) <eos>
color の i 番目の 1 番目 を G とする	G = color [ i ] [ 1 ]	G = color [ i ] [ 1 ] <eos>
c ar p et s の 末尾に c _ b を追加する	carpets . append ( c_b )	carpets . append ( b ) <eos>
r が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if r == 0 : <blk> break </blk>	if r == 0 : <blk> break </blk> <eos>
s を 5 で 割 った 商 を出力する	print ( s // 5 )	print ( s // 5 ) <eos>
空 列 を p _ pass ed とする	p_passed = [ ]	p_passed = [ ] <eos>
[ MASK ] の 両端 キュー を x とする	x = deque ( )	x = collections . deque ( ) <eos>
c 2 が c 1 より小さい とき 、	if c2 < c1 :	if c2 < c1 : <eos>
i に j を 掛け た 値を result とする	result = i * j	result = i * j <eos>
self の node s の self の root _ id 番目 を root _ node とする	root_node = self . nodes [ self . root_id ]	root_node_no = self . nodes [ root_id ] <eos>
s に p c 1 の np 1 番目 、 p c 2 の np 2 番目 、 p c 3 の np 3 番目の 最大 値 を加え た 値を new _ h _ cos t とする	new_h_cost = s + max ( pc1 [ np1 ] , pc2 [ np2 ] , pc3 [ np3 ] )	new_cost = max ( s + c1 [ c2 ] , p2 [ p3 [ p3 ] [ p3 ] ) <eos>
time _ re c の c 番目の next _ c ity 番目の shift ed _ s 番目 が next _ t 以下の とき 、	if time_rec [ c ] [ next_city ] [ shifted_s ] <= next_t :	if time_rec [ city ] [ shifted_s ] <= shifted_s [ shifted_s ] : <eos>
d が r a から rb を 引 いた 値 より小さい とき 、	if d < ra - rb :	if d < ra - rb : <eos>
G の 末尾に number の i 番目 を追加する	G . append ( number [ i ] )	G . append ( number [ i ] ) <eos>
a と b の 最大 公 約 数 を g とする	g = gcd ( a , b )	g = gcd ( a , b ) <eos>
d を x が ' est ' と 等しい とき 9 0 、 そうでなければ - 9 0 だけ 増加 させる	d += 90 if x == 'est' else - 90	d += <unk> if x == 90 else 0 <eos>
d p の 、 つまり 入力された 文字列の 整数値 番目 を出力する	print ( dp [ int ( input ( ) ) ] )	print ( dp [ int ( input ( ) ) ] ) <eos>
i を b _ pos とする	b_pos = i	b_pos = i <eos>
i 、 v max を出力する	print ( i , vmax )	print ( i , maxv ) <eos>
d を 1 だけ 減 少 させる	d -= 1	d -= 1 <eos>
num が c n t と 等しい かどうか を返す	return num == cnt	return num == cnt <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ x _ a 、 y _ a 、 x _ b 、 y _ b 、 x _ c 、 y _ c 、 x _ d 、 y _ d とする	x_a , y_a , x_b , y_b , x_c , y_c , x_d , y_d = map ( float , input ( ) . split ( ) )	xa , ya , x_b , y_b , y_b , x_b , y_b , y_b , x_c , y_c = map ( float , input ( ) . split ( ) ) <eos>
point _ f i x ed の i 番目 を M in とする	Min = point_fixed [ i ]	Min = point_fixed [ i ] <eos>
D P の i 番目の j 番目 、 D P の i 番目の k 番目 に D P の k + 1 番目の j 番目 を加え た 値に P の i -1 番目 に P の k 番目 を 掛け た 値に P の j 番目 を 掛け た 値 を加え た 値の 最小 値を D P の i 番目の j 番目 にする	DP [ i ] [ j ] = min ( DP [ i ] [ j ] , DP [ i ] [ k ] + DP [ k + 1 ] [ j ] + P [ i - 1 ] * P [ k ] * P [ j ] )	DP [ i ] [ j ] = min ( DP [ i ] [ j ] , DP [ i + 1 ] [ j ] [ k - 1 ] ) + DP [ i ] [ j - 1 ] [ j - 1 ] [ i
d p の i から 1 を 引 いた 値 番目の j 番目 が 0 と 等しい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if dp [ i - 1 ] [ j ] == 0 : <blk> continue </blk>	if dp [ i - 1 ] [ j ] == 0 : <blk> continue </blk> <eos>
can d i date の 末尾に ( c _ min 、 c _ max ) の 組 を追加する	candidate . append ( ( c_min , c_max ) )	candidate . append ( ( ( c_min , c_min ) ) ) <eos>
i が 11 と 等しい とき 、	if i == 11 :	if i == 11 : <eos>
( A の i 番目の 1 番目 、 A の i 番目の 2 番目 ) の 組 を 順に j として 、 繰 り 返す	for j in ( A [ i ] [ 1 ] , A [ i ] [ 2 ] ) :	for j in ( A [ i ] [ 1 ] , A [ i ] [ 2 ] ) : <eos>
self . __ class __ ( self . x / d , self . y / d ) を返す	return self . __class__ ( self . x / d , self . y / d )	return self . <unk> ( self . x / d , self . y ) <eos>
7 . 81 48 14 81 に 入力された 文字列 の浮動小数点数 を 掛け た 値 を出力する	print ( 7.81481481 * float ( input ( ) ) )	print ( <unk> * float ( input ( ) ) ) <eos>
0 を l _ B とする	l_B = 0	l_A = 0 <eos>
an s を展開し て を出力する	print ( * ans )	print ( * ans ) <eos>
1 から n に 1 を加え た 値 未 満 までの 数 列 のリスト を people とする	people = list ( range ( 1 , n + 1 ) )	people = list ( range ( 1 , n + 1 ) ) <eos>
x に w を加え た 値が W より大きい とき 、	if x + w > W :	if x + w > W : <eos>
1 を A i の j 番目 にする	Ai [ j ] = 1	A [ j ] = 1 <eos>
day を 3 65 で 割 った 商 に 1 を加え た 値を year とする	year = day // 365 + 1	year = day // 365 + 1 <eos>
入力された 文字列を " " で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を x y とする	xy = [ int ( i ) for i in input ( ) . split ( " " ) ]	x = [ int ( i ) for i in input ( ) . split ( " " ) ] <eos>
H が W と 等しい かどうか が 0 と 等しい とき 、	if ( H == W == 0 ) :	if H == W == 0 : <eos>
s w を 1 だけ 増加 させる	sw += 1	sw += 1 <eos>
c を x で 割 った 余 り が 0 と 等しい とき 、	if c % x == 0 :	if c % x == 0 : <eos>
ch を 英 小文字 に変換し た 文字列を ch とする	ch = ch . lower ( )	ch = ch . lower ( ) <eos>
p t 1 _ x と p t 2 _ x を 入れ替え る	pt1_x , pt2_x = pt2_x , pt1_x	pt1_x , pt2_x = pt1_x , pt2_x <eos>
関数 cross を a 、 b を パラメータ として 定義する a の real に b の imag を 掛け た 値 から a の imag に b の real を 掛け た 値を 引 いた 値を返す	def cross ( a , b ) : return a . real * b . imag - a . imag * b . real	def cross ( a , b ) : return a . real * b . real - a . real * b . real ) <eos>
self の h の 文字列に " : 0 " を加え た 値に self の mm の文字列 を加え た 値を返す	return str ( self . h ) + ":0" + str ( self . mm )	return str ( self . h ) + str ( self . mm ) + str ( self . mm ) <eos>
i に 1 を加え た 値 、 v の d 、 v の f を出力する	print ( i + 1 , v . d , v . f )	print ( i + 1 , v . v , d ) <eos>
decimal モジュール を用い る	import decimal	from decimal import Decimal , Decimal , Decimal , <unk> <eos>
10 500 0 を MAX とする	MAX = 105000	MAX = <unk> <eos>
size の i 番目 を size の j 番目 だけ 増加 させる	size [ i ] += size [ j ]	size [ i ] += size [ j ] <eos>
events を 順に event として 、 繰 り 返す	for event in events :	for event in events : <eos>
1 から N に 1 を加え た 値 未 満 までの 数 列 を 順に case として 、 繰 り 返す	for case in range ( 1 , N + 1 ) :	for case in range ( 1 , N + 1 ) : <eos>
x y _ diff の 最大 値を C h _ d とする	Ch_d = max ( xy_diff )	Ma_d = max ( xy_diff ) <eos>
k に 1.0 を 掛け た 値を 1 を 7 だけ 左 シフト した 値で 割 った 値の 整数値 を a とする	a = int ( k * 1.0 / ( 1 << 7 ) )	a = int ( ( k * 1.0 / ( 1 ) ) ) <eos>
i を出力する	print ( i )	print ( i ) <eos>
an s は 非 ローカル変数 とする	nonlocal ans	nonlocal ans <eos>
queue の 末尾に ( process 、 time から q を 引 いた 値 ) の 組 を追加する	queue . append ( ( process , time - q ) )	queue . append ( ( process , time - q ) ) <eos>
root を 順に i として 、 繰 り 返す	for i in root :	for i in root : <eos>
x 1 、 x 0 から q に x 1 を 掛け た 値を 引 いた 値を x 0 、 x 1 とする	x0 , x1 = x1 , ( x0 - q * x1 )	x0 , x1 = x1 , xq - x1 * xq <eos>
1 、 1 を x 、 y とする	x , y = 1 , 1	x , y = 1 , 1 <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 入力された 文字列の 整数値 の 列 を s とする	s = [ int ( input ( ) ) for i in range ( n ) ]	s = [ int ( input ( ) ) for i in range ( n ) ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を tmp とする	tmp = list ( map ( int , input ( ) . split ( ) ) )	tmp = list ( map ( int , input ( ) . split ( ) ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を t i とする	ti = list ( map ( int , input ( ) . split ( ) ) )	t = list ( map ( int , input ( ) . split ( ) ) ) <eos>
b _ now . make B o ar d ( ) を 順に b _ new として 、 繰 り 返す	for b_new in b_now . makeBoard ( ) :	for b_new in b_now . <unk> ( b ) : <eos>
math モジュール を用い る	from math import gcd	from math import cos , cos , radians <eos>
( a を g で 割 った 商 、 b を g で 割 った 商 ) の 組 を返す	return ( a // g , b // g )	return ( a // g , b // g ) <eos>
1 を co st とする	cost = 1	cost = 1 <eos>
b が 21 より大きい とき 0 、 そうでなければ b を出力する	print ( 0 if b > 21 else b )	print ( ban if b > 21 else b ) <eos>
S の 末尾に a を追加する	S . append ( a )	S . append ( a ) <eos>
h 、 a の b を w で 割 った 商 番目の 最大 値を h とする	h = max ( h , a [ b // w ] )	h = max ( h , a [ b // w ] ) <eos>
空 辞書を count s とする	counts = { }	counts = { } <eos>
de g の j 番目 を 1 だけ 増加 させる	deg [ j ] += 1	deg [ j ] += 1 <eos>
B を展開し て の 要素を それぞれ 組 に した 列 の 組 を t B とする	tB = tuple ( zip ( * B ) )	B = tuple ( zip ( * B ) ) <eos>
cross ( S , E , P ) の 絶対値 を d d の平方根 で 割 った 値を返す	return abs ( cross ( S , E , P ) ) / sqrt ( dd )	return cross ( math . sqrt ( cross ( S , P ) , abs ( d ) / d ) <eos>
n を 500 で 割 った 商 に 500 を 掛け た 値 を出力する	print ( ( n // 500 ) * 500 )	print ( n // 500 * 500 ) <eos>
S の i に 2 を加え た 値 番目 が ' [' と 等しい とき 、 <blk> cal c ( a , b , c , d , i + 2 ) を展開し 、 それぞれ v 1 、 i とする </blk>	if S [ i + 2 ] == '[' : <blk> v1 , i = calc ( a , b , c , d , i + 2 ) </blk>	if S [ i + 2 ] == '[' : <blk> v , c = calc ( a , b , i + 1 , d , c ) </blk> <eos>
f の j 番目の r 2 番目の c 2 番目 を f の j から 1 を 引 いた 値 番目の r 番目の c 番目 を 4 で 割 った 値 だけ 増加 させる	f [ j ] [ r2 ] [ c2 ] += f [ j - 1 ] [ r ] [ c ] / 4	f [ j ] [ r2 ] [ c2 ] [ r2 ] += f [ j - 1 ] [ r ] <eos>
1 を 開始 番号 として X の 1 番目 から N から 1 を 引 いた 値 までの 部分 列 に 番号 付 した 組 の 列 を 順に i 、 X _ i として 、 繰 り 返す	for i , X_i in enumerate ( X [ 1 : N - 1 ] , start = 1 ) :	for i , item_w in enumerate ( X [ 1 : N - 1 ] , start = 1 ) : <eos>
d を d d とする	dd = d	d = d <eos>
x を c を a に 7 を 掛け た 値に b を加え た 値で 割 った 商 に 7 を 掛け た 値 だけ 増加 させる	x += c // ( a * 7 + b ) * 7	x += c * 7 + a * b // 7 <eos>
x の とき 、 <blk> x を z で 割 った 値を x とする </blk>	if x : <blk> x = x / z </blk>	if x : <blk> x = x / z </blk> <eos>
qua d _ max の 末尾に p を追加する	quad_max . append ( p )	quad_max . append ( p ) <eos>
string モジュール を用い る	import string	from string import ascii_lowercase <eos>
lo ts の i 番目 に 1 を加え た 値 を出力する	print ( lots [ i ] + 1 )	print ( lots [ i + 1 ] ) <eos>
j が i と 等しくない とき 、	if j != i :	if j != i : <eos>
ts の先頭 を 除 いた 部分 列 を 順に t として 、 繰 り 返す <blk> 1 を b の t 番目 にする </blk>	for t in ts [ 1 : ] : <blk> b [ t ] = 1 </blk>	for t in ts [ 1 : ] : <blk> t [ b ] = 1 </blk> <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 ( 0 、 0 ) からなる 列 の 列 のリスト を A とする	A = list ( [ [ 0 , 0 ] for i in range ( n ) ] )	A = [ list ( [ 0 ] ) for i in range ( n ) ] <eos>
depth を node の depth にする	node . depth = depth	node . depth = depth <eos>
time を l の i 番目の d にする	l [ i ] . d = time	l [ i ] . d = time <eos>
cal c ( ) を展開し 、 それぞれ f 、 an s とする	f , ans = calc ( )	f , ans = calc ( ) <eos>
x の an s 番目 が p と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if x [ ans ] == p : <blk> break </blk>	if x [ ans ] == p : <blk> break </blk> <eos>
data の 4 番目 を 1 だけ 増加 させる	data [ 4 ] += 1	data [ 4 ] += 1 <eos>
t を max top とする	maxtop = t	maxtop = t <eos>
0 から a の i 番目 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( a [ i ] ) :	for j in range ( a [ i ] ) : <eos>
points の i 番目の とき 、	if points [ i ] :	if points [ i ] : <eos>
\\\\\ j が ' \\\\ \\\\ \\\\ \\\\ ' と 等しい とき 、 \\\\\	\\\\\if j == '\\\\\\\\\\\\\\\\' :\\\\\	\\\\\if j == '\\\\\\\\\\\\\\\\' :\\\\ <eos>\
改行 せずに " % d " を f の i 番目の j 番目の k 番目 で 割 った 余 り を出力する	print ( " %d" % ( f [ i ] [ j ] [ k ] ) , end = '' )	print ( " <unk> % f [ i ] [ j ] [ k ] , end = "" ) <eos>
s の i 番目 が ' A ' と 等しい とき 、 <blk> ' z ' を s の i 番目 にする </blk>	if s [ i ] == 'A' : <blk> s [ i ] = 'z' </blk>	if s [ i ] == 'A' : <blk> sz ] = 'A' </blk> <eos>
an s を p から p r v を 引 いた 値を V で 割 った 値 だけ 増加 させる	ans += ( p - prv ) / V	ans += ( p - prv ) / V <eos>
score の s 番目の 末尾に p を追加する	score [ s ] . append ( p )	score [ s ] . append ( p ) <eos>
cal c _ d ( p [ 0 ] , p [ i + 1 ] ) を b とする	b = calc_d ( p [ 0 ] , p [ i + 1 ] )	b = calc_d ( p [ 0 ] , p [ i + 1 ] ) <eos>
OP を出力する	print ( OP )	print ( <unk> ) <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 入力された 文字列の 整数値 の 列 を f とする	f = [ int ( input ( ) ) for _ in range ( n ) ]	f = [ int ( input ( ) ) for _ in range ( n ) ] <eos>
i _ m ( an s ) を出力する	print ( i_m ( ans ) )	print ( <unk> ( ans ) ) <eos>
M の p 番目の 末尾に q を追加する	M [ p ] . append ( q )	M [ p ] . append ( q ) <eos>
a の 0 番目 が a の 1 番目 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if a [ 0 ] == a [ 1 ] : <blk> break </blk>	if a [ 0 ] == a [ 1 ] : <blk> break </blk> <eos>
child pos を pos とする	pos = childpos	pos = childpos <eos>
b の 長さが 5 より小さい 間 、 次 を 繰 り 返す	while len ( b ) < 5 :	while len ( b ) < 5 : <eos>
l の i 番目 から i に 2 を加え た 値 までの 部分 列 を 削 除 する	del l [ i : i + 2 ]	del l [ i : i + 2 ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 a 、 b 、 c 、 x とする	n , a , b , c , x = map ( int , input ( ) . split ( ) )	n , a , b , c , x = map ( int , input ( ) . split ( ) ) <eos>
x を diff だけ 増加 させる	x += diff	x += diff <eos>
un s al v age d の h t 番目 を rc だけ 減 少 させる	unsalvaged [ ht ] -= rc	unsalvaged [ ht ] -= rc <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を P とする	P = list ( map ( int , f_i . readline ( ) . split ( ) ) )	P = list ( map ( int , f_i . readline ( ) . split ( ) ) ) <eos>
x から x の 3 乗 から q を 引 いた 値を 3.0 に x の 2 乗 を 掛け た 値で 割 った 値を 引 いた 値を x とする	x = x - ( x ** 3 - q ) / ( 3.0 * x ** 2 )	x = x - ( x ** 3 - q ) / ( 2 * x ** 2 ) <eos>
left を r 1 とする	r1 = left	r1 = left <eos>
入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を a とする	a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) )	a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を buf とする	buf = input ( ) . split ( )	buf = input ( ) . split ( ) <eos>
S の cur 番目 が ascii _ lowercase に含まれる とき 、	if S [ cur ] in ascii_lowercase :	if S [ cur ] in ascii_lowercase : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ p x 、 py とする	px , py = map ( int , input ( ) . split ( ) )	px , py = map ( int , input ( ) . split ( ) ) <eos>
x q を x r とする	xr = xq	xr = xq <eos>
d p 1 に 番号 付 した 組 の 列 を 順に s q 、 p r として 、 繰 り 返す	for sq , pr in enumerate ( dp1 ) :	for sq , pr in enumerate ( dp ) : <eos>
re t val の 長さが 0 と 等しい とき 、	if len ( retval ) == 0 :	if len ( retval ) == 0 : <eos>
S が 1000 以上の とき 1 、 そうでなければ 0 を出力する	print ( 1 if S >= 1000 else 0 )	print ( 1 if S >= 1000 else 0 ) <eos>
0 を L str とする	Lstr = 0	Sstr = 0 <eos>
at l as の l の先頭 番目の l の 1 番目 番目の 1 番目 が 0 と 等しい とき 、	if atlas [ l [ 0 ] ] [ l [ 1 ] ] [ 1 ] == 0 :	if atlas [ l [ 0 ] ] [ l [ 1 ] ] == 0 : <eos>
( x 3 、 y 3 ) からなる 列 を C とする	C = [ x3 , y3 ]	C = [ x3 , y3 ] <eos>
i に 1 を加え た 値を j とする	j = i + 1	j = i + 1 <eos>
r _ B を 1 だけ 増加 させる	r_B += 1	r_A += 1 <eos>
0 を z とする	z = 0	z = 0 <eos>
1 、 1 を f 、 c とする	f , c = 1 , 1	f , c = 1 , 1 <eos>
an s を c を 3 で 割 った 商 だけ 増加 させる	ans += c // 3	ans += c // 3 <eos>
Time の 末尾に ( p 、 t ) からなる 列 を追加する	Time . append ( [ p , t ] )	Time . append ( [ p , t ] ) <eos>
is P ar all el L L ( [ p 1 , p 2 ] , [ p 3 , p 4 ] ) の とき ' Y ES ' 、 そうでなければ ' NO ' を出力する	print ( 'YES' if isParallelLL ( [ p1 , p2 ] , [ p3 , p4 ] ) else 'NO' )	print ( 'YES' if <unk> ( [ 1 ] , p2 , p [ 3 ] , 'YES' else 'NO' ) ) <eos>
p が s に 2 を 掛け た 値 に含まれる とき " Y es " 、 そうでなければ " No " を出力する	print ( "Yes" if p in s * 2 else "No" )	print ( "Yes" if p in s * 2 else "No" ) <eos>
真 を u の i 番目 にする	u [ i ] = True	u [ i ] = True <eos>
prime に 番号 付 した 組 の 列 の各要素 を i 、 j と し 、 j が 、 つまり 真 と 等しい ときの i の 列 を prime _ number とする	prime_number = [ i for i , j in enumerate ( prime ) if j == True ]	prime_number = [ True for i , j in enumerate ( prime [ j for i , j in enumerate ( j ) if i == True ] ) <eos>
0 を f low とする	flow = 0	flow = 0 <eos>
points の p 番目の 末尾に no を追加する	points [ p ] . append ( no )	points [ p ] . append ( no ) <eos>
in p の n から 1 を 引 いた 値 番目 を出力する	print ( inp [ n - 1 ] )	print ( inp [ n - 1 ] ) <eos>
0 から co up l ed の 長さ に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( coupled ) + 1 ) :	for i in range ( len ( coupled ) + 1 ) : <eos>
0 を __ T OP とする	__TOP = 0	__TOP = 0 <eos>
0 から n 未 満 までの 数 列 を 反 転 した 列 を 順に i として 、 繰 り 返す	for i in reversed ( range ( n ) ) :	for i in reversed ( range ( n ) ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ X 、 Y とする	X , Y = [ int ( i ) for i in input ( ) . split ( ) ]	X , Y = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
s を ( a の i 番目 に j を加え た 値 ) からなる 列 だけ 増加 させる	s += [ a [ i ] + j ]	s += [ a [ i + j ] ] <eos>
x y の 0 を取り出し た 値を x とする	x = xy . pop ( 0 )	x = xy . pop ( 0 ) <eos>
s を 順に letter として 、 繰 り 返す	for letter in s :	for next_sq in s : <eos>
a の b の x 番目の 先頭から 1 を 引 いた 値 番目の とき 、 <blk> 1 を a の b の x 番目の 1 番目 から 1 を 引 いた 値 番目 にする </blk>	if a [ b [ x ] [ 0 ] - 1 ] : <blk> a [ b [ x ] [ 1 ] - 1 ] = 1 </blk>	if a [ b [ 0 ] ] [ x - 1 ] : <blk> a [ b ] [ 1 ] = a [ x - 1 ] </blk> <eos>
p が '1' と 等しい とき 、	if p == '1' :	if p == '1' : <eos>
{} {} を出力する	print ( { X : . 3 f } { Y : . 3 f } )	print ( { x } { y } ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を x とする	x = [ int ( i ) for i in input ( ) . split ( ) ]	x = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
node s の node _ no 番目の right を right _ node _ no とする	right_node_no = nodes [ node_no ] . right	right_node_no = nodes [ node_no ] . right <eos>
( in p の 先頭の 整数値 、 in p の 1 番目の 整数値 ) からなる 列 を ab とする	ab = [ int ( inp [ 0 ] ) , int ( inp [ 1 ] ) ]	ab = [ int ( inp [ 0 ] ) , int ( inp [ 1 ] ) ] <eos>
0 から 8 未 満 までの 数 列 の各要素 を j と し 、 0 から 100 1 未 満 までの 数 列 の各要素 を i と し 、 0 の 列 の 列 を d p とする	dp = [ [ 0 for i in range ( 1001 ) ] for j in range ( 8 ) ]	dp = [ [ 0 for i in range ( 1001 ) ] for j in range ( 8 ) ] <eos>
month を 12 だけ 増加 させる	month += 12	month += 12 <eos>
k に f ( n -1 , k ) を 掛け た 値に k に f ( n -1 , k -1 ) を 掛け た 値 を加え た 値を mod で 割 った 余 り を re t val とする	retval = ( k * f ( n - 1 , k ) + k * f ( n - 1 , k - 1 ) ) % mod	retval = ( k * f ( n - 1 , k ) + 1 ) * mod ( n - 1 , k - 1 ) % mod <eos>
a c c el _ time _ end ( )	accel_time_end ( )	accel_time ( end ) <eos>
p 2 の y 座 標 から p 1 の y 座 標 を 引 いた 値を a y とする	ay = p2 . y - p1 . y	ya = p2 . y - p1 . y <eos>
an s に 3 を 掛け た 値を an s とする	ans = ans * 3	ans = ans * 3 <eos>
b と b _ i の 排 他 論理和 を pre _ bit とする	pre_bit = b ^ b_i	pre_rec = b ^ <unk> <eos>
( 0 、 1 、 -2 ) からなる 列 を 順に i として 、 繰 り 返す <blk> a の i 番目の 先頭 を出力する </blk>	for i in [ 0 , 1 , - 2 ] : <blk> print ( a [ i ] [ 0 ] ) </blk>	for i in [ 0 , 1 , - 2 ] : <blk> print ( [ i ] [ 0 ] ) </blk> <eos>
0 から a に 1 を加え た 値 未 満 までの 数 列 の各要素 を a と し 、 0 から b に 1 を加え た 値 未 満 までの 数 列 の各要素 を b と し 、 0 の 列 の 列 を p とする	p = [ [ 0 for b in range ( b + 1 ) ] for a in range ( a + 1 ) ]	b = [ [ 0 for b in range ( b + 1 ) ] for a in range ( a + 1 ) ] <eos>
0 から N の 長さ 未 満 までの 13 間 隔 の数 列 を 順に l として 、 繰 り 返す	for l in range ( 0 , len ( N ) , 13 ) :	for l in range ( 0 , len ( N ) , 13 ) : <eos>
can d i date s の 長さが 0 と 等しい とき 、	if len ( candidates ) == 0 :	if len ( candidates ) == 0 : <eos>
m から 1 を 引 いた 値を p とする	p = m - 1	p = m - 1 <eos>
s を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 のリスト を返す	return list ( map ( float , s . split ( ) ) )	return list ( map ( float , s . split ( ) ) ) <eos>
a を 2.0 倍 にする	a *= 2.0	a *= 2.0 <eos>
2 から N に 1 を加え た 値 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( 2 , N + 1 ) :	for k in range ( 2 , N + 1 ) : <eos>
output txt を " [ {} ] " を 書式 として array の i _ in s 番目 で 整 形 した 文字列 だけ 増加 させる	outputtxt += "[{}]" . format ( array [ i_ins ] )	outputtxt += " " . format ( array [ i ] ) <eos>
0 から m の n 乗 の 文字列の長さ 未 満 までの 4 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 0 , len ( str ( m ** n ) ) , 4 ) :	for i in range ( len ( len ( 0 , n ) ** 4 ) , 4 ) : <eos>
31 + 2 9 + 31 + 30 に 31 を加え た 値に 30 を加え た 値に 31 を加え た 値に 31 を加え た 値に D を加え た 値を days とする	days = 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + D	days = 31 + 29 + 31 + 31 + 31 + 31 + D <eos>
N の 末尾に i の 整数値 を追加する	N . append ( int ( i ) )	N . append ( int ( i ) ) <eos>
a [ 0 ] * b [ 1 ] * c [ 2 ] に a [ 2 ] * b [ 0 ] * c [ 1 ] を加え た 値に a [ 1 ] * b [ 2 ] に c [ 0 ] を 掛け た 値 を加え た 値 から a [ 2 ] に b [ 1 ] を 掛け た 値に c	return a [ 0 ] * b [ 1 ] * c [ 2 ] + a [ 2 ] * b [ 0 ] * c [ 1 ] + a [ 1 ] * b [ 2 ] * c [ 0 ] - a [ 2 ] * b [ 1 ] * c [ 0 ] - a [ 1 ] * b [ 0 ] * c [ 2 ] - a [ 0 ]	a [ 0 ] [ b * 2 ] [ 0 ] * b [ 1 ] + c [ 2 ] * a [ b ] [ 0 ] + c [ 1 ] * a [ b * b - c ] [ 1 ] * a [
r を self の r にする	self . r = r	self . r = r <eos>
self の x 座 標 の 2 乗 に self の y 座 標 の 2 乗 を加え た 値の 0.5 乗 を返す	return ( self . x ** 2 + self . y ** 2 ) ** 0.5	return ( self . x + self . y ** 2 ) ** 0.5 <eos>
y 2 から y 1 を 引 いた 値が 0 と 等しい とき 、	if ( y2 - y1 ) == 0 :	if y2 - y1 == 0 : <eos>
偽 を table の x 番目の y 番目 にする	table [ x ] [ y ] = False	table [ x ] [ y ] = False <eos>
( 、 つまり 偽 ) からなる 列 の N 回 分 の 列 を f in とする	fin = [ False ] * N	f = [ False ] * N <eos>
r の i から 1 を 引 いた 値 番目の 2 乗 に 1 を加え た 値 の平方根 を r の i 番目 にする	r [ i ] = math . sqrt ( r [ i - 1 ] ** 2 + 1 )	r [ i + 1 ] [ r ] = math . sqrt ( r [ i - 1 ] ) <eos>
1000 から 、 つまり 入力された 文字列の 整数値 を 引 いた 値 、 0 を b 、 c とする	b , c = 1000 - int ( input ( ) ) , 0	b , c = 1000 - int ( input ( ) ) , 0 <eos>
x を パラメータ として V の x 番目 を返す 関数を key として 0 から N 未 満 までの 数 列 の 最小 値を b 0 とする	b0 = min ( range ( N ) , key = lambda x : V [ x ] )	b = min ( range ( V ) , key = lambda x : ( V [ key ] ) ) <eos>
val の 文字列を v とする	v = str ( val )	v = str ( val ) <eos>
m の k 番目 が -1 と 等しくない とき s 0 の m の k 番目 番目 、 そうでなければ -1 を s の k 番目 にする	s [ k ] = s0 [ m [ k ] ] if m [ k ] != - 1 else - 1	s [ k ] = m [ - 1 ] if m [ k ] != 0 else s [ k - 1 ] <eos>
入力された 文字列の 整数値 を quest ion 1 とする	question1 = int ( input ( ) )	question_lines = int ( input ( ) ) <eos>
t _ cos t が dist ance の v 番目 より小さい とき 、	if t_cost < distance [ v ] :	if t_cost < distance [ v ] : <eos>
tm が " A ll " と 等しい とき 、	if tm == "All" :	if tm == <unk> : <eos>
un process ed の t 1 の末尾 番目の とき 、	if unprocessed [ t1 [ - 1 ] ] :	if unprocessed [ - 1 ] [ t1 ] : <eos>
2 から 11 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 2 , 11 ) :	for i in range ( 2 , 11 ) : <eos>
X を mp の y 番目の x 番目 にする	mp [ y ] [ x ] = "X"	mp [ y ] [ x ] = X <eos>
i に step を 掛け た 値を k とする	k = i * step	k = i * step <eos>
0 から L から b を 1 だけ 左 シフト した 値を 引 いた 値に 1 を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( L - ( b << 1 ) + 1 ) :	for j in range ( L - 1 ) : <eos>
cur _ ver t ex が end _ ver t ex と 等しい とき 、 <blk> f low を返す </blk>	if cur_vertex == end_vertex : <blk> return flow </blk>	if <unk> == <unk> : <blk> return flow </blk> <eos>
self の left が 、 つまり 未 定 値 と 等しくない とき 、 <blk> self . left . pre order ( ) </blk>	if self . left != None : <blk> self . left . preorder ( ) </blk>	if self . left is None : <blk> self . preorder ( self . left ) </blk> <eos>
( i 、 1 ) の 組 を S の x に 1 を加え た 値 から 、 つまり 末 尾 までの 部分 列 にする	S [ x + 1 : ] = ( i , 1 )	S [ x + 1 : ] = ( i , 1 ) <eos>
0 を pos i とする	posi = 0	<unk> = 0 <eos>
x が 0 以上の とき 、 <blk> an s を x だけ 増加 させる </blk>	if x >= 0 : <blk> ans += x </blk>	if x >= 0 : <blk> ans += x </blk> <eos>
i が -1 と 等しくない とき 、	if i != - 1 :	if i != - 1 : <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ b 、 m 、 e とする	b , m , e = map ( int , f_i . readline ( ) . split ( ) )	b , m , e = map ( int , f_i . readline ( ) . split ( ) ) <eos>
3 を i とする	i = 3	i = 3 <eos>
y 1 に d 1 を 掛け た 値に y 2 に d 2 を 掛け た 値 を加え た 値に y 3 に d 3 を 掛け た 値 を加え た 値を d sum で 割 った 値を y とする	y = ( y1 * d1 + y2 * d2 + y3 * d3 ) / dsum	sum = y1 * d1 + d2 * y2 + d3 / 3 * dy <eos>
{ 0 : . 8 f } { 1 : . 8 f } を 書式 として t x 、 t y で 整 形 した 文字列 を出力する	print ( "{0:.8f} {1:.8f}" . format ( tx , ty ) )	print ( "{0:.8f} {1:.8f}" . format ( tx , ty ) ) <eos>
e le v _ to _ h t の floor _ h e ight 番目 内の 全ての要素 を 取り除く	elev_to_ht [ floor_height ] . clear ( )	elev_to_ht [ <unk> ] . clear ( ) <eos>
空 辞書を last M on th とする	lastMonth = { }	lastMonth = { } <eos>
an s _ list の 末尾に an s を追加する	ans_list . append ( ans )	<unk> . append ( ans ) <eos>
に " " を 間 に入れ て node s の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を加え た 値 を出力する	print ( " " + " " . join ( map ( str , nodes ) ) )	print ( " " + " " " + " . join ( map ( str , nodes ) ) ) <eos>
an s を n の i 番目 を 3 で 割 った 商 だけ 増加 させる	ans += n [ i ] // 3	ans += n // 3 [ i ] <eos>
next a を a とする	a = nexta	a = <unk> <eos>
num s のコピー された 列 を a num s とする	anums = nums [ : ]	sa = nums [ : ] <eos>
a d j の start 番目 を 順に i 、 t として 、 繰 り 返す	for i , t in adj [ start ] :	for start , t in adj [ start ] : <eos>
0 から L IM 未 満 までの 数 列 の各要素 を x と し 、 0 の 列 を count _ arr とする	count_arr = [ 0 for x in range ( LIM ) ]	arr = [ [ 0 for x in range ( LIM ) ] for x in range ( LIM ) ] <eos>
an s の リストを an s とする	ans = list ( ans )	ans = list ( ans ) <eos>
top が 0 より大きい 間 、 次 を 繰 り 返す	while top > 0 :	while top > 0 : <eos>
self . _ find ( self . table [ x ] ) を self の table の x 番目 にする	self . table [ x ] = self . _find ( self . table [ x ] )	self . table [ x ] = self . _find ( self . _find ( x ) ) <eos>
0 から m 未 満 までの 数 列 を 順に _ として 、 繰 り 返す <blk> 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ t 、 s 、 d とする <sep> ( s 、 d ) の 組 を b の t 番目 にする </blk>	for _ in range ( m ) : <blk> t , s , d = map ( int , input ( ) . split ( ) ) <sep> b [ t ] = ( s , d ) </blk>	for s , t in range ( m ) : <blk> s [ b ] , t = tuple ( map ( int , input ( ) . split ( ) ) ) </blk> <eos>
score を 1 に base s の 総 和 を加え た 値 だけ 増加 させる	score += 1 + sum ( bases )	score += sum ( bases ) + base <eos>
4 を re n とする	ren = 4	re = 4 <eos>
2 に y 3 を 掛け た 値 から 2 に y 1 を 掛け た 値を 引 いた 値を b 2 とする	b2 = 2 * y3 - 2 * y1	b2 = 2 * y3 - y1 * y2 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ a 、 l 、 x とする	a , l , x = map ( int , input ( ) . split ( ) )	a , l , x = map ( int , input ( ) . split ( ) ) <eos>
D の u 番目 に i を加え た 値が D の j 番目 より小さい とき 、	if D [ u ] + i < D [ j ] :	if D [ u ] + D [ j ] < D [ j ] : <eos>
H S を 順に h として 、 繰 り 返す	for h in HS :	for h in HS : <eos>
d f s ( s , k , i + 1 ) を r とする	r = dfs ( s , k , i + 1 )	r = dfs ( k , i + 1 , i + 1 ) <eos>
0 から d 未 満 までの 数 列 の各要素 を i と し 、 0 から n 未 満 までの 数 列 の各要素 を j と し 、 w の i + 1 番目の j 番目 から w の i 番目の j 番目 を 引 いた 値の 列 の 列 を p とする	p = [ [ w [ i + 1 ] [ j ] - w [ i ] [ j ] for j in range ( n ) ] for i in range ( d ) ]	w = [ dp [ i ] [ j ] [ w [ i ] ] for j in range ( d ) ] <eos>
num s の i 番目 が max i と 等しい とき 、	if nums [ i ] == maxi :	if nums [ i ] == maxi : <eos>
0 から N の 長さ 未 満 までの 数 列 を 順に ll として 、 繰 り 返す	for ll in range ( len ( N ) ) :	for ll in range ( len ( N ) ) : <eos>
co st に d を加え た 値が dist に対応する 値 、 もし 存在し なければ key 、 IN F より小さい とき 、	if cost + d < dist . get ( key , INF ) :	if cost + d . get ( dist , key ) < INF : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ h 、 m とする	h , m = map ( int , input ( ) . split ( ) )	h , m = map ( int , input ( ) . split ( ) ) <eos>
n が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if n == 0 : <blk> break </blk>	if n == 0 : <blk> break </blk> <eos>
0 から array の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( array ) ) :	for i in range ( len ( array ) ) : <eos>
cross _ point ( b i , b i + 1 , a 0 , a 1 ) を cp とする	cp = cross_point ( bi , bi + 1 , a0 , a1 )	cp = cross_point ( bi , 1 + a , b , 1 ) <eos>
( 、 つまり 偽 ) からなる 列 の 13 回 分 の 列 を s とする	s = [ False ] * 13	s = [ False ] * 13 <eos>
c r s _ a に c r s _ b を 掛け た 値に c r s _ c を 掛け た 値に c r s _ d を 掛け た 値が 0 より小さい とき 、	if crs_a * crs_b * crs_c * crs_d < 0 :	if <unk> * <unk> * <unk> < 0 : <eos>
Point ( x _ sub , y _ sub ) を返す	return Point ( x_sub , y_sub )	return Point ( <unk> , sub ) <eos>
p を p r v とする	prv = p	prv = p <eos>
m の 11 番目の 整数値 が Check D is it ( m ) と 等しい とき 、	if int ( m [ 11 ] ) == CheckDisit ( m ) :	if int ( m [ 11 ] ) == D ( m ) : <eos>
com の 1 番目 が s に含まれる とき 、 <blk> ' yes ' を出力する </blk>	if com [ 1 ] in s : <blk> print ( 'yes' ) </blk>	if com [ 1 ] in s : <blk> print ( 'yes' ) </blk> <eos>
p _ queue の 末尾に p u z z le を追加する	p_queue . append ( puzzle )	p_queue . append ( new_puzzle ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ a 1 、 m 1 、 a 2 、 m 2 、 a 3 、 m 3 とする	a1 , m1 , a2 , m2 , a3 , m3 = map ( int , input ( ) . split ( ) )	a1 , m1 , a2 , m2 , a3 , m3 = map ( int , input ( ) . split ( ) ) <eos>
check ( used , n , s , me m o ) を an s とする	ans = check ( used , n , s , memo )	ans = check ( used , n , s ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を 展開 し 、 それぞれ m 、 d とする	m , d = [ int ( _ ) for _ in input ( ) . split ( ) ]	m , d = [ int ( _ ) for _ in input ( ) . split ( ) ] <eos>
a が b より大きい とき 、	if a > b :	if a > b : <eos>
num が '0' と 等しい とき 、	if num == '0' :	if num == '0' : <eos>
check ( d x , d y ) の とき 、 <blk> 繰り返し を 中断 する </blk>	if check ( dx , dy ) : <blk> break </blk>	if check ( dx , dy ) : <blk> break </blk> <eos>
改行 せずに p num の i 番目 を出力する	print ( pnum [ i ] , end = "" )	print ( pnum [ i ] , end = "" ) <eos>
i が n から 1 を 引 いた 値 より小さい とき 、 <blk> 空行 を出力する </blk>	if i < n - 1 : <blk> print ( ) </blk>	if i < n - 1 : <blk> print ( ) </blk> <eos>
grap h の 、 つまり 現在の 日時 番目 を 順に next として 、 繰 り 返す	for next in graph [ now ] :	for next in graph [ now ] : <eos>
p の 2 7 番目 、 p の先頭 を p の先頭 、 p の 2 7 番目 とする	p [ 0 ] , p [ 27 ] = p [ 27 ] , p [ 0 ]	p [ 0 ] , p [ 27 ] = p [ 27 ] , p [ 0 ] <eos>
a が b より大きい とき 、 <blk> t を 3 だけ 増加 させる </blk>	if a > b : <blk> t += 3 </blk>	if a > b : <blk> t += 3 </blk> <eos>
( - IN F ) からなる 列 の N 回 分 の 列 を dist とする	dist = [ - INF ] * N	dist = [ - INF ] * N <eos>
space の 末尾に row を追加する	space . append ( row )	space . append ( row ) <eos>
string が d ic _ G に含まれる とき 、	if string in dic_G :	if string in <unk> : <eos>
x から b x を 引 いた 値の 2 乗 に y から by を 引 いた 値の 2 乗 を加え た 値の 0.5 乗 を b とする	b = ( ( x - bx ) ** 2 + ( y - by ) ** 2 ) ** 0.5	b = ( ( ( x - xx ) ** 2 + ( by - yy ) ** 2 ) ** 0.5 <eos>
0 から 13 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 13 ) :	for j in range ( 13 ) : <eos>
S から L を 引 いた 値の 文字列 の各要素 を _ と し 、 _ の 列 を digits とする	digits = [ _ for _ in str ( S - L ) ]	digits = [ str ( _ ) for _ in S ] <eos>
n に 2 の 0.5 乗 を 掛け た 値が n を 1 で 割 った 商 に 1 を加え た 値 より小さい とき n を 1 で 割 った 商 に 1 を加え た 値 、 そうでなければ n に 2 の 0.5 乗 を 掛け た 値 を出力する	print ( n // 1 + 1 if n * 2 ** 0.5 < n // 1 + 1 else n * 2 ** 0.5 )	print ( n * 0.5 + 1 if n * 2 // 0.5 ) < 1 else n // 2 + 1 ) <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を 展開 し 、 それぞれ d 、 a とする	d , a = list ( map ( int , input ( ) . split ( ',' ) ) )	a , d = list ( map ( int , input ( ) . split ( ',' ) ) ) <eos>
N の l 番目の 整数値 を k とする	k = int ( N [ l ] )	k = int ( N [ l ] ) <eos>
right 0 、 right end ( p o ly 1 ) の 最大 値を right とする	right = max ( right0 , rightend ( poly1 ) )	right = max ( right0 , end ) <eos>
re t が 0 より大きい とき 、	if ret > 0 :	if ret > 0 : <eos>
points ( t r im ( N ) )	points ( trim ( N ) )	points ( <unk> ( N ) ) <eos>
S . un it e Set s ( s , t )	S . uniteSets ( s , t )	S . <unk> ( s , t ) <eos>
0 から 8 未 満 までの 数 列 を 順に c として 、 繰 り 返す	for c in range ( 8 ) :	for c in range ( 8 ) : <eos>
St a c k ( ) を accu m l at or とする	accumlator = Stack ( )	accumlator = <unk> ( ) <eos>
at i が 12 と 等 し く または t r の p の t 番目 番目 が a d j の at i 番目 と 等しい とき 、	if ati == 12 or tr [ p [ t ] ] == adj [ ati ] :	if ( <unk> == tr [ t [ i ] or tr [ j ] == adj [ t [ i ] : <eos>
a が b と 等しい とき 、	if a == b :	if a == b : <eos>
self . is _ le a f ( ) の とき 、	if self . is_leaf ( ) :	if self . <unk> ( ) : <eos>
x 1 から x 2 を 引 いた 値の 2 乗 に y 1 から y 2 を 引 いた 値の 2 乗 を加え た 値 の平方根 を dist とする	dist = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 )	dist = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <eos>
os . path の 末尾に start を追加する	path . append ( start )	path . append ( start ) <eos>
800 を返す	return 800	return <unk> <eos>
math モジュール を用い る	from math import pi , cos , sin	from math import cos , cos , radians <eos>
0 を 無限 の 整数 列 とする	count = 0	count = 0 <eos>
n が 、 つまり 空 列 と 等しくな く かつ n の 先頭の 全て が 英 大文字 かどうか が 、 つまり 偽 と 等しい 間 、 次 を 繰 り 返す <blk> an s を n の 0 を取り出し た 値 だけ 増加 させる </blk>	while n != [ ] and n [ 0 ] . isupper ( ) == False : <blk> ans += n . pop ( 0 ) </blk>	while n != [ ] and n [ 0 ] == False : <blk> ans += False </blk> <eos>
i に 1 を加え た 値を返す	return i + 1	return i + 1 <eos>
b l ood を 順に i として 、 繰 り 返す <blk> b l ood の i 番目 を出力する </blk>	for i in blood : <blk> print ( blood [ i ] ) </blk>	for i in blood : <blk> print ( blood [ blood [ i ] ) </blk> <eos>
ABC を c up とする	cup = "ABC"	cup = <unk> <eos>
[ MASK ] の 両端 キュー を que とする	que = deque ( )	que = collections . deque ( ) <eos>
N を 順に i として 、 繰 り 返す	for i in N :	for i in N : <eos>
id x _ verti ce s の各要素 を x と し 、 x の 整数値 の 列 を verti ce s の id x の 整数値 番目 にする	vertices [ int ( idx ) ] = [ int ( x ) for x in idx_vertices ]	vertices [ idx ] = [ int ( x ) for x in vertices ] <eos>
0 から member の 長さ 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( len ( member ) ) :	for j in range ( len ( member ) ) : <eos>
( d 、 x 、 y ) の 組 を返す	return ( d , x , y )	return ( d , x , y ) <eos>
( r 、 0 ) の 組 を P の r 番目 にする	P [ r ] = ( r , 0 )	P [ r ] = ( r , 0 ) <eos>
400 を min _ d とする	min_d = 400	min_d = <unk> <eos>
tm が " N ight " と 等しい とき 、	if tm == "Night" :	if tm == <unk> : <eos>
q 0 の v 番目 で ないとき 、	if not q0 [ v ] :	if not q0 [ v ] : <eos>
a の先頭 を p とする	p = a [ 0 ]	p = a [ 0 ] <eos>
d の w 番目の 末尾に p の 整数値 を追加する	d [ w ] . append ( int ( p ) )	d [ w ] . append ( int ( p ) ) <eos>
now _ value を min _ value とする	min_value = now_value	min_value = now_value <eos>
改行 せずに table の 7 から j を 引 いた 値 番目の i 番目 を出力する	print ( table [ 7 - j ] [ i ] , end = "" )	print ( table [ 7 - j ] [ i ] , end = "" ) <eos>
s ec を 36 00 で 割 った 商 を hour とする	hour = sec // 3600	hour = sec // 3600 <eos>
m _ sum を m の j 番目 だけ 増加 させる	m_sum += m [ j ]	sum_m += sum_m [ j ] <eos>
( ( 0 、 start ) の 組 ) からなる 列 を h q とする	hq = [ ( 0 , start ) ]	hq = [ ( 0 , start ) ] <eos>
h c s d 、 t gt _ h c s d の 要素を それぞれ 組 に した 列 を 順に src 、 t gt として 、 繰 り 返す	for src , tgt in zip ( hcsd , tgt_hcsd ) :	for no , tgt in zip ( h_cost , hcsd_order ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 q とする	n , q = map ( int , input ( ) . split ( ) )	n , q = map ( int , input ( ) . split ( ) ) <eos>
0 を re t とする	ret = 0	ret = 0 <eos>
d f s ( 0 , [ 0 ] * L , [ 1 ] + [ 0 ] * 2 6 )	dfs ( 0 , [ 0 ] * L , [ 1 ] + [ 0 ] * 26 )	dfs ( 0 , L [ 0 ] * L + 1 , [ 2 ] * 6 ] ) <eos>
d の 最大 値 から d の 最小 値を 引 いた 値 を出力する	print ( max ( d ) - min ( d ) )	print ( max ( d ) - min ( d ) ) <eos>
s eg ment _ line _ s im pl ify ( N , L S ) を展開し 、 それぞれ L 、 G 0 、 P S とする	L , G0 , PS = segment_line_simplify ( N , LS )	S , G0 , PS = <unk> ( L , L ) <eos>
( 1 ) からなる 列 の 5 回 分 の 列 を an s とする	ans = [ 1 ] * 5	ans = [ 1 ] * 5 <eos>
15 を MAX とする	MAX = 15	MAX = <unk> <eos>
st u den s の 末尾に s を追加する	studens . append ( s )	studens . append ( s ) <eos>
無限 の 整数 列 が N と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if count == N : <blk> break </blk>	if count == N : <blk> break </blk> <eos>
m の i に 1 を加え た 値 番目の j に 1 を加え た 値 番目の とき 、	if m [ i + 1 ] [ j + 1 ] :	if m [ i + 1 ] [ j + 1 ] : <eos>
真 を check ed の key 番目 にする	checked [ key ] = True	checked [ key ] = True <eos>
last を 1 だけ 減 少 させる	last -= 1	last -= 1 <eos>
input ( ) . split ( ) の各要素 に int を 適用 した 列 のリスト の 総 和 を K から 1 を 引 いた 値で 割 った 商 を出力する	print ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) // ( K - 1 ) )	print ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) - 1 ) <eos>
L の j 番目 を tmp の j 番目 だけ 増加 させる	L [ j ] += tmp [ j ]	L [ j ] += tmp [ j ] <eos>
b に c c を 掛け た 値 から b b に c を 掛け た 値を 引 いた 値を a に b b を 掛け た 値 から a a に b を 掛け た 値を 引 いた 値で 割 った 値 、 c に a a を 掛け た 値 から c c に a を 掛け た 値を 引 いた 値を a に b b を 掛け た 値 から a a に b を 掛け た	x , y = ( b * cc - bb * c ) / ( a * bb - aa * b ) , ( c * aa - cc * a ) / ( a * bb - aa * b )	return b * c - ( a * b - a * b * c ) / ( a * b - a * b ) <eos>
空 列 を groups とする	groups = [ ]	groups = [ ] <eos>
parent _ search ( tree , node ) を node _ parent とする	node_parent = parent_search ( tree , node )	parent = parent_search ( tree , node ) <eos>
T の i 番目の 末尾に i を追加する	T [ i ] . append ( i )	T [ i ] . append ( i ) <eos>
( 、 つまり 未 定 値 ) からなる 列 を self の stack にする	self . stack = [ None ]	self . stack = [ None ] <eos>
e が 全て 数字 の とき 、	if e . isdigit ( ) :	if e . isdigit ( ) : <eos>
0 、 b 0 から s a を 引 いた 値の 最大 値 から b 0 に s a を加え た 値 、 N から 1 を 引 いた 値の 最小 値に 1 を加え た 値 未 満 までの 数 列 を 順に t として 、 繰 り 返す	for t in range ( max ( 0 , b0 - sa ) , min ( b0 + sa , N - 1 ) + 1 ) :	for t in range ( min ( max ( b - a ) + 1 ) + min ( t - a - b ) ) : <eos>
answer を N の 、 つまり 無限 の 整数 列 に 1 を加え た 値 番目の 整数値 に N の 、 つまり 無限 の 整数 列 に 2 を加え た 値 番目 を 掛け た 値 だけ 増加 させる	answer += int ( N [ count + 1 ] ) * N [ count + 2 ]	answer += int ( N [ count + 1 ] ) * N [ 2 + count ] [ count ] <eos>
n y 、 target において 正規表現 n x が 最初 にマッチする 位置	search ( nx , ny , target )	search ( n , search ( nx , ny , target ) ) <eos>
( 0 ) からなる 列 の M に 1 を加え た 値 回 分 の 列 を ma とする	ma = [ 0 ] * ( M + 1 )	ma = [ 0 ] * ( M + 1 ) <eos>
check ( p ) の とき 、	if check ( p ) :	if check ( p ) : <eos>
x を パラメータ として ( - x の 2 番目 、 x の 3 番目 、 x の先頭 ) の 組 を返す 関数を key として T e am を ソート する	Team . sort ( key = lambda x : ( - x [ 2 ] , x [ 3 ] , x [ 0 ] ) )	Team . sort ( key = lambda x : ( - x [ 2 ] , x [ 3 ] , x [ 3 ] ) ) <eos>
t の i 番目の 2 番目 が 0 より大きい とき cal c ( t [ i ] [ 2 ] ) 、 そうでなければ 1 を w r とする	wr = calc ( t [ i ] [ 2 ] ) if t [ i ] [ 2 ] > 0 else 1	w = calc ( t [ i ] [ 0 ] if t [ i ] [ 2 ] > 0 else wb ) <eos>
0 から 100 未 満 までの 数 列 の各要素 を i と し 、 0 の 列 を l is とする	lis = [ 0 for i in range ( 100 ) ]	lis = [ 0 for i in range ( 100 ) ] <eos>
1 から x の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , len ( x ) ) :	for i in range ( 1 , len ( x ) ) : <eos>
time を que の 、 つまり 先頭から i 番目 までの 部分 列 の 総 和 だけ 増加 させる	time += sum ( que [ 0 : i ] )	time += sum ( que [ : i ] ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ t 1 、 n 1 とする	t1 , n1 = map ( int , input ( ) . split ( ) )	t1 , t1 = map ( int , input ( ) . split ( ) ) <eos>
M C F . add _ ed ge ( s , i , 1 , 0 )	MCF . add_edge ( s , i , 1 , 0 )	MCF . add_edge ( s , i , 1 , 0 ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ h 、 m 、 s とする	h , m , s = map ( int , input ( ) . split ( ) )	h , m , s = map ( int , input ( ) . split ( ) ) <eos>
1 を result の n O r i g in の 整数値 番目 にする	result [ int ( nOrigin ) ] = 1	result [ i ] = int ( result ) <eos>
t の i 番目 と 2 の 論理 積 の とき 、	if t [ i ] & 2 :	if t [ i ] & 2 : <eos>
空 辞書 、 未 定 値を tree 、 root とする	tree , root = { } , None	tree , root = { } , None <eos>
x を 36 00 で 割 った 余 り を 60 で 割 った 余 り を s _ a とする	s_a = x % 3600 % 60	<unk> = x % 3600 % 60 <eos>
n が 2 より 小さく または n を 2 で 割 った 余 り が 0 と 等しい とき 、	if n < 2 or n % 2 == 0 :	if n < 2 or n % 2 == 0 : <eos>
an s の 末尾に ' m ' を追加する	ans . append ( 'm' )	ans . append ( 'm' ) <eos>
c に ' ' を加え た 値に n の文字列 を加え た 値を key とする	key = c + ' ' + str ( n )	key = str ( c + n ) + str ( n ) <eos>
aug _ path _ f low 、 a d j _ m at の x 番目の y 番目の 最小 値を aug _ path _ f low とする	aug_path_flow = min ( aug_path_flow , adj_mat [ x ] [ y ] )	aug_path_flow = min ( aug_path_flow , fish [ j ] [ x ] ) <eos>
b を d だけ 減 少 させる	b -= d	b -= d <eos>
[ MASK ] の 両端 キュー を weight とする	weight = collections . deque ( )	weight = collections . deque ( ) <eos>
空 列 を ed ge とする	edge = [ ]	edge = [ ] <eos>
k が self の n _ から 1 を 引 いた 値 より小さい とき 、	if k < self . n_ - 1 :	if k < self . n - 1 : <eos>
proc の 1 番目の 整数値 が q 以下の とき 、	if int ( proc [ 1 ] ) <= q :	if int ( proc [ 1 ] ) <= q : <eos>
0 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> d の i 番目 を g で 割 った 商 を出力する </blk>	for i in range ( n ) : <blk> print ( d [ i ] // g ) </blk>	for i in range ( n ) : <blk> print ( d [ i ] // g ) </blk> <eos>
res の i 番目 を line 内の 、 つまり 文字 コード ' a ' の順序 数 に i を加え た 値の 文字の 出現 回数 だけ 増加 させる	res [ i ] += line . count ( chr ( ord ( 'a' ) + i ) )	res [ chr ( i + ord ( 'a' ) ) . count ( i ) ] += ord ( 'a' ) <eos>
self の state が COR R ECT _ ST ATE と 等しい かどうか を返す	return self . state == CORRECT_STATE	return self . state == <unk> <eos>
c ir c um c ir c le ( P 1 , P 2 , P 3 ) を展開し 、 それぞれ x 、 y 、 r とする	x , y , r = circumcircle ( P1 , P2 , P3 )	x , y , r = <unk> ( P1 , P2 , P3 ) <eos>
m f . add _ ed ge ( i + x , t , 1 )	mf . add_edge ( i + x , t , 1 )	mf . add_edge ( i + x , t , 1 ) <eos>
out を " {} " だけ 増加 させる	out += { cur . val }	out += { self . val } <eos>
0 を返す	return 0	return 0 <eos>
m が 1 e - 10 より大きく または 13 が a の 長さ より小さい とき ' N A ' 、 そうでなければ a を出力する	print ( 'NA' if m > 1 e -10 or 13 < len ( a ) else a )	print ( 1 if m > 1 or len ( a ) > 13 else a ) <eos>
prime ( )	prime ( )	prime ( ) <eos>
vec _ self _ to _ other . arg ( ) を the t a _ base _ to _ other とする	theta_base_to_other = vec_self_to_other . arg ( )	vec_a = vec_self_to_other . get_value ( other ) <eos>
check ( s , i ) の とき 、	if check ( s , i ) :	if check ( s , i ) : <eos>
code を " 0 " に - code の 長さ を 5 で 割 った 余 り を 掛け た 値 だけ 増加 させる	code += "0" * ( - len ( code ) % 5 )	code += "0" * ( len ( code ) % 5 ) <eos>
( ' ch ic k en ' 、 ' egg ' ) からなる 列 の r が ' e ' と 等しい かどうか 番目 を出力する	print ( [ 'chicken' , 'egg' ] [ r == 'e' ] )	print ( [ <unk> , <unk> ] [ r == <unk> ] ) <eos>
score の tea m 1 から 1 を 引 いた 値 番目 を 1 だけ 増加 させる	score [ team1 - 1 ] += 1	score [ team1 - 1 ] += 1 <eos>
d ice 2 . W ( )	dice2 . W ( )	dice2 . W ( ) <eos>
( ( 1 00000 ) からなる 列 の 0 から n 未 満 までの 数 列 の各要素 を i と し 、 3 の 列 回 分 の 列 ) からなる 列 を f a re とする	fare = [ [ 100000 ] * [ 3 for i in range ( n ) ] ]	fare = [ [ 100000 ] * [ a for i in range ( 3 ) ] ] <eos>
a をコピーし た 結果を b とする	b = copy . copy ( a )	b = copy . copy ( a ) <eos>
F i b ( n -1 ) に F i b ( n -2 ) を加え た 値を返す	return Fib ( n - 1 ) + Fib ( n - 2 )	return F ( btn ( n - 1 ) + b - 2 ) <eos>
w k が " A ll " と 等しい とき 、	if wk == "All" :	if <unk> == <unk> : <eos>
words の i 番目の 長さが 4 と 等しい とき 、	if len ( words [ i ] ) == 4 :	if len ( words [ i ] ) == 4 : <eos>
0 から N に 1 を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( N + 1 ) :	for j in range ( N + 1 ) : <eos>
T を 空白 で 分割 した 字句 列 のリスト を small _ T とする	small_T = list ( T . split ( ) )	b_T = list ( T . split ( ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を Q とする	Q = list ( map ( int , input ( ) . split ( ) ) )	Q = list ( map ( int , input ( ) . split ( ) ) ) <eos>
0 を A B とする	AB = 0	B = 0 <eos>
T の i 番目 を t とする	t = T [ i ]	t = T [ i ] <eos>
( ( 0 、 0 ) からなる 列 ) からなる 列 を s qua re とする	square = [ [ 0 , 0 ] ]	square = [ [ 0 , 0 ] ] <eos>
co st を money の j 番目 だけ 増加 させる	cost += money [ j ]	cost += money [ j ] <eos>
入力された 文字列を " " で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ N 、 M 、 D とする	N , M , D = [ int ( i ) for i in input ( ) . split ( " " ) ]	N , M , D = [ int ( i ) for i in input ( ) . split ( " " ) ] <eos>
1 が g ame に 含 まれ かつ 2 が g ame に含まれる とき 、	if 1 in game and 2 in game :	if 1 in game and game ( g1 ) : <eos>
i _ s を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ num 、 left _ child 、 right _ child とする	num , left_child , right_child = map ( int , i_s . split ( ) )	<unk> , <unk> , <unk> , right_child = map ( int , <unk> . split ( ) ) <eos>
g 3 の 末尾に P l a y er ( p , t ) を追加する	g3 . append ( Player ( p , t ) )	g3 . append ( Player ( p , t ) ) <eos>
i を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を score s とする	scores = list ( map ( int , i . split ( ) ) )	scores = list ( map ( int , i . split ( ) ) ) <eos>
t の 0 番目 が b の先頭 と 等しい とき 、	if t [ 0 ] == b [ 0 ] :	if t [ 0 ] == b [ 0 ] : <eos>
cd と 1 を p に 3 を 掛け た 値 だけ 左 シフト した 値 から 1 を 引 いた 値の 論理 積 を b 1 とする	b1 = cd & ( ( 1 << ( p * 3 ) ) - 1 )	b = ( cd & ( 1 << 3 * p ) - 1 ) <eos>
score sh e et を 順に tea m 、 n 、 points として 、 繰 り 返す	for team , n , points in scoresheet :	for team , n in scoresheet : <eos>
空 列 を self の node s にする	self . nodes = [ ]	self . nodes = [ ] <eos>
a が k の文字列 と 等しい かどうか を返す	return a == str ( k )	return str ( a == k ) <eos>
r の 、 つまり 先頭から 2 番目 までの 部分 列 が " IX " と 等しい とき 、	if r [ : 2 ] == "IX" :	if r [ : 2 ] == <unk> : <eos>
b を a で 割 った 余 り が 0 と 等しい とき 、	if b % a == 0 :	if b % a == 0 : <eos>
x _ b から x _ a を 引 いた 値 、 y _ b から y _ a を 引 いた 値を ab _ x 、 ab _ y とする	ab_x , ab_y = x_b - x_a , y_b - y_a	xa , ya = x_ab - x_b , yb - y_b <eos>
区切り なしで ' C a se ' 、 i に 1 を加え た 値 、 ' : ' を出力する	print ( 'Case ' , i + 1 , ':' , sep = '' )	print ( "Case <unk> , i + 1 , sep = '' ) <eos>
m と 1 の 論理 積 の とき 、 <blk> a の 末尾に 2 の c 乗 を追加する </blk>	if m & 1 : <blk> a . append ( 2 ** c ) </blk>	if m & 1 : <blk> a . append ( a . append ( 2 ) ) </blk> <eos>
conv ex _ h ul l の 長さが 1 と 等 し く または conv ex _ h ul l の -1 番目 が conv ex _ h ul l の先頭 と 等しくない 間 、 次 を 繰 り 返す	while len ( convex_hull ) == 1 or convex_hull [ - 1 ] != convex_hull [ 0 ] :	while len ( convex_hull [ 1 ] ) == - 1 or convex_hull [ 0 ] != convex_hull [ - 1 ] : <eos>
buf の pos 番目 を op とする	op = buf [ pos ]	op = buf [ pos ] <eos>
d ic _ G に string を 追加した 集 まり	dic_G . add ( string )	dic . add ( string ) <eos>
n を 4 だけ 増加 させる	n += 4	n += 4 <eos>
0 、 空 列 を an s 、 tb l とする	ans , tbl = 0 , [ ]	ans , tbl = 0 , [ ] <eos>
defaultdict ( list ) を rel ation s とする	relations = defaultdict ( list )	relations = defaultdict ( list ) <eos>
self の IN F を self の lazy の k 番目 にする	self . lazy [ k ] = self . INF	self . lazy [ k ] = self . INF <eos>
1000 001 を MAX とする	MAX = 1000001	MAX = <unk> <eos>
a の i 番目 が c に m を加え た 値 より大きい とき 、	if a [ i ] > c + m :	if a [ i ] > m + m : <eos>
a から 1 を 引 いた 値を 1000 で 割 った 商 に 1 を加え た 値に 1000 を 掛け た 値を a とする	a = ( ( a - 1 ) // 1000 + 1 ) * 1000	a = a - 1 // 1000 + 1 <eos>
空 列 を de e p en _ x とする	deepen_x = [ ]	new_puzzle = [ ] <eos>
i に 1 を加え た 値を n とする	n = i + 1	n = i + 1 <eos>
x が n を 2 で 割 った 商 より大きい とき 、 <blk> 繰り返し を 中断 する </blk>	if x > n // 2 : <blk> break </blk>	if x > n // 2 : <blk> break </blk> <eos>
V の キーと値 の集まり を 順に k 、 v として 、 繰 り 返す	for k , v in V . items ( ) :	for k , v in V . items ( ) : <eos>
空 辞書を dist _ from _ 0 とする	dist_from_0 = { }	dist_from_0 = { } <eos>
p が s に 2 を 掛け た 値 に含まれる とき 、	if p in s * 2 :	if p in s * 2 : <eos>
3 の i 乗 から 1 を 引 いた 値を 2 で 割 った 商 を g a p とする	gap = ( 3 ** i - 1 ) // 2	gap = 3 ** ( i - 1 ) // g2 <eos>
真 を s witch とする	switch = True	switch = True <eos>
G を 逆 順に する	G . reverse ( )	G . reverse ( ) <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 0 から 7 未 満 までの 数 列 の各要素 を j と し 、 '' の 列 の 列 を a とする	a = [ [ '' for j in range ( 7 ) ] for i in range ( n ) ]	a = [ [ '' for j in range ( 7 ) ] for i in range ( n ) ] <eos>
c 2 から c を 引 いた 値に 1 を加え た 値を w とする を w 2 とする	w2 = w = c2 - c + 1	w2 = c2 - c1 + 1 <eos>
to _ forward を 順に t 、 at 、 n x t 、 cur 、 num として 、 繰 り 返す	for t , at , nxt , cur , num in to_forward :	for t , nxt , cur , num in skip_row : <eos>
f e e の c 番目の b 番目 に e を加え た 値に f e e の a 番目の d 番目 を加え た 値を t とする	t = fee [ c ] [ b ] + e + fee [ a ] [ d ]	t = fee [ c ] [ b ] + e + f [ d ] [ t ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ c 1 、 c 2 、 c 3 とする	c1 , c2 , c3 = map ( int , input ( ) . split ( ) )	c1 , c2 , c3 = map ( int , input ( ) . split ( ) ) <eos>
空 列 を pairs とする	pairs = [ ]	pairs = [ ] <eos>
M を 順に row として 、 繰 り 返す	for row in M :	for row in M : <eos>
table の c から i を 引 いた 値 から 1 を 引 いた 値 番目の i 番目 を table の c から i を 引 いた 値 から 2 を 引 いた 値 番目の i 番目 だけ 増加 させる	table [ c - i - 1 ] [ i ] += table [ c - i - 2 ] [ i ]	table [ c - i - 1 ] [ c - i ] += table [ i ] [ c - 2 ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を ソート した 列 を 展開 し 、 それぞれ a 、 b 、 _ とする	a , b , _ = sorted ( map ( int , input ( ) . split ( ) ) )	a , b , _ = sorted ( map ( int , input ( ) . split ( ) ) <eos>
文字 コード ' A ' の順序 数 に s ell s  の s ell s の 最大 値 と 等しい 要素の 最初の 位置 を加え た 値の 文字 、 s ell s の 最大 値 を出力する	print ( chr ( ord ( 'A' ) + sells . index ( max ( sells ) ) ) , max ( sells ) )	print ( chr ( ( ord ( ss ) + ss ) ) . index ( max ( s ) ) ) <eos>
x の 整数値 を出力する	print ( int ( x ) )	print ( int ( x ) ) <eos>
b の逆 順 を 順に x として 、 繰 り 返す	for x in b [ : : - 1 ] :	for x in b [ : - 1 ] : <eos>
me i j i { 0 } { 1 } { 2 } を 書式 として y から 1 86 7 を 引 いた 値 、 m 、 d で 整 形 した 文字列 を返す	return "meiji {0} {1} {2}" . format ( y - 1867 , m , d )	return <unk> <unk> . format ( ( y - 1867 , m , d ) ) <eos>
0 から n 未 満 までの 数 列 を 順に current として 、 繰 り 返す	for current in range ( n ) :	for current in range ( n ) : <eos>
0 から N line 未 満 までの 数 列 を 順に ll として 、 繰 り 返す	for ll in range ( Nline ) :	for ll in range ( N ) : <eos>
i に 1 を加え た 値 から s z 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( i + 1 , sz ) :	for j in range ( i + 1 , sz ) : <eos>
c を 開始 番号 として T の c 番目 から 、 つまり 末 尾 までの 部分 列 、 T の 要素を それぞれ 組 に した 列 に 番号 付 した 組 の 列 を 順に i 、 t として 、 繰 り 返す	for i , t in enumerate ( zip ( T [ c : ] , T ) , start = c ) :	for i , t in enumerate ( zip ( c , T [ : ] ) , start = c ) : <eos>
q から q に p を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( q , q + p ) :	for i in range ( q , p + q ) : <eos>
end が start 以下の とき 、	if end <= start :	if end <= start : <eos>
a を b が ' (' と 等しい とき c の 整数値 、 そうでなければ - c の 整数値 だけ 増加 させる	a += int ( c ) if b == '(' else - int ( c )	a += int ( b ) if c == '(' else - c <eos>
d を dist 2 の - i 番目 にする	dist2 [ - i ] = d	dist [ i ] = d <eos>
空 列 を an s _ out とする	ans_out = [ ]	<unk> = [ ] <eos>
a を d だけ 減 少 させる	a -= d	a -= d <eos>
s の 整数値 を出力する	print ( int ( s ) )	print ( int ( s ) ) <eos>
0 から x から 1 を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( x - 1 ) :	for i in range ( x - 1 ) : <eos>
k を 100 で 割 った 商 を k とする	k = k // 100	k = k // 100 <eos>
build _ g r id ( W , H , N , blocks ) を g r id とする	grid = build_grid ( W , H , N , blocks )	grid = <unk> ( W , H , grid ) <eos>
x の j 番目 を x の j に 1 を加え た 値 番目 にする	x [ j + 1 ] = x [ j ]	x [ j + 1 ] = x [ j ] <eos>
R を 順に c 、 l として 、 繰 り 返す	for c , l in R :	for c , l in R : <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ x _ p 0 、 y _ p 0 、 x _ p 1 、 y _ p 1 とする	x_p0 , y_p0 , x_p1 , y_p1 = map ( int , file_input . readline ( ) . split ( ) )	x_p0 , y_p0 , x_p1 , y_p1 , x_p3 , y_p0 = map ( int , file_input . readline ( ) . split ( ) ) <eos>
i  内の a に 2 を加え た 値 と 等しい 要素を 取り除く	i . remove ( a + 2 )	i . remove ( a + 2 ) <eos>
member 2 の 長さが n と 等しい とき 、	if len ( member2 ) == n :	if len ( <unk> ) == n : <eos>
queue の 末尾に start を追加する	queue . append ( start )	queue . append ( start ) <eos>
B in ary S e ar ch T re e ( ) を t とする	t = BinarySearchTree ( )	t = BinaryTree ( ) <eos>
整数 を ソート する	str . sort ( )	int ( str ) <eos>
10 を x とする	x = 10	x = 10 <eos>
sys の stdin から 読み込んだ 一行 の 整数値 を q とする	q = int ( sys . stdin . readline ( ) )	q = int ( sys . stdin . readline ( ) ) <eos>
sum を返す	return sum	return sum <eos>
L 、 row を '0' で 分割 した 字句 列 の各要素 を _ と し 、 _ の 長さ の 列 の 最大 値の 最大 値を L とする	L = max ( L , max ( [ len ( _ ) for _ in row . split ( '0' ) ] ) )	L = max ( L , max ( [ len ( _ ) for _ in row ) ] ) <eos>
right 、 width から row の逆 順  の m と 等しい 要素の 最初の 位置 を 引 いた 値 から 1 を 引 いた 値の 最大 値を right とする	right = max ( right , width - row [ : : - 1 ] . index ( m ) - 1 )	right = max ( right , width [ : - 1 ] ) - m . index ( 1 ) <eos>
last _ num で ないとき 、	if not last_num :	if not last_num : <eos>
1 000000 を mod とする	mod = 1000000	mod = 1000000 <eos>
map H の 先頭の i 番目 を map H の 先頭の i から 1 を 引 いた 値 番目 だけ 増加 させる	mapH [ 0 ] [ i ] += mapH [ 0 ] [ i - 1 ]	mapH [ 0 ] [ i ] += mapH [ 0 ] [ i - 1 ] <eos>
_ heap q モジュール を用い る	import _heapq	import _heapq <eos>
d q の 要素を 右 に - q の 1 番目 個 、 回 転 する	dq . rotate ( - q [ 1 ] )	dq . rotate ( - q [ 1 ] ) <eos>
\\\\\ ' \\\\ \\\\ n ' を 間 に入れ て self . root s ( ) の各要素 を r と し 、 ' {} : {} ' を 書式 として r 、 self . members ( r ) で 整 形 した 文字列の 列 を 連結 した 文字列 を返す \\\\\	\\\\\return '\\\\\\\\n' . join ( [ '{}: {}' . format ( r , self . members ( r ) ) for r in self . roots ( ) ] )\\\\\	\\\\\print ( '\\\\\\\\n' . format ( self . root , r ) for r in self . join ( [ <unk> ( self . root , self . root ) ] ) : <eos>\
l 内の ' R ' を r で 置き換え た 文字列を l とする	l = l . replace ( 'R' , r )	l = l . replace ( 'R' , 'R' ) <eos>
next が visit ed に含まれる とき 、	if next in visited :	if next in visited : <eos>
sub set s の 末尾に ( cal c _ int ( sub ) 、 sub ) の 組 を追加する	subsets . append ( ( calc_int ( sub ) , sub ) )	subsets . append ( ( calc ( int , sub ) ) ) <eos>
x 2 から x 1 を 引 いた 値を r x とする	rx = x2 - x1	xr = x2 - x1 <eos>
( 0 ) からなる 列 の N から 1 を 引 いた 値 回 分 の 列 を S とする	S = [ 0 ] * ( N - 1 )	S = [ 0 ] * ( N - 1 ) <eos>
mi 、 a の k に j を加え た 値 番目の 最小 値を mi とする	mi = min ( mi , a [ k + j ] )	mi = min ( mi , a [ k + j ] ) <eos>
s が d ic に 含まれない とき 、 <blk> 1 を d ic の s 番目 にする </blk>	if s not in dic : <blk> dic [ s ] = 1 </blk>	if s not in dic : <blk> dic [ s ] = 1 </blk> <eos>
right pos を child pos とする	childpos = rightpos	childpos = right <eos>
a の real に b の real を加え た 値を 2 で 割 った 値 、 a の imag に b の imag を加え た 値を 2 で 割 った 値を a x 、 a y とする	ax , ay = ( a . real + b . real ) / 2 , ( a . imag + b . imag ) / 2	xa , ya = a . real + b . real , a . imag / 2 , a . imag + a . imag / 2 <eos>
selection _ sort ( array _ s ) を array _ s とする	array_s = selection_sort ( array_s )	i_ins = <unk> ( array ) <eos>
pos が w より 小さく かつ buf の pos 番目 が 全て 数字 の間 、 次 を 繰 り 返す	while pos < w and buf [ pos ] . isdigit ( ) :	while pos < w and buf [ pos ] . isdigit ( ) : <eos>
G を an s とする	ans = "G"	ans = G <eos>
( N 、 0 ) の 組 を an s とする	ans = ( N , 0 )	ans = ( N , 0 ) <eos>
i が j と 等しい とき 、 <blk> 何も 返さ ない </blk>	if i == j : <blk> return </blk>	if i == j : <blk> return </blk> <eos>
x 、 y の 最小 値 、 x 、 y の 最大 値 を出力する	print ( min ( x , y ) , max ( x , y ) )	print ( min ( x , y ) , max ( x , y ) ) <eos>
y に 1 を加え た 値 、 9 の 最小 値を p o y とする	poy = min ( y + 1 , 9 )	hypo = min ( y + 1 , 9 ) <eos>
pairs の 末尾に x y を追加する	pairs . append ( xy )	pairs . append ( x ) <eos>
st ud ent の 末尾に i を追加する	student . append ( i )	student . append ( i ) <eos>
a に x に y を 掛け た 値 を加え た 値 、 b に y を加え た 値 、 c に 1 を加え た 値を a 、 b 、 c とする	a , b , c = a + x * y , b + y , c + 1	a , b , c = a + x * y , b + 1 , c + 1 <eos>
que の 末尾に ( w 、 c と 1 の 排 他 論理和 ) の 組 を追加する	que . append ( ( w , c ^ 1 ) )	que . append ( ( w ^ c ) ) <eos>
board の先頭 の先頭 を返す	return board [ 0 ] [ 0 ]	return board [ 0 ] [ 0 ] <eos>
p の 長さが 1 と 等しい とき 、	if len ( p ) == 1 :	if len ( p ) == 1 : <eos>
d f s ( c , d , state | ( 1 << c ) | ( 1 << d ) ) を展開し 、 それぞれ c 0 、 d 0 とする	c0 , d0 = dfs ( c , d , state | ( 1 << c ) | ( 1 << d ) )	c0 , d0 = dfs ( c , state | ( 1 << d ) | ( 1 << c ) ) <eos>
文字 コード ' a ' の順序 数 に i を加え た 値の 文字を ch とする	ch = chr ( ord ( 'a' ) + i )	ch = chr ( ord ( 'a' ) + i ) <eos>
d is _ list _ c ash を d is _ list とする	dis_list = dis_list_cash	dis_list = dis_list <eos>
direct が " >" と 等しい とき 、	if direct == ">" :	if "" == ">" : <eos>
v を ソート した 列 を 展開 して を出力する	print ( * sorted ( v ) )	print ( * sorted ( v ) ) <eos>
j が 0 と 等しい とき 、 <blk> root を 1 だけ 増加 させる </blk>	if j == 0 : <blk> root += 1 </blk>	if j == 0 : <blk> root += 1 </blk> <eos>
空 列 、 空 辞書を p a g 、 d ic とする	pag , dic = [ ] , { }	dic , dic = { } , [ ] <eos>
入力された 文字列を " " で 分割 した 字句 列 の各要素 を j と し 、 j の 整数値 から 1 を 引 いた 値の 列 を _ input とする	_input = [ int ( j ) - 1 for j in input ( ) . split ( " " ) ]	1 = [ int ( j ) - 1 for j in input ( ) . split ( " " ) ] <eos>
root ( p rt [ x ] ) を x とする を p rt の x 番目 にする	prt [ x ] = x = root ( prt [ x ] )	prt = root ( p [ x ] ) <eos>
A を 順に p 、 q として 、 繰 り 返す	for p , q in A :	for p , q in A : <eos>
an s に 1 を加え た 値の 整数値 を an s とする	ans = int ( ans + 1 )	ans = int ( ans + 1 ) <eos>
b を d 分 の 一 にする	b // = d	b // = d <eos>
a 、 b を c 0 、 c 1 とする	c0 , c1 = a , b	c0 , c1 = a , b <eos>
b が 0 より大きい とき 、 <blk> a を 1 だけ 増加 させる </blk>	if b > 0 : <blk> a += 1 </blk>	if b > 0 : <blk> a += 1 </blk> <eos>
c c w ( l [ -1 ] , l [ -2 ] , p ) の間 、 次 を 繰 り 返す	while ccw ( l [ - 1 ] , l [ - 2 ] , p ) :	while ccw ( l [ - 1 ] , l [ - 2 ] , p ) : <eos>
0 から n 1 未 満 までの 数 列 を 順に r として 、 繰 り 返す	for r in range ( n1 ) :	for r in range ( n1 ) : <eos>
v 1 に item _ v を加え た 値 、 v 2 の 最大 値を C の i 番目 にする	C [ i ] = max ( v1 + item_v , v2 )	C [ i ] = max ( v1 + v2 , v2 ) <eos>
cd を q に 1 を加え た 値 だけ 右 シフト した 値に 3 を 掛け た 値 と 1 を n - q から 1 を 引 いた 値 だけ 左 シフト した 値に 3 を 掛け た 値 から 1 を 引 いた 値の 論理 積 を b 3 とする	b3 = ( cd >> ( q + 1 ) * 3 ) & ( ( 1 << ( n - q - 1 ) * 3 ) - 1 )	b = ( cd >> ( q + 1 << 3 ) * ( n - 1 ) + ( q - 1 ) * 3 ) <eos>
f i g u re の row 番目の c ol 番目 が '1' と 等しい とき 、	if figure [ row ] [ col ] == '1' :	if figure [ row ] [ col ] == '1' : <eos>
50 001 を L IM とする	LIM = 50001	LIM = <unk> <eos>
( 1 ) からなる 列 の 10 1 回 分 の 列 を len _ re c とする	len_rec = [ 1 ] * 101	c_rec = [ 1 ] * 10 <eos>
c が " S " と 等しい とき 、	if ( c == "S" ) :	if c == "S" : <eos>
m の n 乗 に対する mod の 剰余 を出力する	print ( pow ( m , n , mod ) )	print ( pow ( m , n , mod ) ) <eos>
( d 3 、 d 2 、 d 6 、 d 1 、 d 5 、 d 4 ) からなる 列 を返す	return [ d3 , d2 , d6 , d1 , d5 , d4 ]	return [ d3 , d3 , d1 , d3 , d5 , d1 ] <eos>
card s のうち k 個 までの 順 列 の各要素 を t と し 、 '' を 間 に入れ て t を 連結 した 文字列の 列 の集合 を num s とする	nums = set ( [ '' . join ( t ) for t in permutations ( cards , k ) ] )	nums = set ( [ '' . join ( t ) for s in cards ] ) <eos>
1 から m 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , m ) :	for i in range ( 1 , m ) : <eos>
10 を y とする	y = 10	y = 10 <eos>
card の 0 番目 が card の 1 番目 と 等しい とき 、	if card [ 0 ] == card [ 1 ] :	if card [ 0 ] == card [ 1 ] : <eos>
de t ( ed ge 1 , ed ge 2 , r h s ) を de t _ abc で 割 った 値を t とする	t = det ( edge1 , edge2 , rhs ) / det_abc	t = det ( edge1 , edge2 , ray ) / det_abc <eos>
( 0 ) からなる 列 の n に a 、 b の 最大 値 を加え た 値に 1 を加え た 値 回 分 の 列 を f とする	f = [ 0 ] * ( n + max ( a , b ) + 1 )	f = [ 0 ] + max ( a , b + 1 ) <eos>
n uri ( table , m , x + 1 , y )	nuri ( table , m , x + 1 , y )	nuri ( table , m , x + 1 , y ) <eos>
arr の x 番目の 1 番目の とき 、 <blk> 繰り返し を 中断 する </blk>	if arr [ x ] [ 1 ] : <blk> break </blk>	if arr [ x ] [ 1 ] : <blk> break </blk> <eos>
( d i stances  の max _ d と 等しい 要素の 最初の 位置 、 max _ d ) の 組 を返す	return ( distances . index ( max_d ) , max_d )	return ( distances . index ( ( max_d , max_d ) ) <eos>
a _ tmp の j 番目 を a の i 番目の j 番目 にする	a [ i ] [ j ] = a_tmp [ j ]	a [ i ] [ j ] = a_tmp [ j ] <eos>
base に w 1 を w で 割 った 値 を加え た 値を b 2 とする	b2 = base + w1 / w	b2 = base + 1 / w <eos>
ed ge の集合 を ver t ex とする	vertex = set ( edge )	<unk> = set ( ) <eos>
OFF を second とする	second = "OFF"	second = "OFF" <eos>
p 0 が 、 つまり 未 定 値 と 等しくな く または p 1 が 、 つまり 未 定 値 と 等しくない とき 、	if p0 is None or p1 is None :	if p is None or None is None or None != None : <eos>
num に 1 を加え た 値が d より大きい とき 、 <blk> -1 を an s とする <sep> 繰り返し を 中断 する </blk>	if num + 1 > d : <blk> ans = - 1 <sep> break </blk>	if num + 1 > d : <blk> ans = - 1 <sep> break </blk> <eos>
S の i 番目 が cur と 等しい とき 、	if ( S [ i ] == cur ) :	if S [ i ] == cur : <eos>
i を i と - i の 論理 積 だけ 増加 させる	i += i & - i	i += i & - i <eos>
G の q 番目の 末尾に p を追加する	G [ q ] . append ( p )	G [ q ] . append ( p ) <eos>
array の 最大 値を m とする	m = max ( array )	m = max ( array ) <eos>
65 が s の i 番目の 順序 数 以下 かどうか が 6 7 以下の とき 、	if 65 <= ord ( s [ i ] ) <= 67 :	if 65 <= ord ( s [ i ] ) <= 6 : <eos>
d の r 番目の c 番目の 整数値 を k とする	k = int ( d [ r ] [ c ] )	k = int ( d [ r ] ) <eos>
cal c ( len ( D 1 ) , D 1 , z 1 , sum ( D 0 ) * 9 , None ) を S 1 とする	S1 = calc ( len ( D1 ) , D1 , z1 , sum ( D0 ) * 9 , None )	S = calc ( len ( D1 , D1 ) * CD , 1 , D0 ) <eos>
1 から n の 0.5 乗 の 整数値 を 3 で 割 った 商 に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , int ( n ** 0.5 ) // 3 + 1 ) :	for i in range ( 1 , int ( n ** 0.5 ) // 3 + 1 ) : <eos>
a の j 番目 を c だけ 減 少 させる	a [ j ] -= c	a [ j ] -= c <eos>
m が d に含まれる とき ' yes ' 、 そうでなければ ' no ' を出力する	print ( 'yes' if m in d else 'no' )	print ( 'yes' if m in d else 'no' ) <eos>
r ing ( string , pattern ) の とき " Y es " 、 そうでなければ " No " を出力する	print ( "Yes" if ring ( string , pattern ) else "No" )	print ( "Yes" if <unk> ( pattern , Y ) else "No" ) <eos>
line を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ M 、 T 、 P 、 R とする	M , T , P , R = map ( int , line . split ( ) )	T , M , P , R = map ( int , line . split ( ) ) <eos>
m から k に d を 掛け た 値を 引 いた 値を m とする	m = m - k * d	m = m - k * d <eos>
d ic の キーと値 の集まり を 順に v 、 m として 、 繰 り 返す	for v , m in dic . items ( ) :	for v , m in dic . items ( ) : <eos>
e から b を 引 いた 値を w とする	w = e - b	w = e - b <eos>
m を 60 で 割 った 余 り の 整数値 を minute s とする	minutes = int ( m % 60 )	s = int ( m % 60 ) <eos>
200 00 に 200 00 を 掛け た 値を max _ a re a とする	max_area = 20000 * 20000	max_area = 200 * <unk> <eos>
0 から rw から 1 を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( rw - 1 ) :	for i in range ( <unk> - 1 ) : <eos>
改行 せずに a の a  の x と 等しい 要素の 最初の 位置 から 3 を 引 いた 値 番目 を出力する	print ( a [ a . index ( x ) - 3 ] , end = '' )	print ( a [ a . index ( x ) - 3 ] , end = "" ) <eos>
D の 末尾に get _ dist ance _ s p ( b p 4 , b p 1 , s p ) を追加する	D . append ( get_distance_sp ( bp4 , bp1 , sp ) )	D . append ( get_distance_sp ( bp1 , ep , bp4 ) ) <eos>
q の 末尾に m を追加する	q . append ( m )	q . append ( m ) <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ k 、 t x 、 t y 、 tz とする	k , tx , ty , tz = map ( int , f_i . readline ( ) . split ( ) )	x , y , t , <unk> = map ( int , f_i . readline ( ) . split ( ) ) <eos>
right の 末尾に b all を追加する	right . append ( ball )	right . append ( ball ) <eos>
c を t の b 番目の si b にする	t [ b ] . sib = c	t [ b ] . sib = c <eos>
'' を 間 に入れ て 0 から w 未 満 までの 数 列 の各要素 を x と し 、 ' # . ' の ( x + y ) を 2 で 割 った 余 り 番目の 列 を 連結 した 文字列 を出力する	print ( '' . join ( [ '#.' [ ( x + y ) % 2 ] for x in range ( w ) ] ) )	\print ( '' . join ( [ '\\\\\\\\n' . join ( [ { y : x + 2 ] ) % "#" for y in range ( w ) ] ) ) <eos>\
a d j の j 番目の 末尾に ( i 、 d ) の 組 を追加する	adj [ j ] . append ( ( i , d ) )	adj [ j ] . append ( ( i , d ) ) <eos>
c の 末尾に h を追加する	c . append ( h )	c . append ( h ) <eos>
f ( a , 0 )	f ( a , 0 )	f ( a , 0 ) <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を a とする	a = list ( map ( int , f_i . readline ( ) . split ( ) ) )	a = list ( map ( int , f_i . readline ( ) . split ( ) ) ) <eos>
' r ' を f とする	f = 'r'	f = 'r' <eos>
空 列 を R 0 とする 空 列 を R 1 とする	R0 = [ ] R1 = [ ]	R1 = [ ] R1 = [ ] <eos>
make _ list ( G ) を g _ list とする	g_list = make_list ( G )	e_list = make_list ( G ) <eos>
入力された 文字列を 英 小文字 に変換し た 文字列を w とする	w = input ( ) . lower ( )	w = input ( ) . lower ( ) <eos>
quick S or t ( a , q + 1 , r )	quickSort ( a , q + 1 , r )	quickSort ( a , q + 1 , r ) <eos>
i から n 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( i , n ) :	for j in range ( i , n ) : <eos>
p の i から 3 を 引 いた 値 から 、 つまり 末 尾 までの 部分 列 の 総 和 を p の i 番目 にする	p [ i ] = sum ( p [ i - 3 : ] )	p [ i ] = sum ( p [ i - 3 : ] ) <eos>
( 4 14 12 12 1 、 14 12 12 14 、 4 12 12 14 1 、 12 12 14 14 、 2 12 14 14 1 、 12 14 14 12 、 2 14 14 12 1 、 14 14 12 12 ) からなる 列 を d とする	d = [ 41412121 , 14121214 , 41212141 , 12121414 , 21214141 , 12141412 , 21414121 , 14141212 ]	<unk> = [ 4 , 1 , 12 , 14 , 14 , 12 , <unk> , 12 , <unk> , 12 , 12 , <unk> ] <eos>
を s とする	s = ""	s = "" <eos>
a の各要素 を x と し 、 b を展開し て の 要素を それぞれ 組 に した 列 の各要素 を y と し 、 zip ( x , y ) の各要素 を j 、 k と し 、 j * k の 列 の 総 和 の 列 の 列 の各要素 を x と し 、 x を展開し て を出力する の 列	[ print ( * x ) for x in [ [ sum ( [ j * k for j , k in zip ( x , y ) ] ) for y in zip ( * b ) ] for x in a ] ]	[ print ( sum ( [ x * y for x , y in [ x for j in [ k for k in a ] ] for x , y in zip ( * b ) ] ) ] ) <eos>
ed mon d s _ branch ing ( d i grap h , root , weight ) を返す	return edmonds_branching ( digraph , root , weight )	return <unk> ( d , u , weight ) <eos>
one s の k 番目の 1 番目 を min _ c ol だけ 減 少 させる	ones [ k ] [ 1 ] -= min_col	ones [ k ] [ 1 ] -= min_col <eos>
_ num _ node s は グローバル変数 とする	global _num_nodes	global _num_nodes <eos>
self . __ class __ ( self . x + a . x , self . y + a . y ) を返す	return self . __class__ ( self . x + a . x , self . y + a . y )	return self . <unk> ( self . x + a . y , self . y + a . y ) <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を b とする </blk>	try : <blk> b = list ( map ( int , input ( ) . split ( ) ) ) </blk>	try : <blk> b = list ( map ( int , input ( ) . split ( ) ) ) </blk> <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 集合 の 列 を g とする	g = [ set ( ) for i in range ( n ) ]	g = [ set ( ) for i in range ( n ) ] <eos>
r に d r の i 番目 を加え た 値 、 c に d c の i 番目 を加え た 値を n r 、 n c とする	nr , nc = r + dr [ i ] , c + dc [ i ]	nr , nc = r + d [ i ] , c [ nr + c ] <eos>
1 を used の k 番目 にする	used [ k ] = 1	used [ k ] = 1 <eos>
x の t 番目 が 10 と 等しい とき 、 <blk> 1 を a とする </blk>	if x [ t ] == 10 : <blk> a = 1 </blk>	if x [ t ] == 10 : <blk> a = 1 </blk> <eos>
x を展開し 、 それぞれ d 、 a 、 b とする	d , a , b = x	a , b , d = x <eos>
0 を ab とする	ab = 0	ab = 0 <eos>
1 から V 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , V ) :	for i in range ( 1 , V ) : <eos>
l が r より小さい 間 、 次 を 繰 り 返す	while l < r :	while l < r : <eos>
w を 1 だけ 減 少 させる	w -= 1	w -= 1 <eos>
self . In De gree ( m ) が 0 と 等しい とき 、	if self . InDegree ( m ) == 0 :	if self . <unk> ( 0 ) == 0 : <eos>
0 から b 未 満 までの 数 列 を 順に _ として 、 繰 り 返す	for _ in range ( b ) :	for _ in range ( b ) : <eos>
R を 順に e として 、 繰 り 返す	for e in R :	for e in R : <eos>
data の 先頭の 整数値 を num とする	num = int ( data [ 0 ] )	num = int ( data [ 0 ] ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ s 、 g 、 v とする	s , g , v = map ( int , input ( ) . split ( ) )	s , g , v = map ( int , input ( ) . split ( ) ) <eos>
l st の先頭 を r とする	r = lst [ 0 ]	r = lst [ 0 ] <eos>
S の l 番目 が " L " と 等しい とき 、	if S [ l ] == "L" :	if S [ l ] == "L" : <eos>
id を出力する	print ( id )	print ( id ) <eos>
( p 12 、 p 12 に p 1 から p 2 を 引 いた 値に 0 を 実 部 、 1 を 虚 部 と した 複素数 を 掛け た 値 を加え た 値 ) からなる 列 を l n 1 とする	ln1 = [ p12 , p12 + ( p1 - p2 ) * complex ( 0 , 1 ) ]	ln2 = [ complex ( p , 12 + 1 , 0 ) * complex ( 1 - l ) ] <eos>
x に move の i 番目の 先頭 を加え た 値 、 y に move の i 番目の 1 番目 を加え た 値を n x 、 n y とする	nx , ny = x + move [ i ] [ 0 ] , y + move [ i ] [ 1 ]	ny , ny = x + move [ i ] [ 0 ] , y [ i + 1 ] [ nx + 1 ] <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ w 、 h とする	w , h = map ( int , file_input . readline ( ) . split ( ) )	w , h = map ( int , file_input . readline ( ) . split ( ) ) <eos>
table の i から 1 を 引 いた 値 番目の j 番目 に table の i から 1 を 引 いた 値 番目の j に 1 を加え た 値 番目 を加え た 値を 10 で 割 った 余 り を table の i 番目の j 番目 にする	table [ i ] [ j ] = ( table [ i - 1 ] [ j ] + table [ i - 1 ] [ j + 1 ] ) % 10	table [ i ] [ j ] = table [ i - 1 ] [ j ] + table [ i - 1 ] [ j ] <eos>
b r id ge の 末尾に b を追加する	bridge . append ( b )	bridge . append ( b ) <eos>
A の キー の集まり の集合 を s m とする	sm = set ( A . keys ( ) )	sm = set ( A . keys ( ) ) <eos>
num が 2 6 より小さい とき 、	if num < 26 :	if num < 26 : <eos>
x の 長さ 、 y の 長さ を n 、 m とする	n , m = len ( x ) , len ( y )	n , m = len ( x ) , y <eos>
m の x 番目の y 番目 を m の x から 1 を 引 いた 値 番目の y 番目 にする	m [ x - 1 ] [ y ] = m [ x ] [ y ]	m [ x ] [ y - 1 ] = m [ x ] [ y ] <eos>
a が 16 5.0 より小さい とき 、	if a < 165.0 :	if a < <unk> : <eos>
p の i 番目 が s の p の i 番目 番目 と 等しくない とき 、	if p [ i ] != s [ p [ i ] ] :	if p [ i ] != s [ i ] : <eos>
b の q 番目 を h から h に p を加え た 値 未 満 までの 数 列 のリスト だけ 増加 させる	b [ q ] += list ( range ( h , h + p ) )	b [ q ] += list ( range ( h [ h ] + p ) ) <eos>
e 、 e を f e e の a 番目の b 番目 、 f e e の b 番目の a 番目 とする	fee [ a ] [ b ] , fee [ b ] [ a ] = e , e	a [ b ] [ e ] , fee [ b ] [ a ] = e , e <eos>
% d x % d = % d を ( i 、 j 、 a ) の 組 で 割 った 余 り を出力する	print ( "%dx%d=%d" % ( i , j , a ) )	print ( "%d %d %d" % ( i , j ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を 展開 し 、 それぞれ W 、 H 、 x 、 y 、 r とする	W , H , x , y , r = [ int ( _ ) for _ in input ( ) . split ( ) ]	W , H , x , y , r = [ int ( _ ) for _ in input ( ) . split ( ) ] <eos>
out に in p [ i ] の 整数値 に in p [ i + 1 ] の 整数値 を加え た 値の 文字列 の末尾 を加え た 値を out とする	out = out + str ( int ( inp [ i ] ) + int ( inp [ i + 1 ] ) ) [ - 1 ]	out = int ( out + int ( inp [ i ] ) + str ( inp [ 1 ] ) ) <eos>
box の i 番目の 1 番目 が box の min i 番目の 1 番目 より大きい とき 、	if box [ i ] [ 1 ] > box [ mini ] [ 1 ] :	if box [ i ] [ 1 ] > box [ mini ] [ 1 ] : <eos>
pp の 長さ 、 0 を n 、 s とする	n , s = len ( pp ) , 0	n , s = len ( pp ) , 0 <eos>
n を 2 で 割 った 値を n とする	n = n / 2	n = n / 2 <eos>
A の a 番目 が A の a に 1 を加え た 値 番目 と 等 し く かつ A の a 番目 が A の a に 2 を加え た 値 番目 と 等しい とき 、	if A [ a ] == A [ a + 1 ] and A [ a ] == A [ a + 2 ] :	if A [ a ] == A [ a + 1 ] and A [ a + 2 ] == A [ a ] : <eos>
mp の 0 に ( " X " ) からなる 列 の w に 2 を加え た 値 回 分 の 列 を 挿入 する	mp . insert ( 0 , [ "X" ] * ( w + 2 ) )	mp . insert ( "0" + [ "X" ] * ( w + 2 ) <eos>
s の末尾 が ' est ' と 等しい とき 9 0 、 そうでなければ 0 を d とする	d = 90 if s [ - 1 ] == 'est' else 0	d = [ 0 if s [ 1 ] == '9' else 0 <eos>
prime s の集合 を p set とする	pset = set ( primes )	set = set ( primes ) <eos>
16 00 を返す	return 1600	return 600 <eos>
入力された 文字列の 整数値 を h とする	h = int ( input ( ) )	h = int ( input ( ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を a とする	a = list ( map ( int , input ( ) . split ( ) ) )	a = list ( map ( int , input ( ) . split ( ) ) ) <eos>
x q を x q 2 とする	xq2 = xq	xq2 = xq <eos>
c it ies に c ity 2 を 追加した 集 まり	cities . add ( city2 )	<unk> . add ( <unk> ) <eos>
' ' を 間 に入れ て b us _ line ( a , b ) の各要素 を _ と し 、 _ の 文字列の 列 を 連結 した 文字列 を出力する	print ( ' ' . join ( [ str ( _ ) for _ in bus_line ( a , b ) ] ) )	print ( ' ' . join ( [ str ( _ ) for _ in a ] ) ) <eos>
a の largest 番目 、 a の i 番目 を a の i 番目 、 a の largest 番目 とする	a [ i ] , a [ largest ] = a [ largest ] , a [ i ]	a [ i ] , a [ largest ] = a [ largest ] , a [ i ] <eos>
V ec t or ( self . x * k , self . y * k ) を返す	return Vector ( self . x * k , self . y * k )	return Vector ( self * x , self . y * self . y ) <eos>
1 を 辞書の j 番目 にする	dict [ j ] = 1	dict [ j ] = 1 <eos>
を 間 に入れ て tmp _ row の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する	print ( " " . join ( map ( str , tmp_row ) ) )	print ( " " . join ( map ( str , tmp_row ) ) ) <eos>
c の 末尾に 入力された 文字列 を追加する	c . append ( input ( ) )	c . append ( input ( ) ) <eos>
入力された 文字列の 整数値 、 0 を n 、 a とする	n , a = int ( input ( ) ) , 0	n , a = int ( input ( ) ) , 0 <eos>
t を 3 倍 にする	t *= 3	t *= 3 <eos>
0 を diff とする	diff = 0	diff = 0 <eos>
d ic の キーと値 の集まり のリスト を s とする	s = list ( dic . items ( ) )	s = list ( dic . items ( ) ) <eos>
0 から e に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( e + 1 ) :	for i in range ( e + 1 ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ y 1 、 m 1 、 d 1 、 y 2 、 m 2 、 d 2 とする	y1 , m1 , d1 , y2 , m2 , d2 = map ( int , input ( ) . split ( ) )	y1 , m1 , d1 , d2 , m2 , d2 = map ( int , input ( ) . split ( ) ) <eos>
self . d ice _ move ( move )	self . dice_move ( move )	self . dice_move ( ) <eos>
3 を出力する	print ( 3 )	print ( 3 ) <eos>
2 9 を mm の 2 番目 にする	mm [ 2 ] = 29	mm [ 2 ] = 29 <eos>
x y の i 番目 が -1 と 等しい とき 、	if xy [ i ] == - 1 :	if xy [ i ] == - 1 : <eos>
co in を 順に i として 、 繰 り 返す	for i in coin :	for i in coin : <eos>
a の i 番目 が b 以下の とき 、	if a [ i ] <= b :	if a [ i ] <= b : <eos>
ab の先頭に ab の 1 番目 を 掛け た 値 、 ab の先頭に 2 を 掛け た 値に ab の 1 番目 に 2 を 掛け た 値 を加え た 値 を出力する	print ( ab [ 0 ] * ab [ 1 ] , ab [ 0 ] * 2 + ab [ 1 ] * 2 )	print ( ab [ 0 ] * ab [ 1 ] * 2 + ab [ 1 ] * ab [ 2 ] * ab [ 1 ] ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ w 、 p とする	w , p = input ( ) . split ( )	p , w = input ( ) . split ( ) <eos>
文字列 s を評価し た 値 を出力する	print ( eval ( s ) )	print ( eval ( s ) ) <eos>
0 を max _ f re とする	max_fre = 0	<unk> = 0 <eos>
0 を a を _ y とすると する を _ x とする	_x = _y = a = 0	<unk> = y = 0 <eos>
ch u - k ic hi を返す	return "chu-kichi"	return <unk> <eos>
0 を top とする	top = 0	top = 0 <eos>
d x に c 6 0 を 掛け た 値 から d y に s 6 0 を 掛け た 値を 引 いた 値に s x を加え た 値を u x とする	ux = dx * c60 - dy * s60 + sx	x = dx * <unk> + dy * <unk> + 0 <eos>
x が y と 等しい とき 、 <blk> 0 を返す </blk>	if x == y : <blk> return 0 </blk>	if x == y : <blk> return 0 </blk> <eos>
s が 正規表現 ' [0-9] + ' に マッチした 文字列の 列 を 順に i として 、 繰 り 返す <blk> p を i の 整数値 だけ 増加 させる </blk>	for i in re . findall ( '[0-9]+' , s ) : <blk> p += int ( i ) </blk>	for i in re . findall ( '[0-9]+' , s ) : <blk> p += int ( i ) </blk> <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を f ab の i に 2 を加え た 値 番目の 2 番目 から 12 番目 までの 部分 列 にする	fab [ i + 2 ] [ 2 : 12 ] = list ( map ( int , input ( ) . split ( ) ) )	ab [ i : 2 + 1 ] [ 2 ] = list ( map ( int , input ( ) . split ( ) ) ) <eos>
left _ node _ no が -1 と 等 し く かつ right _ node _ no が -1 と 等しい とき 、	if left_node_no == - 1 and right_node_no == - 1 :	if left_node_no == - 1 and right_node_no == - 1 : <eos>
( 0 ) からなる 列 の 1 を N だけ 左 シフト した 値 回 分 の 列 を b c とする	bc = [ 0 ] * ( 1 << N )	bc = [ 0 ] * ( 1 << N ) <eos>
tuple s を 順に t として 、 繰 り 返す	for t in tuples :	for t in tuples : <eos>
e w を 1 だけ 減 少 させる	ew -= 1	ew -= 1 <eos>
4 を返す	return 4	return 4 <eos>
Y の y に w を加え た 値 番目 を 1 だけ 減 少 させる	Y [ y + w ] -= 1	Y [ y + w ] -= 1 <eos>
d ish _ re main _ d の ot 番目 を 削 除 する	del dish_remain_d [ ot ]	del dish_remain [ ot ] <eos>
0 から a の 長さ を 5 で 割 った 商 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> b を en の 2 進表記 a の i に 5 を 掛け た 値 から i に 5 を 掛け た 値に 5 を加え た 値 までの 部分 列 の 整数値 番目 だけ 増加 させる </blk>	for i in range ( len ( a ) // 5 ) : <blk> b += en [ int ( a [ i * 5 : i * 5 + 5 ] , 2 ) ] </blk>	for i in range ( len ( a ) // 5 ) : <blk> b += int ( a [ i : i * 5 + 5 ] ) * i </blk> <eos>
w を出力する	print ( w )	print ( w ) <eos>
入力された 文字列の 整数値 を number とする	number = int ( input ( ) )	number = int ( input ( ) ) <eos>
S os u ( i ) の とき 、	if Sosu ( i ) :	if Sosu ( i ) : <eos>
e le v _ to _ h t の dest 番目 に i を 追加した 集 まり	elev_to_ht [ dest ] . add ( i )	elev_to_ht [ i ] . add ( dest ) <eos>
leap _ years を 順に year として 、 繰 り 返す	for year in leap_years :	for year in <unk> : <eos>
A の b 番目 から c 番目 までの 部分 列 に A の a 番目 から b 番目 までの 部分 列 を加え た 値を A の a 番目 から c 番目 までの 部分 列 にする	A [ a : c ] = A [ b : c ] + A [ a : b ]	A [ a ] = A [ b : c ] + A [ a : b ] <eos>
( 11 、 14 ) の 組	( 11 , 14 )	( 11 , 14 ) <eos>
0 が j に item の 1 番目 を加え た 値 以下 かどうか が w 以下の とき 、	if 0 <= j + item [ 1 ] <= w :	if 0 <= j + item [ 1 ] <= w : <eos>
s の a の i 番目 から 1 を 引 いた 値 番目 を x だけ 増加 させる	s [ a [ i ] - 1 ] += x	s [ a [ i ] - 1 ] += x <eos>
un it e ( a , b ) の とき 、	if unite ( a , b ) :	if unite ( a , b ) : <eos>
m から l を 引 いた 値を n 1 とする	n1 = m - l	n1 = m - l <eos>
x が 2 と 等しい とき 、	if x == 2 :	if x == 2 : <eos>
key 、 val を出力する	print ( key , val )	print ( key , val ) <eos>
check Q ue en ( que en , initial ) の とき 、	if checkQueen ( queen , initial ) :	if <unk> ( queen , initial ) : <eos>
Q の先頭 を i とする	i = Q [ 0 ]	i = Q [ 0 ] <eos>
a の b を w で 割 った 商 番目 を 1 だけ 増加 させる	a [ b // w ] += 1	a [ b // w ] += 1 <eos>
f _ str の -1 番目 が " 0 " と 等しい とき 、	if f_str [ - 1 ] == "0" :	if f_str [ - 1 ] == "0" : <eos>
無限 の 整数 列 が 7 以下の とき 、 <blk> l 1 の 末尾に ( t 、 p ) からなる 列 を追加する </blk>	if count <= 7 : <blk> l1 . append ( [ t , p ] ) </blk>	if count <= 7 : <blk> p . append ( [ 1 , t ] ) </blk> <eos>
n _ i が 0 と 等しい とき 、	if n_i == 0 :	if n_i == 0 : <eos>
A から B に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( A , B + 1 ) :	for i in range ( A , B + 1 ) : <eos>
l が "+" と 等しい とき 、	if l == "+" :	if l == "+" : <eos>
weight の b 番目 から weight の a 番目 を 引 いた 値を返す	return weight [ b ] - weight [ a ]	return weight [ b ] - a [ weight ] <eos>
2 から n に 2 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> i を出力する </blk>	for i in range ( 2 , n + 2 ) : <blk> print ( i ) </blk>	for i in range ( 2 , n + 2 ) : <blk> print ( i ) </blk> <eos>
box を展開し て を出力する	print ( * box )	print ( * box ) <eos>
a の b から 1 を 引 いた 値 番目 と a の c から 1 を 引 いた 値 番目 を 入れ替え る	a [ b - 1 ] , a [ c - 1 ] = a [ c - 1 ] , a [ b - 1 ]	a [ b - 1 ] , a [ c - 1 ] = a [ b - 1 ] , a [ c - 1 ] <eos>
{ 0 : . 8 f } { 1 : . 8 f } を 書式 として self の x 座 標 、 self の y 座 標 で 整 形 した 文字列 を返す	return "{0:.8f} {1:.8f}" . format ( self . x , self . y )	return "{0:.8f} . format ( self . x , self . y ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 d とする	n , d = map ( int , input ( ) . split ( ) )	n , d = map ( int , input ( ) . split ( ) ) <eos>
a から b に 1 を加え た 値 未 満 までの 数 列 を 順に y として 、 繰 り 返す	for y in range ( a , b + 1 ) :	for y in range ( a , b + 1 ) : <eos>
right _ child が -1 と 等しくない とき 、	if right_child != - 1 :	if right_child != - 1 : <eos>
bisect モジュール を用い る	from bisect import insort	from bisect import bisect <eos>
t の とき 、	if t :	if t : <eos>
heapq . heappush ( queue , [ D [ j ] , j ] )	heapq . heappush ( queue , [ D [ j ] , j ] )	heapq . heappush ( queue , [ j ] [ j ] , D [ j ] ) <eos>
an s の 末尾に '0' を追加する	ans . append ( '0' )	ans . append ( '0' ) <eos>
s を d に i の 2 乗 を 掛け た 値 だけ 増加 させる	s += d * i ** 2	s += d * i <eos>
p の 1 番目 を 1 だけ 減 少 させる	p [ 1 ] -= 1	p [ 1 ] -= 1 <eos>
f ( an s + 1 , n -1 ) 、 f ( an s + 11 , n -1 ) の 最大 値を返す	return max ( f ( ans + 1 , n - 1 ) , f ( ans + 11 , n - 1 ) )	return max ( f ( ans + 1 , n - 1 ) , max ( ans , - 1 ) ) <eos>
0 から n 未 満 までの 数 列 の各要素 を __ と し 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 浮動小数点数の 列 の 列 を rate s とする	rates = [ [ float ( _ ) for _ in input ( ) . split ( ) ] for __ in range ( n ) ]	<unk> = [ [ float ( _ ) for _ in input ( ) . split ( ) ] for __ in range ( n ) ] <eos>
ソートされた 順序 を 保 った まま arg の 1 番目の 整数値 を arr に 挿入 できる 最後の 位置 を r _ id x とする	r_idx = bisect . bisect_right ( arr , int ( arg [ 1 ] ) )	r_idx = bisect . bisect_right ( arr , int ( arg [ 1 ] ) ) <eos>
p q の 末尾に ( 0 、 i 、 j 、 0 ) からなる 列 を追加する	pq . append ( [ 0 , i , j , 0 ] )	pq . append ( [ 0 , i , j , 0 ] ) <eos>
index から 1 を 引 いた 値を index とする	index = index - 1	index = index - 1 <eos>
h で ないとき 、	if not h :	if not h : <eos>
N が 1 65 より小さい とき 、 <blk> d ic の 1 番目 を 1 だけ 増加 させる </blk>	if N < 165 : <blk> dic [ 1 ] += 1 </blk>	if N < 165 : <blk> dic [ 1 ] += 1 </blk> <eos>
x を d x だけ 増加 させる y を d y だけ 増加 させる	x += dx y += dy	x += dx y += dy <eos>
an s の 末尾に so l ve ( N , M ) を追加する	ans . append ( solve ( N , M ) )	ans . append ( solve ( N , M ) ) <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 0 の 列 を P とする	P = [ 0 for _ in range ( n ) ]	P = [ 0 for _ in range ( n ) ] <eos>
D is join t Set s ( n ) を S とする	S = DisjointSets ( n )	S = DisjointSets ( n ) <eos>
g a p から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( gap , n ) :	for i in range ( g , n ) : <eos>
18 に 60 を 掛け た 値を B とする	B = 18 * 60	B = 18 * 60 <eos>
( 0 ) からなる 列 を sum _ list とする	sum_list = [ 0 ]	sum_list = [ 0 ] <eos>
0 が n x 以下 かどうか が W より 小さく なく または 0 が n y 以下 かどうか が H より 小さく ないとき 、	if not 0 <= nx < W or not 0 <= ny < H :	if not 0 <= nx < W or not 0 <= ny < H : <eos>
node 1 が self . Get Node s ( ) に 含まれない とき 、	if node1 not in self . GetNodes ( ) :	if node1 not ( self . GetNodes ( ) ) not in self . GetNodes ( ) : <eos>
io _ re c の 3 番目 を io _ head c n t とする	io_headcnt = io_rec [ 3 ]	zero_cnt = io_rec [ 3 ] <eos>
p r に e に base を 掛け た 値 を加え た 値を c _ p 2 とする	c_p2 = pr + e * base	e2_cp = pr + e * base <eos>
l の逆 順 を s とする	s = l [ : : - 1 ]	s = l [ : - 1 ] <eos>
b を i と 1 の 論理 積 の とき i 、 そうでなければ - i だけ 減 少 させる	b -= i if i & 1 else - i	b -= 1 - ( i if i & 1 else - i ) <eos>
level の u 番目 に 1 を加え た 値を next _ level とする	next_level = level [ u ] + 1	level = level [ u ] + 1 <eos>
S を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を N とする	N = [ int ( i ) for i in S . split ( ) ]	N = [ int ( i ) for i in S . split ( ) ] <eos>
a の j 番目 を b とする	b = a [ j ]	b = a [ j ] <eos>
4 が s c に含まれる とき 、 <blk> ' B ' を返す </blk>	if 4 in sc : <blk> return 'B' </blk>	if 4 in s : <blk> return 'B' </blk> <eos>
' root ' を T の rt _ n 番目の type にする	T [ rt_n ] . type = 'root'	'T' [ n_close ] . type = <unk> <eos>
( {} ) を返す	return ( { "," . join ( map ( str , self . f_keys ) ) } )	return ( { self . val } ) <eos>
1 00000 を p とする	p = 100000	p = 100000 <eos>
36 0 . を the t a とする	theta = 360 .	theta = 360 . sin ( theta ) <eos>
p a int ( f _ in p , x -3 , y ) を f _ in p とする	f_inp = paint ( f_inp , x - 3 , y )	f_inp = paint ( f_inp , x , y - 3 ) <eos>
heappush ( h q , ( temp _ cos t , v ) )	heappush ( hq , ( temp_cost , v ) )	heappush ( hq , ( temp_cost , v_cost ) ) <eos>
p o ly 1 の 末尾に p o ly 1 の先頭 を追加する	poly1 . append ( poly1 [ 0 ] )	poly1 . append ( poly1 [ 0 ] ) <eos>
B T . in order _ walk ( )	BT . inorder_walk ( )	BT . <unk> ( ) <eos>
T の root を x とする	x = T . root	x = T . root <eos>
u が v と 等しい とき 、	if u == v :	if u == v : <eos>
_ f ( p x , py , q x , q y , r x , ry ) を f 1 とする	f1 = _f ( px , py , qx , qy , rx , ry )	f = _f ( px , py , qx , qy , ry , rx ) <eos>
31 に 2 9 を加え た 値に 31 を加え た 値に 30 を加え た 値に D を加え た 値を days とする	days = 31 + 29 + 31 + 30 + D	days = 31 + 29 + 31 + 31 + D <eos>
left end ( p o ly 0 ) を left 0 とする	left0 = leftend ( poly0 )	left0 = <unk> ( poly0 ) <eos>
x 2 が 0 より 小さく または x 2 が 4 以上 または y 2 が 0 より 小さく または y 2 が 4 以上 または arr の y 2 番目の x 2 番目の とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if x2 < 0 or x2 >= 4 or y2 < 0 or y2 >= 4 or arr [ y2 ] [ x2 ] : <blk> continue </blk>	if x2 < 0 or y2 < 4 or y2 >= 0 or arr [ y < 4 ] [ x2 : <blk> continue </blk> <eos>
S から 10 を 引 いた 値を返す	return S - 10	return S - 10 <eos>
0 を v 1 とする	v1 = 0	v1 = 0 <eos>
( 0 ) からなる 列 、 ( 0 ) からなる 列 、 ( 0 ) からなる 列 を a 、 s 、 t とする	a , s , t = [ 0 ] , [ 0 ] , [ 0 ]	a = [ 0 , [ 0 ] , [ 0 , 0 ] , [ s ] ] <eos>
空 列 を D 1 とする 空 列 を z 1 とする	D1 = [ ] z1 = [ ]	z1 = [ ] z1 = [ ] <eos>
n _ i を un s al v age d の height 番目 にする	unsalvaged [ height ] = n_i	unsalvaged [ height ] = n_i <eos>
0 から 10 未 満 までの 数 列 の各要素 を row と し 、 0 から 10 未 満 までの 数 列 の各要素 を c ol と し 、 0 の 列 の 列 を p a per とする	paper = [ [ 0 for col in range ( 10 ) ] for row in range ( 10 ) ]	paper = [ [ 0 for row in range ( 10 ) ] for row in range ( 10 ) ] <eos>
sys の stdin から 読み込んだ データを 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を board とする	board = list ( map ( int , sys . stdin . read ( ) . split ( ) ) )	board = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) <eos>
入力された 文字列 内の ' apple ' を '#' で 置き換え た 文字列 内の ' p e ach ' を ' apple ' で 置き換え た 文字列 内の '#' を ' p e ach ' で 置き換え た 文字列 を出力する	print ( input ( ) . replace ( 'apple' , '#' ) . replace ( 'peach' , 'apple' ) . replace ( '#' , 'peach' ) )	print ( input ( ) . replace ( 'apple' , ' ' . replace ( '#' , 'peach' ) . replace ( '@' ) ) <eos>
0 から n 未 満 までの 数 列 を 反 転 した 列 を 順に j として 、 繰 り 返す	for j in reversed ( range ( n ) ) :	for j in range ( n ) : <eos>
b [ a ] の d 番目 が 40 以下 かつ 17 * 60 + 30 <= t が 19 * 60 + 30 以下 または 17 * 60 + 30 <= _ t が 19 * 60 + 30 以下の とき b [ d ] [ a ] を 2 で 割 った 商 に b [ d ] [ a ] を 2 で 割 った	print ( ( b [ d ] [ a ] // 2 + b [ d ] [ a ] % 2 ) * 50 if b [ a ] [ d ] <= 40 and ( ( 17 * 60 + 30 <= t <= 19 * 60 + 30 ) or ( 17 * 60 + 30 <= _t <= 19 * 60 + 30 ) ) else b [ d ] [ a ] * 50 )	if b [ a ] <= d and ( a [ 30 ] * 60 + b [ 5 ] * 60 + d <= 60 ) or a [ 2 ] <= t <= d or a [ b + d or a [ 30 ] <= d //
x _ pre から x _ pre の 3 乗 から q を 引 いた 値を 3 に x _ pre の 2 乗 を 掛け た 値で 割 った 値を 引 いた 値を x とする	x = x_pre - ( x_pre ** 3 - q ) / ( 3 * x_pre ** 2 )	x = ( _x - x3 ) / ( xq - 2 * xq ** 2 ) <eos>
s _ d 、 x の 最小 値を s _ d とする	s_d = min ( s_d , x )	s_d = min ( <unk> , x ) <eos>
w が 0 と 等 し く かつ h が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if w == 0 and h == 0 : <blk> break </blk>	if w == 0 and h == 0 : <blk> break </blk> <eos>
B _ c ir c les を 順に b c として 、 繰 り 返す	for bc in B_circles :	for b in <unk> : <eos>
p t 2 を p t 1 とする	pt1 = pt2	pt1 = pt2 <eos>
r - l が 6 以上 かつ S [ l ] が " L R ? " に 含 まれ かつ S の l に 1 を加え た 値 番目 かつ S の l に 1 を加え た 値 番目 が " ( ? " に 含 まれ かつ S の r から 1 を 引 いた 値 番目 が ") ? " に含まれる とき 、	if r - l >= 6 and S [ l ] in "LR?" and S [ l + 1 ] and S [ l + 1 ] in "(?" and S [ r - 1 ] in ")?" :	if r >= 6 and S [ l ] in S and S [ l + 1 ] and S [ l + r - 1 ] in S [ l + 1 ] : <eos>
0 から b 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( b ) :	for i in range ( b ) : <eos>
( 0 ) からなる 列 の 6 回 分 の 列 を T all _ list とする	Tall_list = [ 0 ] * 6	Tall_list = [ 0 ] * 6 <eos>
d p の bits 番目の i 番目 が 、 つまり 無限大 と 等しい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if dp [ bits ] [ i ] == inf : <blk> continue </blk>	if dp [ bits ] [ i ] == inf : <blk> continue </blk> <eos>
m id から h _ i _ s n を 引 いた 値を s _ r とする	s_r = mid - h_i_sn	s_r = mid - h_i_sn <eos>
1 から m に 1 を加え た 値 未 満 までの 数 列 のリスト 、 0 、 0 を a 、 i 、 c とする	a , i , c = list ( range ( 1 , m + 1 ) ) , 0 , 0	a , c , a = list ( range ( 1 , m + 1 ) ) , 0 <eos>
' root ' を T の T の末尾 番目の type にする	T [ T [ - 1 ] ] . type = 'root'	T [ - 1 ] [ cap ] = <unk> <eos>
r の right を min _ node とする	min_node = r . right	min_node = r . right <eos>
N A を出力する	print ( "NA" )	print ( "NA" ) <eos>
0 から M 未 満 までの 数 列 を 順に b として 、 繰 り 返す	for b in range ( M ) :	for b in range ( M ) : <eos>
{} を返す	return { self . state }	return { self . pt2 } <eos>
' l ' を f とする	f = 'l'	f = <unk> <eos>
rename の 末尾に ( year 、 name ) からなる 列 を追加する	rename . append ( [ year , name ] )	rename . append ( [ year , name ] ) <eos>
S の S の i 番目 番目 を T の i 番目 にする	T [ i ] = S [ S [ i ] ]	T [ T [ i ] ] = S [ i ] <eos>
d の c y 番目の c x 番目の cd 番目 が c cos t より小さい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if d [ cy ] [ cx ] [ cd ] < ccost : <blk> continue </blk>	if d [ cy ] [ cx ] < cd : <blk> continue </blk> <eos>
b 0 が c 2 に含まれる とき 、	if b0 in c2 :	if b0 in c2 : <eos>
a の 0 番目 が '0' と 等しい とき 、 <blk> a の 2 番目の 整数値 を 辞書の k i 番目 にする </blk>	if a [ 0 ] == '0' : <blk> dict [ ki ] = int ( a [ 2 ] ) </blk>	if a [ 0 ] == '0' : <blk> dict [ ki ] [ ki ] = int ( a [ i ] ) </blk> <eos>
s の 長さが t の 長さ より小さい とき 、 <blk> s と t を 入れ替え る </blk>	if len ( s ) < len ( t ) : <blk> s , t = t , s </blk>	if len ( s ) < len ( t ) : <blk> s , t = s , t </blk> <eos>
入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を ソート した 列 を 展開 し 、 それぞれ a 、 b 、 c とする	a , b , c = sorted ( map ( int , input ( ) . strip ( ) . split ( ) ) )	a , b , c = sorted ( map ( int , input ( ) . strip ( ) . split ( ) ) <eos>
points の 1 番目 を p 1 とする	p1 = points [ 1 ]	p1 = points [ 1 ] <eos>
total は グローバル変数 とする	global total	global total <eos>
a 1 に b 1 を 掛け た 値 から a 2 に b 2 を 掛け た 値を 引 いた 値 から a 3 に b 3 を 掛け た 値を 引 いた 値 から a 4 に b 4 を 掛け た 値を 引 いた 値を p 1 とする	p1 = a1 * b1 - a2 * b2 - a3 * b3 - a4 * b4	p4 = a1 * b1 - b2 * a1 <eos>
total L en に v 1 を 掛け た 値を v 1 に v 2 を加え た 値で 割 った 値を m id Point とする	midPoint = totalLen * v1 / ( v1 + v2 )	<unk> = ( total * v1 + v2 ) / ( <unk> + <unk> ) <eos>
node を self の tail の next にする	self . tail . next = node	self . tail . next = node <eos>
d f s ( i + 1 , s )	dfs ( i + 1 , s )	dfs ( i + 1 , s ) <eos>
E Q ( tb l [ i ] . real , 0 ) の とき 、	if EQ ( tbl [ i ] . real , 0 ) :	if EQ ( tbl [ i ] . real , 0 ) : <eos>
( pi 、 1 ) の 組 を cd に ソート 順 で 最後に 挿入 する	insort ( cd , ( pi , 1 ) )	insort ( cd , ( pi , ( pi , - 1 ) ) ) <eos>
lines の i 番目 を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ q 、 arg とする	q , arg = lines [ i ] . split ( )	arg , q = lines [ i ] . split ( ) <eos>
s を d に f ( d d ) を 掛け た 値 だけ 増加 させる	s += d * f ( dd )	s += d * d <eos>
k の n の i 番目 番目 を 1 だけ 増加 させる	k [ n [ i ] ] += 1	k [ n [ i ] ] += 1 <eos>
update ( a _ i , get _ sum ( a _ i -1 ) + a _ i )	update ( a_i , get_sum ( a_i - 1 ) + a_i )	update ( <unk> ( a_i , a_i + 1 ) ) <eos>
'' を 間 に入れ て string の各要素 を char と し 、 C O DE 2 _ rev の char 番目の 列 を 連結 した 文字列を bit string とする	bitstring = '' . join ( [ CODE2_rev [ char ] for char in string ] )	string = '' . join ( [ <unk> [ char ] for char in string ] ) <eos>
1 を n z の t の先頭 番目 にする	nz [ t [ 0 ] ] = 1	nz [ 0 ] = 1 <eos>
a に b を 掛け た 値を 3.3 05 7 85 で 割 った 値 を出力する	print ( a * b / 3.305785 )	print ( a * b / 3.305785 ) <eos>
s の 、 つまり 先頭から op の 1 番目の 整数値 までの 部分 列 に op の 3 番目 を加え た 値に s の op の 2 番目の 整数値 に 1 を加え た 値 から 、 つまり 末 尾 までの 部分 列 を加え た 値を s とする	s = s [ : int ( op [ 1 ] ) ] + op [ 3 ] + s [ int ( op [ 2 ] ) + 1 : ]	s = s [ : op [ 1 ] + int ( op [ 2 ] ) + s [ op [ 2 : ] ] <eos>
score を line の i 番目 に line の i に 1 を加え た 値 番目 を加え た 値に line の i に 2 を加え た 値 番目 を加え た 値 だけ 増加 させる	score += line [ i ] + line [ i + 1 ] + line [ i + 2 ]	score += line [ i + 1 ] + line [ i + 2 ] <eos>
a に 1 を加え た 値 から N 未 満 までの 数 列 を 順に b として 、 繰 り 返す	for b in range ( a + 1 , N ) :	for b in range ( a + 1 , N ) : <eos>
f l _ h t  内の dest と 等しい 要素を 取り除く	fl_ht . remove ( dest )	fl_ht . remove ( dest ) <eos>
me m o _ 2 の 末尾に an s を追加する	memo_2 . append ( ans )	memo . append ( 2 ) <eos>
s に 1 を加え た 値を t とする	t = s + 1	t = s + 1 <eos>
a の b 乗 に対する 10 000000 07 の 剰余 を出力する	print ( pow ( a , b , 1000000007 ) )	print ( pow ( a , b , 1000000007 ) ) <eos>
0 から i の 1 番目 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( i [ 1 ] ) :	for j in range ( i [ 1 ] ) : <eos>
b を 3 だけ 増加 させる	b += 3	b += 3 <eos>
test の i 番目 が " the " と 等 し く または test の i 番目 が " th at " と 等 し く または test の i 番目 が " this " と 等しい とき 、	if test [ i ] == "the" or test [ i ] == "that" or test [ i ] == "this" :	if test [ i ] == <unk> or 'the' == '1' or tmp [ i ] == <unk> : <eos>
time を quant um だけ 増加 させる	time += quantum	time += quantum <eos>
0 から 3 未 満 までの 数 列 を 順に r s として 、 繰 り 返す	for rs in range ( 3 ) :	for sr in range ( 3 ) : <eos>
を 間 に入れ て a を ソート した 列 を 連結 した 文字列 を出力する	print ( " " . join ( sorted ( a ) ) )	print ( " " . join ( sorted ( a ) ) ) <eos>
power の 末尾に 1 を追加する	power . append ( 1 )	power . append ( 1 ) <eos>
D P の i に c を加え た 値 番目 、 D P の i 番目 に 1 を加え た 値の 最小 値を D P の i に c を加え た 値 番目 にする	DP [ i + c ] = min ( DP [ i + c ] , DP [ i ] + 1 )	DP [ i + 1 ] = min ( DP [ i + 1 ] , DP [ i + 1 ] + c [ i ] ) <eos>
a が b と 等しくない とき 、	if a != b :	if a != b : <eos>
a を追加して A を拡張する	A . extend ( a )	a . extend ( a ) <eos>
n を id x とする	idx = n	idx = n <eos>
' a ' が char 以下 かどうか が ' z ' 以下の とき 、	if 'a' <= char <= 'z' :	if 'a' <= char <= 'z' : <eos>
partition ( a , 0 , n -1 ) を index とする	index = partition ( a , 0 , n - 1 )	index = partition ( a , 0 , n - 1 ) <eos>
d p の先頭 の末尾 を出力する	print ( dp [ 0 ] [ - 1 ] )	print ( dp [ - 1 ] [ 0 ] ) <eos>
card が ' M ' と 等しい とき 、	if card == 'M' :	if card == 'M' : <eos>
c A の i 番目 を 削 除 する	del cA [ i ]	del cA [ i ] <eos>
d の r 番目の c 番目 が '0' 以上 かつ d の r 番目の c 番目 が ' 9 ' 以下の とき 、	if d [ r ] [ c ] >= '0' and d [ r ] [ c ] <= '9' :	if d [ r ] >= '0' and c <= d and d [ r ] [ c ] <= <unk> : <eos>
3 から x の平方根 の 切り 上 げ 整数値 に 1 を加え た 値 未 満 までの 2 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 3 , math . ceil ( math . sqrt ( x ) ) + 1 , 2 ) :	for i in itertools . ceil ( math . sqrt ( math . sqrt ( range ( 3 , x ) + 1 , int ( i ) ) ) : <eos>
v から MAX に 1 を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( v , MAX + 1 ) :	for j in range ( v , MAX + 1 ) : <eos>
1 から n 未 満 までの 数 列 の各要素 を x と し 、 x の 列 を un re ach ed _ verti ce s とする	unreached_vertices = [ x for x in range ( 1 , n ) ]	unreached_vertices = [ string_to_complex ( x ) for x in range ( 1 , n ) ] <eos>
0 から N 未 満 までの 数 列 の各要素 を i と し 、 readline ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト の 列 を P とする	P = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( N ) ]	P = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( N ) ] <eos>
i から j を 引 いた 値を c とする s を c だけ 増加 させる	c = i - j s += c	s += j - c <eos>
event を展開し 、 それぞれ tm 、 typ 、 en 、 h t とする	tm , typ , en , ht = event	tm , typ , ht = event <eos>
p に 10 を 掛け た 値 と q を 割 ったとき の ( 商 を 展開 し 、 それぞれ d 、 p とする	d , p = divmod ( p * 10 , q )	d , p = divmod ( p * 10 , q ) <eos>
1 を an s とする s の先頭 を pre とする	ans = 1 pre = s [ 0 ]	pre = 1 ans = ans [ 0 ] <eos>
c arr i able _ ba g g age ( b a g g age , b a g g age _ num , m id , t ru c k _ num ) を v とする	v = carriable_baggage ( baggage , baggage_num , mid , truck_num )	<unk> = <unk> ( g , a , b , <unk> , <unk> ) <eos>
i が 3 に r を 掛け た 値に j を加え た 値 と 等しくない とき 、	if i != 3 * r + j :	if i != 3 * j + r : <eos>
time を 2 に t 1 を 掛け た 値 だけ 増加 させる	time += 2 * t1	time += 2 * t <eos>
1 から n に 1 を加え た 値 未 満 までの 数 列 を 1 を 初期値 として mul で 集 約 した 列 を出力する	print ( reduce ( mul , range ( 1 , n + 1 ) , 1 ) )	print ( <unk> , math . reduce ( <unk> , n + 1 ) ) <eos>
0 から L IM 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 真 の 列 を is _ prime とする	is_prime = [ True for _ in range ( LIM ) ]	is_prime = [ True for _ in range ( LIM ) ] <eos>
x  の m と 等しい 要素の 最初の 位置 を i とする	i = x . index ( m )	i = x . index ( m ) <eos>
an s を 2 に c を 掛け た 値 だけ 増加 させる	ans += 2 * c	ans += 2 * c <eos>
a c _ 1 j から a c _ 1 i を 引 いた 値を c ol _ max とする	col_max = ac_1j - ac_1i	col_max = <unk> - 1 <eos>
p を n で 割 った 余 り が 0 と 等しい とき 、	if p % n == 0 :	if p % n == 0 : <eos>
空 列 を cp _ l とする	cp_l = [ ]	cp_l = [ ] <eos>
que の 末尾に proc を追加する	que . append ( proc )	que . append ( proc ) <eos>
未 定 値を an s の T 番目 にする	ans [ T ] = None	ans [ T ] = None <eos>
partition ( A , 0 , n -1 ) を P とする	P = partition ( A , 0 , n - 1 )	P = partition ( A , 0 , n - 1 ) <eos>
self . Add E d ge ( ( row , c ol ) , ( row 2 , c ol 2 ) )	self . AddEdge ( ( row , col ) , ( row2 , col2 ) )	self . AddEdge ( col , row2 ) <eos>
( n ) からなる 列 の 2 回 分 の 列 を m とする	m = [ n ] * 2	m = [ n ] * 2 <eos>
mi が i 以下の 間 、 次 を 繰 り 返す	while mi <= i :	while mi <= i : <eos>
c に e を 掛け た 値 から b に f を 掛け た 値を 引 いた 値を a に e を 掛け た 値 から b に d を 掛け た 値を 引 いた 値で 割 った 値を x とする	x = ( c * e - b * f ) / ( a * e - b * d )	x = ( c * e - b * f ) / ( d - b * d ) <eos>
op の 1 番目の 整数値 を s とする	s = int ( op [ 1 ] )	s = int ( op [ 1 ] ) <eos>
p 1 の 0 番目 から p 0 の先頭 を 引 いた 値を x 0 とする p 1 の 1 番目 から p 0 の 1 番目 を 引 いた 値を y 0 とする	x0 = p1 [ 0 ] - p0 [ 0 ] y0 = p1 [ 1 ] - p0 [ 1 ]	x0 = p1 [ 0 ] - p0 [ 0 ] y1 = p1 [ 0 ] - p0 [ 1 ] <eos>
x 、 y から 2 を 引 いた 値 、 depth に 1 を加え た 値 、 max _ depth において 正規表現 table が 最初 にマッチする 位置 の とき 、	if search ( table , x , y - 2 , depth + 1 , max_depth ) :	if search ( table , x - 2 , y , depth + 1 , max_depth ) : <eos>
c が card の 長さ から h を 引 いた 値 より小さい とき 、	if c < len ( card ) - h :	if c < len ( card ) - h : <eos>
a の b を 5 で 割 った 商 から 32 を 引 いた 値 番目 を 1 だけ 増加 させる	a [ b // 5 - 32 ] += 1	a [ b // 5 - 1 ] += 1 <eos>
( 、 つまり 空 列 ) からなる 列 を g とする	g = [ [ ] ]	g = [ [ ] ] <eos>
j から n 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( j , n ) :	for k in range ( j , n ) : <eos>
0 を max _ price とする	max_price = 0	max_price = 0 <eos>
b の i 番目 が a の m id 番目 と 等しい とき 、	if b [ i ] == a [ mid ] :	if b [ i ] == a [ mid ] : <eos>
d p の pre _ bit 番目 を d p _ pre とする	dp_pre = dp [ pre_bit ]	pre_dp = dp [ pre_d ] <eos>
f の とき 、	if f :	if f : <eos>
A x に B x から A x を 引 いた 値に math . pi を 3 で 割 った 値の 余 弦 を 掛け た 値 を加え た 値 から By から A y を 引 いた 値に 円 周 率 を 3 で 割 った 値の 正 弦 を 掛け た 値を 引 いた 値を C x とする	Cx = Ax + ( Bx - Ax ) * math . cos ( math . pi / 3 ) - ( By - Ay ) * math . sin ( math . pi / 3 )	A = math . sin ( B + x - 3 ) * math . sin ( C ) / math . pi * math . pi - ( C ) <eos>
[ MASK ] の リストを prime s とする	primes = list ( )	primes = list ( ) <eos>
x 1 から x 0 を 引 いた 値の 絶対値 が 1 より大きい とき 、	if abs ( x1 - x0 ) > 1 :	if abs ( x1 - x0 ) > 1 : <eos>
x のコピー を y とする	y = x . copy ( )	y = x . copy ( ) <eos>
i が n に n を 掛け た 値 以下の 間 、 次 を 繰 り 返す	while i <= n * n :	while i <= n * n : <eos>
c 1 に c 2 を加え た 値を S とする	S = c1 + c2	S = c1 + c2 <eos>
f _ i から 読み込んだ 一行 の 整数値 を R とする	R = int ( f_i . readline ( ) )	R = int ( f_i . readline ( ) ) <eos>
p a int ( f _ in p , x -1 , y ) を f _ in p とする	f_inp = paint ( f_inp , x - 1 , y )	f_inp = paint ( f_inp , x - 1 ) <eos>
無限 の 整数 列 の j 番目の 1 番目 を 1 だけ 増加 させる	count [ j ] [ 1 ] += 1	count [ j ] [ 1 ] += 1 <eos>
len ( s ) が 6 より 小さく または s が 全て アルファベット または s が 全て 数字 または s の 全て が 英 小文字 または s の 全て が 英 大文字 の とき 、	if len ( s ) < 6 or s . isalpha ( ) or s . isdigit ( ) or s . islower ( ) or s . isupper ( ) :	if len ( s ) < 6 or s . islower ( ) or s . islower ( ) or s . islower ( ) or len ( s . islower ( ) ) . islower ( ) : <eos>
b のコピー された 列 を s とする	s = b [ : ]	s = b [ : ] <eos>
_ num _ output s を 1 だけ 増加 させる	_num_outputs += 1	_num_outputs += 1 <eos>
S を 1.0 5 倍 にする	S *= 1.05	S *= 1.05 <eos>
mod が 1 と 等しい とき 、	if mod == 1 :	if mod == 1 : <eos>
0 から N 未 満 までの 数 列 の各要素 を i と し 、 i の 列 を p とする	p = [ i for i in range ( N ) ]	p = [ i for i in range ( N ) ] <eos>
入力された 文字列を " " で 分割 した 字句 列 の各要素 を j と し 、 j の 整数値 の 列 を 展開 し 、 それぞれ _ d 、 _ v とする	_d , _v = [ int ( j ) for j in input ( ) . split ( " " ) ]	v , d = [ int ( _ ) for j in input ( ) . split ( " " ) ] <eos>
0 から s の 長さ から t の 長さ を 引 いた 値に 1 を加え た 値 未 満 までの 数 列 の各要素 を x と し 、 s の x 番目 から x に t の 長さ を加え た 値 までの 部分 列 が t と 等しい ときの x を出力する の 列	[ print ( x ) for x in range ( len ( s ) - len ( t ) + 1 ) if s [ x : x + len ( t ) ] == t ]	print ( len ( [ s for x in range ( len ( t ) - 1 ) if x == len ( t ) + x [ t : x - 1 : t ] == x ] ) <eos>
m id から h _ i _ s m を 引 いた 値を l とする	l = mid - h_i_sm	l = mid - h_i_sm <eos>
d が L 以上 かつ flag の とき 、	if d >= L and flag :	if d >= L and flag >= flag : <eos>
s の 長さが 1 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if len ( s ) == 1 : <blk> break </blk>	if len ( s ) == 1 : <blk> break </blk> <eos>
入力された 文字列を 空白 で 分割 した 字句 列 のリスト を p とする	p = list ( input ( ) . split ( ) )	p = list ( input ( ) . split ( ) ) <eos>
0 から L IM を 2 で 割 った 商 に 1 を加え た 値 未 満 までの 数 列 を 順に x として 、 繰 り 返す	for x in range ( LIM // 2 + 1 ) :	for x in range ( L // 2 + 1 ) : <eos>
get _ right ( d ice [ : ] , top , f r on t ) を出力する	print ( get_right ( dice [ : ] , top , front ) )	print ( <unk> ( dice , top [ top : front ] , front ) ) <eos>
a を 実 部 、 b を 虚 部 と した 複素数 を a とする	a = complex ( a , b )	a = complex ( a , b ) <eos>
f を in c r だけ 増加 させる	f += incr	f += rr <eos>
A を l とする	l = A	l = A <eos>
track が k 以下の とき 、	if track <= k :	if track <= k : <eos>
'0' を m の i 番目 にする	m [ i ] = '0'	m [ i ] = '0' <eos>
ma is u の n 番目 を ma is u の x 番目 に 1 を加え た 値 だけ 増加 させる	maisu [ n ] += maisu [ x ] + 1	maisu [ n ] += maisu [ x ] + 1 <eos>
an s 、 dist に対応する 値 、 もし 存在し なければ ( i 、 j 、 0 ) の 組 、 IN F 、 dist に対応する 値 、 もし 存在し なければ ( i 、 j 、 1 ) の 組 、 IN F の 最小 値を an s とする	ans = min ( ans , dist . get ( ( i , j , 0 ) , INF ) , dist . get ( ( i , j , 1 ) , INF ) )	ans = min ( ans , min ( dist . get ( i , j ) , INF ) , ( i , j , j ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ d 、 a 、 k 、 t とする	d , a , k , t = map ( int , input ( ) . split ( ) )	d , a , t , k = map ( int , input ( ) . split ( ) ) <eos>
q を展開し て を出力する	print ( * q )	print ( * q ) <eos>
- 10 の 9 乗 を v _ max とする	v_max = - 10 ** 9	max_v = - 10 ** 9 <eos>
( 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 0 ) からなる 列 を G O AL とする	GOAL = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 ]	G = [ 1 , 2 , 3 , 4 , 5 , 7 , 8 , 0 ] <eos>
V から P を 引 いた 値 から an s を 引 いた 値 を出力する	print ( V - P - ans )	print ( V - P - ans ) <eos>
score が 11 以下 かつ one が 0 より大きい 間 、 次 を 繰 り 返す	while score <= 11 and one > 0 :	while score <= 11 and one > 0 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ t 、 h 、 s とする	t , h , s = map ( int , input ( ) . split ( ) )	t , s , t = map ( int , input ( ) . split ( ) ) <eos>
t gt _ h c s d _ order の no 番目 を t gt _ h c s d とする	tgt_hcsd = tgt_hcsd_order [ no ]	hcsd_order = after_orders [ no ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を j と し 、 j の 整数値 の 列 を table の i 番目 にする	table [ i ] = [ int ( j ) for j in input ( ) . split ( ) ]	table [ i ] = [ int ( j ) for j in input ( ) . split ( ) ] <eos>
a が " 0 " と 等 し く かつ b が " 0 " と 等しい とき 、	if a == "0" and b == "0" :	if a == "0" and b == 0 : <eos>
( 0 ) からなる 列 の 128 回 分 の 列 、 ( 0 ) からなる 列 の 128 回 分 の 列 を S 、 T とする	S , T = [ 0 ] * 128 , [ 0 ] * 128	S , FS = [ 0 ] * 128 , [ 0 ] * 128 , [ 128 <eos>
arr の id x に x を 挿入 する	arr . insert ( idx , x )	arr . insert ( idx , x ) <eos>
self の hash _ table の can d i date _ key 番目 でなく または self の hash _ table の can d i date _ key 番目 が val と 等しい とき 、	if not self . hash_table [ candidate_key ] or self . hash_table [ candidate_key ] == val :	if not self . hash_table [ left_index ] or self . hash_table [ candidate_key ] == candidate_key : <eos>
heap の先頭 を取り出し た 値を last key とする	lastkey = heap . pop ( )	last = heap . pop ( ) <eos>
node の left Child を l c とする	lc = node . leftChild	lcm = node . leftChild <eos>
( 、 つまり 偽 ) からなる 列 の n に 1 を加え た 値 回 分 の 列 を visit ed とする	visited = [ False ] * ( n + 1 )	visited = [ False ] * ( n + 1 ) <eos>
. を Ma p の h 番目の w 番目 にする	Map [ h ] [ w ] = "."	Map [ h ] [ w ] = "." <eos>
l even sh t e in ( s 1 , s 2 ) を an s とする	ans = levenshtein ( s1 , s2 )	ans = <unk> ( 1 , s ) <eos>
\\\\\ write ( " % . 16 f \\\\ \\\\ n " % res ) \\\\\	\\\\\write ( "%.16f\\\\\\\\n" % res )\\\\\	\\\\\write ( <unk> % res )\\\\ <eos>\
b と c を 入れ替え る	b , c = c , b	b , c = b , c <eos>
m が f と 等しい かどうか が r と 等しい かどうか が -1 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if m == f == r == - 1 : <blk> break </blk>	if m == f == r == - 1 : <blk> break </blk> <eos>
x を st ud ent の 長さ だけ 増加 させる	x += len ( student )	x += len ( student ) <eos>
step を f w d _ re c の tmp _ state 番目 にする	fwd_rec [ tmp_state ] = step	fwd_rec [ tmp_state ] = step <eos>
b に 5 を 掛け た 値に r に 3 を 掛け た 値 を加え た 値を y とする	y = b * 5 + r * 3	y = b * 5 + 3 * r <eos>
y の 先頭の 1 番目 を b とする	b = y [ 0 ] [ 1 ]	b = y [ 0 ] [ 1 ] <eos>
d r op ( f ab , 0 , 0 , d _ tmp ) を an s とする	ans = drop ( fab , 0 , 0 , d_tmp )	ans = <unk> ( 0 , ab , 0 , d ) <eos>
Q S を 順に q 、 x 、 s 、 t として 、 繰 り 返す	for q , x , s , t in QS :	for x , q , s , t , t in QS : <eos>
s ch の i 番目の 1 番目 を t とする	t = sch [ i ] [ 1 ]	t = chairs [ i ] [ 1 ] <eos>
0 から 2 6 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( 26 ) :	for k in range ( 26 ) : <eos>
pos が w 以上の とき 、 <blk> 繰り返し を 中断 する </blk>	if pos >= w : <blk> break </blk>	if pos >= w : <blk> break </blk> <eos>
arr の x から 1 を 引 いた 値 番目の y 番目 が 0 と 等しい とき 、 <blk> p の x 番目の y 番目 を p の x から 1 を 引 いた 値 番目の y 番目 だけ 増加 させる </blk>	if arr [ x - 1 ] [ y ] == 0 : <blk> p [ x ] [ y ] += p [ x - 1 ] [ y ] </blk>	if arr [ x - 1 ] [ y ] == 0 : <blk> p [ x ] [ y - 1 ] [ x ] += 1 </blk> <eos>
v x 2 、 v y 2 を v x 1 、 v y 1 とする	vx1 , vy1 = vx2 , vy2	vy1 , vy1 = vx2 , v2 <eos>
v t x _ dist を dist _ from _ 0 の v t x 番目 にする	dist_from_0 [ vtx ] = vtx_dist	dist [ vtx ] = vtx <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ m 、 f 、 r とする	m , f , r = input ( ) . split ( )	m , f , r = input ( ) . split ( ) <eos>
( p r v ) からなる 列 を k p r v とする	kprv = [ prv ]	prv = [ prv ] <eos>
空 辞書を this M on th とする	thisMonth = { }	thisMonth = { } <eos>
mp の n y 番目の n x 番目 が target と 等しい とき 、	if mp [ ny ] [ nx ] == target :	if mp [ ny ] [ nx ] == target : <eos>
T の l 番目 を 1 だけ 増加 させる	T [ l ] += 1	T [ l ] += 1 <eos>
2 に x 3 から x 1 を 引 いた 値を 掛け た 値を a a とする	aa = 2 * ( x3 - x1 )	a = 2 * ( x3 - x1 ) <eos>
0 、 32 を i 、 s とする	i , s = 0 , 32	s , i = 0 , 32 <eos>
d の b 番目 を 1 だけ 増加 させる	d [ b ] += 1	d [ b ] += 1 <eos>
s g を 順に e として 、 繰 り 返す	for e in sg :	for e in sg : <eos>
bits の 末尾に ( 0 、 i 、 1 、 0 ) の 組 を追加する	bits . append ( ( 0 , i , 1 , 0 ) )	bits . append ( ( 0 , i , 1 , 0 ) ) <eos>
tb l の 末尾に ( l 、 r 、 r から l を 引 いた 値 ) からなる 列 を追加する	tbl . append ( [ l , r , r - l ] )	tbl . append ( [ l , r , l - r ] ) <eos>
temp を x の j に 1 を加え た 値 番目 にする	x [ j + 1 ] = temp	x [ j + 1 ] = temp <eos>
arr の 総 和 を n で 割 った 値を m とする	m = sum ( arr ) / n	m = sum ( arr ) / n <eos>
' ' を 間 に入れ て le x の id x から 1 を 引 いた 値 番目 の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する	print ( ' ' . join ( map ( str , lex [ idx - 1 ] ) ) )	print ( ' ' . join ( map ( str , first [ idx - 1 ] ) ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ x の i 番目 、 y の i 番目 、 z の i 番目 とする	x [ i ] , y [ i ] , z [ i ] = map ( int , input ( ) . split ( ) )	x , y [ i ] , z [ i ] = map ( int , input ( ) . split ( ) ) <eos>
d と 20 を 割 ったとき の ( 商 を 展開 し 、 それぞれ d 、 _ k とする	d , _k = divmod ( d , 20 )	d , <unk> = divmod ( d , 20 ) <eos>
self の FLAGS と self の ALL _ ON の 論理 積 が self の ALL _ OFF と 等しい かどうか を返す	return self . FLAGS & self . ALL_ON == self . ALL_OFF	return self . FLAGS & self . ALL_ON == self . ALL_OFF <eos>
num を 2 の 4 から i を 引 いた 値 乗 だけ 増加 させる	num += 2 ** ( 4 - i )	num += 2 ** ( 4 - i ) <eos>
lines の 1 番目 から 1 に n を加え た 値 までの 部分 列 の各要素 に x を パラメータ として x . split ( ) の 2 番目の 浮動小数点数 を返す 関数を 適用 した 列 の 総 和 を r _ sum とする	r_sum = sum ( map ( lambda x : float ( x . split ( ) [ 2 ] ) , lines [ 1 : 1 + n ] ) )	sum = map ( lambda x : x [ 1 ] + sum ( map ( float , n [ x : x + 2 ] . split ( ) ) ) ) <eos>
d _ an s の とき 、	if d_ans :	if d_ans : <eos>
i に 1 を加え た 値が p の 長さ より 小さく かつ r o man の p の i 番目 番目 が r o man の p の i に 1 を加え た 値 番目 番目 より小さい とき 、	if i + 1 < len ( p ) and roman [ p [ i ] ] < roman [ p [ i + 1 ] ] :	if i + 1 < len ( roman ) and roman [ p [ i + 1 ] < roman [ p [ i + 1 ] ] : <eos>
math モジュール を用い る	from math import sqrt	from math import cos , cos , radians <eos>
j から 1 を 引 いた 値が 0 以上の とき 、	if j - 1 >= 0 :	if j - 1 >= 0 : <eos>
accu m _ h c s d _ order ( array ) を h c s d _ order とする	hcsd_order = accum_hcsd_order ( array )	hcsd_order = accumlator ( hcsd_order ) <eos>
i に i を 掛け た 値 から N 未 満 までの i 間 隔 の数 列 を 順に j として 、 繰 り 返す <blk> 0 を p の j 番目 にする </blk>	for j in range ( i * i , N , i ) : <blk> p [ j ] = 0 </blk>	for j in range ( i * i , N , i , j ) : <blk> p [ j ] = 0 </blk> <eos>
42 80 から w を 引 いた 値 を出力する	print ( 4280 - w )	print ( 4280 - w ) <eos>
f が 0 以上の とき 、	if f >= 0 :	if f >= 0 : <eos>
buf の 6 番目 を 実 部 、 buf の 7 番目 を 虚 部 と した 複素数 を p k とする	pk = complex ( buf [ 6 ] , buf [ 7 ] )	k = complex ( buf [ 6 ] , buf [ 7 ] ) <eos>
1 を change とする	change = 1	change = 1 <eos>
set H ight ( H , top )	setHight ( H , top )	<unk> ( H , top ) <eos>
( ( s 、 0 ) の 組 ) からなる 列 の 両端 キュー を que とする	que = deque ( [ ( s , 0 ) ] )	que = deque ( [ ( s , 0 ) ] ) <eos>
a の先頭 を pre とする 0 を d とする	pre = a [ 0 ] d = 0	pre = a [ 0 ] d = a <eos>
h e is e i 、 y から 1988 を 引 いた 値 、 m 、 d を出力する	print ( "heisei" , y - 1988 , m , d )	print ( "heisei" , y - 1988 , m , d ) <eos>
gra de ( m , e , j ) を出力する	print ( grade ( m , e , j ) )	print ( grades ( m , j , e ) ) <eos>
m の ( n 、 r 、 s ) の 組 番目 を返す	return m [ ( n , r , s ) ]	return ( m , n , s [ s ] ) <eos>
i が word に 含まれない とき 、 <blk> word の 0 に i を 挿入 する </blk>	if i not in word : <blk> word . insert ( 0 , i ) </blk>	if i not in word : <blk> word . insert ( 0 , i ) </blk> <eos>
co st を pos だけ 増加 させる	cost += pos	cost += pos <eos>
gra y を color の r 番目 にする	color [ r ] = "gray"	color [ r ] = "gray" <eos>
self の ed ge s の キー の集まり のリスト を返す	return list ( self . edges . keys ( ) )	return list ( self . keys ( ) ) <eos>
\\\\\ c ol 1 の 、 つまり 先頭から width 番目 までの 部分 列 に " \\\\ \\\\ n " を加え た 値に c ol 2 の 、 つまり 先頭から width 番目 までの 部分 列 を加え た 値に " \\\\ \\\\ n " を加え た 値を c ol _ set とする \\\\\	\\\\\col_set = col1 [ : width ] + "\\\\\\\\n" + col2 [ : width ] + "\\\\\\\\n"\\\\\	\\\\\print ( <unk> [ : width ] + <unk> + <unk> + <unk> [ : width ] ) </blk>\\\\ <eos>\
an s の 末尾に sum _ c を追加する	ans . append ( sum_c )	ans . append ( <unk> ) <eos>
m に tmp を加え た 値を m とする	m = m + tmp	m = m + tmp <eos>
q が n max より大きい とき 、 <blk> n max を出力する </blk>	if q > nmax : <blk> print ( nmax ) </blk>	if q > nmax : <blk> print ( nmax ) </blk> <eos>
input ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の集合 のリスト を ソート した 列 を arr とする	arr = sorted ( list ( set ( map ( int , input ( ) . split ( ) ) ) ) )	arr = sorted ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <eos>
i に i を 掛け た 値 から MAX 未 満 までの i 間 隔 の数 列 を 順に j として 、 繰 り 返す <blk> 偽 を prime の j 番目 にする </blk>	for j in range ( i * i , MAX , i ) : <blk> prime [ j ] = False </blk>	for j in range ( i * i , MAX , i ) : <blk> prime [ j ] = False </blk> <eos>
self の f _ key _ to _ val の キーと値 の集まり の 各 値を x を パラメータ として x の 1 番目 が other _ top と 等しい かどうか を返す 関数 で フィルタ ー した 列 を self _ top _ f a ce s とする	self_top_faces = filter ( lambda x : x [ 1 ] == other_top , self . f_key_to_val . items ( ) )	<unk> = filter ( lambda self . items ( ) , self . items [ 1 ] == self . items ( ) ) <eos>
x が b の -1 番目 より 小さく かつ x が c の末尾 より小さい とき 、	if x < b [ - 1 ] and x < c [ - 1 ] :	if x < b [ - 1 ] and x [ - 1 ] < c : <eos>
check ( i , j ) で ないとき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if not check ( i , j ) : <blk> continue </blk>	if not check ( i , j ) : <blk> continue </blk> <eos>
f の とき 、 <blk> 繰り返し を 中断 する </blk>	if f : <blk> break </blk>	if f : <blk> break </blk> <eos>
k が p と 等しい とき 、	if k == p :	if k == p : <eos>
construct ( p r v ) を k p r v とする	kprv = construct ( prv )	prv = <unk> ( prv ) <eos>
u . connect ed ( e [ 0 ] , e [ 1 ] ) で ないとき 、	if not u . connected ( e [ 0 ] , e [ 1 ] ) :	if not u . connected ( e [ 0 ] , e [ 1 ] ) : <eos>
{ : 02 d } : { : 02 d } : { : 02 d } を 書式 として x を 36 00 で 割 った 商 、 x を 36 00 で 割 った 余 り を 60 で 割 った 商 、 x を 60 で 割 った 余 り で 整 形 した 文字列 を出力する	print ( "{:02d}:{:02d}:{:02d}" . format ( x // 3600 , ( x % 3600 ) // 60 , x % 60 ) )	print ( <unk> . format ( d // 3600 , ( x % 60 , x % 60 ) ) <eos>
i が s の 長さ より 小さく かつ s の i 番目 が c と 等しい 間 、 次 を 繰 り 返す <blk> i に 1 を加え た 値 、 w に 1 を加え た 値を i 、 w とする </blk>	while i < len ( s ) and s [ i ] == c : <blk> i , w = i + 1 , w + 1 </blk>	while i < len ( s ) and s [ i + 1 ] == w : <blk> w = i + 1 , i + 1 </blk> <eos>
in p のリスト の各要素 に 整数 を 適用 した 列 のリスト の 総 和 を出力する	print ( sum ( list ( map ( int , list ( inp ) ) ) ) )	print ( sum ( list ( map ( int , sum ( inp ) ) ) ) <eos>
g 2 を ソート する	g2 . sort ( )	g2 . sort ( ) <eos>
U R D L を p とする	p = "URDL"	p = <unk> <eos>
P S の i 番目 を 展開 し 、 それぞれ x 0 、 y 0 とする	x0 , y0 = PS [ i ]	x0 , y0 = PS [ i ] <eos>
x の 0 番目 が x の 1 番目 と 等しい とき 、 <blk> 1 を g の x の 先頭の 整数値 番目 にする </blk>	if x [ 0 ] == x [ 1 ] : <blk> g [ int ( x [ 0 ] ) ] = 1 </blk>	if x [ 0 ] == int ( x [ 1 ] ) : <blk> g [ 0 ] [ 1 ] = int ( x [ 0 ] ) </blk> <eos>
neighbor s を self の neighbor _ dict の node 1 番目 にする	self . neighbor_dict [ node1 ] = neighbors	self . neighbor_dict [ node1 ] = neighbors <eos>
max _ heap ify ( 1 )	max_heapify ( 1 )	max_heapify ( 1 ) <eos>
入力された 文字列を "," で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ s 、 g 、 v 、 p とする	s , g , v , p = map ( int , input ( ) . split ( "," ) )	s , g , v , g = map ( int , input ( ) . split ( "," ) ) <eos>
文字 コード 65 に c up s  の 1 と 等しい 要素の 最初の 位置 を加え た 値の 文字 を出力する	print ( chr ( 65 + cups . index ( 1 ) ) )	print ( chr ( <unk> + 1 ) . index ( chr ( s ) ) ) <eos>
contains ( c v x 2 , p ) の とき 、	if contains ( cvx2 , p ) :	if contains ( cvx2 , p2 ) : <eos>
l の 末尾に a の i 番目 を追加する	l . append ( a [ i ] )	l . append ( a [ i ] ) <eos>
n から f の s 番目 から n に 1 を加え た 値 までの 部分 列 の 総 和 を 引 いた 値 を出力する	print ( n - sum ( f [ s : n + 1 ] ) )	print ( n - sum ( f [ s : n + 1 ] ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ s 、 d 、 v とする	s , d , v = map ( int , input ( ) . split ( ) )	s , d , v = map ( int , input ( ) . split ( ) ) <eos>
'' を tmp _ an s とする	tmp_ans = ''	tmp_ans = '' <eos>
fibo ( n ) を出力する	print ( fibo ( n ) )	print ( fibo ( n ) ) <eos>
T を s を 英 小文字 に変換し た 文字列を 空白 で 分割 した 字句 列 だけ 増加 させる	T += s . lower ( ) . split ( )	T += s . lower ( ) . split ( ) <eos>
0 から n 未 満 までの 数 列 の各要素 を c と し 、 0 から n 未 満 までの 数 列 の各要素 を r と し 、 0 の 列 の 列 を tb l とする	tbl = [ [ 0 for r in range ( n ) ] for c in range ( n ) ]	tbl = [ [ 0 for r in range ( n ) ] for c in range ( n ) ] <eos>
A A A を出力する	print ( "AAA" )	print ( "AA" ) <eos>
f r i end list の k 番目 を 1 だけ 増加 させる	friendlist [ k ] += 1	friendlist [ k ] += 1 <eos>
0 から s の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> an s を tb l の s の i 番目の 整数値 番目 だけ 増加 させる </blk>	for i in range ( len ( s ) ) : <blk> ans += tbl [ int ( s [ i ] ) ] </blk>	for i in range ( len ( s ) ) : <blk> ans += tbl [ int ( tbl [ i ] [ i ] ) ] </blk> <eos>
d ic _ A に string を 追加した 集 まり	dic_A . add ( string )	dic_A . add ( string ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を S とする	S = input ( ) . split ( )	S = input ( ) . split ( ) <eos>
2 を last とする	last = 2	last = 2 <eos>
空 列 を w 3 とする	w3 = [ ]	w3 = [ ] <eos>
c の j から i を 引 いた 値 から 1 を 引 いた 値 番目 が 0 より大きい とき 、	if c [ j - i - 1 ] > 0 :	if c [ j - i - 1 ] > 0 : <eos>
入力された 文字列を in p とする	inp = input ( )	inp = input ( ) <eos>
time が q より大きい とき 、	if time > q :	if time > q : <eos>
s 内の " p e ach " を " @ @ @ @ @ @ @ " で 置き換え た 文字列を s とする	s = s . replace ( "peach" , "@@@@@@@" )	s = s . replace ( <unk> , <unk> ) <eos>
0 から 4 に i を 2 で 割 った 余 り を加え た 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 4 + i % 2 ) :	for j in range ( 4 + i % 2 ) : <eos>
n が i に j を加え た 値に k を加え た 値に l を加え た 値 と 等しい とき 、	if n == i + j + k + l :	if n == i + j + k + l : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を list ed _ input とする	listed_input = input ( ) . split ( )	cp_list = input ( ) . split ( ) <eos>
C を X の末尾 の -2 番目 にする	X [ - 1 ] [ - 2 ] = C	X [ - 2 ] = C [ - 1 ] <eos>
0 から a の 長さ から 1 を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( a ) - 1 ) :	for i in range ( len ( a ) - 1 ) : <eos>
p の 0 番目 を 1 だけ 減 少 させる	p [ 0 ] -= 1	p [ 0 ] -= 1 <eos>
0 から l の 長さ から 2 を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( l ) - 2 ) :	for i in range ( len ( l ) - 2 ) : <eos>
self の iter の cur _ ver t ex 番目 を 1 だけ 増加 させる	self . iter [ cur_vertex ] += 1	self . iter [ cur_vertex ] += 1 <eos>
A を B で 割 った 商 に 1 を加え た 値 を出力する	print ( A // B + 1 )	print ( A // B + 1 ) <eos>
in p のコピー された 列 を 展開 し 、 それぞれ q 1 、 b 、 c 1 、 c 2 、 q 2 とする	q1 , b , c1 , c2 , q2 = inp [ : ]	c1 , b2 , c1 = inp [ : ] <eos>
p を a とする	a = p	a = p <eos>
y a ma を出力する	print ( yama )	print ( yama ) <eos>
begin から end 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( begin , end ) :	for j in range ( begin , end ) : <eos>
i _ t a x に j _ t a x を加え た 値が s と 等しい とき 、	if i_tax + j_tax == s :	if i_tax + <unk> == s : <eos>
x が y より大きい とき 、 <blk> x と y を 入れ替え る </blk>	if x > y : <blk> x , y = y , x </blk>	if x > y : <blk> x , y = y , x </blk> <eos>
b が 4 より小さい とき 、	if b < 4 :	if b < 4 : <eos>
q の先頭 を c とする	c = q [ 0 ]	c = q [ 0 ] <eos>
tmp _ dist が sys の maxsize と 等しい とき 、	if tmp_dist == sys . maxsize :	if tmp_distance == sys . maxsize : <eos>
key を t の key にする	t . key = key	t . key = key <eos>
a を max A とする	maxA = a	maxA = a <eos>
x 1 ** 2 に y 1 ** 2 を加え た 値に y 2 から y 3 を 引 いた 値を 掛け た 値に x 2 ** 2 に y 2 ** 2 を加え た 値に y 3 から y 1 を 引 いた 値を 掛け た 値 を加え た 値に x 3 の 2 乗 に y 3 の 2 乗 を加え た 値に y 1 から y 2 を 引 いた 値を 掛け た	px = ( ( x1 ** 2 + y1 ** 2 ) * ( y2 - y3 ) + ( x2 ** 2 + y2 ** 2 ) * ( y3 - y1 ) + ( x3 ** 2 + y3 ** 2 ) * ( y1 - y2 ) ) / d	py = x1 * ( y2 ** 2 + y1 ** 2 - y2 ) * ( x1 ) + y1 - y2 ** 2 + y2 ** 2 + y1 ** 2 + y2 ** 2 ) * ( x1 - y3 ) <eos>
0 を d の cmd の 7 番目 から 、 つまり 末 尾 までの 部分 列 番目 にする	d [ cmd [ 7 : ] ] = 0	d [ 7 : ] = 0 <eos>
a に b を加え た 値を re t val とする	retval = a + b	retval = a + b <eos>
p の i 番目 が p の 21 番目 と 等しくない とき 、	if p [ i ] != p [ 21 ] :	if p [ i ] != p [ 21 ] : <eos>
r を me m o の a 番目の b 番目の state 番目 にする	memo [ a ] [ b ] [ state ] = r	memo [ a ] [ b ] [ state ] = r <eos>
b の各要素 に len を 適用 した 列 の 総 和 から 5 を 引 いた 値 を出力する	print ( sum ( map ( len , b ) ) - 5 )	print ( sum ( map ( sum , b ) - 5 ) ) <eos>
{} {} {} を出力する	print ( { min ( nums ) } { max ( nums ) } { sum ( nums ) } )	print ( { x } { y } ) <eos>
N の i 番目 から 9 番目 までの 3 間 隔 による 部分 列 内の k o ma の 出現 回数 が 3 と 等 し く または N の 3 に i を 掛け た 値 から 3 * i に 3 を加え た 値 までの 部分 列 内の k o ma の 出現 回数 が 3 と 等しい とき 、 <blk> k o ma を返す </blk>	if N [ i : 9 : 3 ] . count ( koma ) == 3 or N [ 3 * i : 3 * i + 3 ] . count ( koma ) == 3 : <blk> return koma </blk>	if N [ i : 3 ] . count ( koma ) == 3 : <blk> return koma + 3 * i . count ( koma ) </blk> <eos>
stack の 末尾に s 1 に s 2 を加え た 値 を追加する	stack . append ( s1 + s2 )	stack . append ( s1 + s2 ) <eos>
ed ge s の 末尾に 入力された 文字列を " " で 分割 した 字句 列 の各要素 を j と し 、 j の 整数値 の 列 を追加する	edges . append ( [ int ( j ) for j in input ( ) . split ( " " ) ] )	edges . append ( [ int ( j ) for j in input ( ) . split ( " " ) ] ) <eos>
y 3 が y 2 より大きく または y 4 が y 1 より小さい とき 、	if y3 > y2 or y4 < y1 :	if y3 > y2 or y2 < y4 : <eos>
tmp に table の i 番目の j 番目 を加え た 値を tmp とする	tmp = tmp + table [ i ] [ j ]	tmp = tmp + table [ i ] [ j ] <eos>
n を n から 30 を 引 いた 値 だけ 減 少 させる	n -= n - 30	n -= n - 30 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ command 、 key とする	command , key = input ( ) . split ( )	command , key = input ( ) . split ( ) <eos>
n が m と 等しい とき 、 <blk> ' per f ec t number ' を出力する </blk>	if n == m : <blk> print ( 'perfect number' ) </blk>	if n == m : <blk> print ( <unk> ) </blk> <eos>
is _ prime ( int ( input ( ) ) ) の とき 、	if is_prime ( int ( input ( ) ) ) :	if is_prime ( int ( input ( ) ) ) : <eos>
'{: . 6 f } { : . 6 f } ' を 書式 として pi に r の 2 乗 を 掛け た 値 、 2 に pi を 掛け た 値に r を 掛け た 値で 整 形 した 文字列 を出力する	print ( '{:.6f} {:.6f}' . format ( pi * r ** 2 , 2 * pi * r ) )	print ( <unk> <unk> . format ( r * pi , 2 * pi , r * pi ) ) <eos>
( 0 ) からなる 列 の M 回 分 の 列 を de g とする	deg = [ 0 ] * M	deg = [ 0 ] * M <eos>
( 3 80 、 55 0 、 8 50 ) からなる 列 を s とする	s = [ 380 , 550 , 850 ]	s = [ 3 , <unk> , 0 ] <eos>
L 、 R の 最大 値を返す	return max ( L , R )	return max ( L , R ) <eos>
( 0 、 1 、 0 、 -1 ) からなる 列 を x とする	x = [ 0 , 1 , 0 , - 1 ]	x = [ 0 , 1 , 0 , - 1 ] <eos>
an s 、 x の 3 乗 に y の 3 乗 を加え た 値の 最大 値を an s とする	ans = max ( ans , x ** 3 + y ** 3 )	ans = max ( ans , x ** 3 + y ** 3 ) <eos>
X の x から w を 引 いた 値 番目 を 1 だけ 増加 させる	X [ x - w ] += 1	X [ x - w ] += 1 <eos>
空 列 を stack _ B とする	stack_B = [ ]	<unk> = [ ] <eos>
mp の y 番目の x 番目の 間 、 次 を 繰 り 返す	while mp [ y ] [ x ] :	while mp [ y ] [ x ] : <eos>
skip が 0 より大きい とき 、	if skip > 0 :	if skip > 0 : <eos>
r が 0 と 等しくない とき 、	if r != 0 :	if r != 0 : <eos>
cross ( be - b s , s eg [ 0 ] - b s ) を a 1 とする	a1 = cross ( be - bs , seg [ 0 ] - bs )	sa = cross ( sb - seg [ 0 ] , - seg [ 1 ] ) <eos>
空 列 を pro d s とする	prods = [ ]	prods = [ ] <eos>
a が 60 より小さい とき 、 <blk> " al er t " を出力する </blk>	if a < 60 : <blk> print ( "alert" ) </blk>	if a < 60 : <blk> print ( <unk> ) </blk> <eos>
S 、 i に 1 を加え た 値 を出力する	print ( "S" , i + 1 )	print ( S , i + 1 ) <eos>
m が 0 と 等しくない とき 、	if m != 0 :	if m != 0 : <eos>
' ' を 間 に入れ て C の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する	print ( ' ' . join ( map ( str , C ) ) )	print ( ' ' . join ( map ( str , C ) ) ) <eos>
B を 4 で 割 った 余 り を n b とする	nb = B % 4	nb = B % 4 <eos>
CLASS ES を 順に weight 、 name として 、 繰 り 返す	for weight , name in CLASSES :	for name , weight in <unk> : <eos>
an s 、 s に i に 2 を加え た 値を 掛け た 値の 最大 値を an s とする	ans = max ( ans , s * ( i + 2 ) )	ans = max ( ans , s + i * 2 ) <eos>
to t i ent の 整数値 を出力する	print ( int ( totient ) )	print ( int ( totient ) ) <eos>
l を 2 で 割 った 商 を ll とする	ll = l // 2	ll = l // 2 <eos>
a x から b x を 引 いた 値の 2 乗 に a y から by を 引 いた 値の 2 乗 を加え た 値を返す	return ( ax - bx ) ** 2 + ( ay - by ) ** 2	return ( ( ax - bx ) ** 2 + ( ay - by ) ** 2 ) ** 2 <eos>
file _ input から 読み込んだ 一行 を n とする	n = file_input . readline ( )	n = file_input . readline ( ) <eos>
200 2 を MAX とする	MAX = 2002	MAX = 200 <eos>
1 に ( ( -1 、 0 ) からなる 列 、 ( 1 、 0 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 0 、 1 ) からなる 列 ) からなる 列 の各要素 を d x 、 d y と し 、 f ( x + d x , y + d y , r ) の	return 1 + sum ( [ f ( x + dx , y + dy , r ) for dx , dy in [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] ] )	f = [ 1 , [ 0 , - 1 ] , [ 0 , x + dy ] , [ 1 , 0 ] , [ dx , dy + dy ] ] <eos>
( n 、 r 、 s ) の 組 が m に含まれる とき 、	if ( n , r , s ) in m :	if ( n , s , m ) in m : <eos>
the t a を tmp だけ 減 少 させる	theta -= tmp	theta -= tmp <eos>
sys . set re cur s ion limit ( 1 000000 )	sys . setrecursionlimit ( 1000000 )	sys . setrecursionlimit ( 1000000 ) <eos>
an s を a の 0 番目 から M を 引 いた 値 、 0 の 最大 値 だけ 増加 させる	ans += max ( a [ 0 ] - M , 0 )	ans += max ( a [ 0 ] - M [ 0 ] , 0 ) <eos>
v 2 を v 1 分 の 一 にする	v2 /= v1	v2 /= v1 <eos>
P u z z le State ( u . state , depth = u . depth + 1 ) を new _ p u z z le とする	new_puzzle = PuzzleState ( u . state , depth = u . depth + 1 )	new_puzzle = <unk> . <unk> ( u . depth + 1 , u . depth + 1 ) <eos>
m id を right とする	right = mid	right = mid <eos>
( p の i 番目 、 p の n から i を 引 いた 値に 1 を加え た 値 番目 ) の 組 が ( 1 、 1 ) の 組 と 等しい とき 、 <blk> c を 1 だけ 増加 させる </blk>	if ( p [ i ] , p [ n - i + 1 ] ) == ( 1 , 1 ) : <blk> c += 1 </blk>	if ( p [ i ] , p [ i - 1 ] ) == ( n - 1 , c ) : <blk> c += 1 </blk> <eos>
ed ge s の b 番目の 末尾に ( a 、 d ) の 組 を追加する	edges [ b ] . append ( ( a , d ) )	edges [ b ] . append ( ( a , d ) ) <eos>
s を s から 1 を 引 いた 値を 5 で 割 った 余 り だけ 減 少 させる	s -= ( s - 1 ) % 5	s -= ( s - 1 ) % 5 <eos>
t から e を 引 いた 値が j 以下 かどうか が t に e を加え た 値 以下の とき 、	if t - e <= j <= t + e :	if t - e <= j + e <= t : <eos>
2 に r を 掛け た 値の 2 乗 が v min より大きい とき ' OK ' 、 そうでなければ ' N A ' を出力する	print ( 'OK' if ( 2 * r ) ** 2 > vmin else 'NA' )	print ( 'OK' if 2 * r > 2 else 'NA' ) <eos>
p が r より小さい とき 、	if p < r :	if p < r : <eos>
y _ s が 3 より小さい とき 、	if y_s < 3 :	if y_s < 3 : <eos>
0 、 0 を m 、 x とする	m , x = 0 , 0	m , x = 0 , 0 <eos>
0 を x とする	x = 0	x = 0 <eos>
s の 、 つまり 先頭から cur 番目 までの 部分 列 に c を加え た 値に s の cur 番目 から 、 つまり 末 尾 までの 部分 列 を加え た 値を s とする	s = s [ : cur ] + c + s [ cur : ]	s = s [ : cur ] + c [ cur + s : ] <eos>
n が ' =' と 等しい とき 、	if n == '=' :	if n == '=' : <eos>
t ( i , j , x ) が s と 等しくない とき 、 <blk> 何も しない </blk>	if t ( i , j , x ) != s : <blk> pass </blk>	if t ( i , j , s ) != <unk> : <blk> <unk> </blk> <eos>
rest を a から cur を 引 いた 値 だけ 減 少 させる	rest -= ( a - cur )	rest -= a - cur <eos>
c が g と 等 し く かつ s が 1 と 等しい とき 、	if c == g and s == 1 :	if c == g and s == 1 : <eos>
C ar d をコピーし た 結果を C ar d _ copy とする	Card_copy = copy . copy ( Card )	Card = copy . copy ( Card ) <eos>
an s が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if ans == 0 : <blk> break </blk>	if ans == 0 : <blk> break </blk> <eos>
G . Add E d ge ( c ity 2 , c ity 1 , co st 2 )	G . AddEdge ( city2 , city1 , cost2 )	G . AddEdge ( city1 , city2 , cost2 ) <eos>
y 1 から a 12 に x 1 を 掛け た 値を 引 いた 値を b 12 とする	b12 = y1 - a12 * x1	a12 = y1 - a1 * a12 <eos>
0 から 2 に n を 掛け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の各要素 を i と し 、 0 の 列 を A とする	A = [ 0 for i in range ( 2 * n - 1 ) ]	A = [ [ 0 for i in range ( n * 2 - 1 ) ] for i in range ( 2 * n - 1 ) ] <eos>
self の n が n _ より小さい 間 、 次 を 繰 り 返す <blk> self の n を 2 倍 にする </blk>	while self . n < n_ : <blk> self . n *= 2 </blk>	while self . n < n : <blk> self . *= 2 </blk> <eos>
in side ( n y , n x ) で ないとき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if not inside ( ny , nx ) : <blk> continue </blk>	if not inside ( ny , n ) : <blk> continue </blk> <eos>
b を出力する 入力された 文字列	print ( b ) input ( )	print ( b ) <eos>
空 列 を u とする	u = [ ]	u = [ ] <eos>
F の i 番目の j 番目の とき 、	if F [ i ] [ j ] :	if F [ i ] [ j ] : <eos>
b row を 1 だけ 増加 させる	brow += 1	row += 1 <eos>
event の 1 番目 を event _ type とする	event_type = event [ 1 ]	n_type = event [ 1 ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 のリスト を task とする	task = list ( input ( ) . split ( ) )	<unk> = list ( input ( ) . split ( ) ) <eos>
t の i 番目の p が -1 と 等しい とき 、 <blk> ' root ' を出力する </blk>	if t [ i ] . p == - 1 : <blk> print ( 'root' ) </blk>	if t [ i ] . p == - 1 : <blk> print ( ' ' ) </blk> <eos>
c n t を B の j 番目の i 番目 にする	B [ j ] [ i ] = cnt	B [ j ] [ i ] = cnt <eos>
( 2 ) からなる 列 を prime とする	prime = [ 2 ]	prime = [ 2 ] <eos>
( 0 ) からなる 列 の size 回 分 の 列 を fib とする	fib = [ 0 ] * size	fib = [ 0 ] * size <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 のリスト を 展開 し 、 それぞれ x 、 y とする	x , y = list ( map ( float , input ( ) . split ( ',' ) ) )	x , y = list ( map ( float , input ( ) . split ( ',' ) ) ) <eos>
i を min i とする	mini = i	mini = i <eos>
an s の 末尾に ( v 0 、 v 1 ) の 組 を追加する	ans . append ( ( v0 , v1 ) )	ans . append ( ( v0 , v1 ) ) <eos>
D を ソート した 列 を 順に k として 、 繰 り 返す	for k in sorted ( D ) :	for k in sorted ( D ) : <eos>
OK を an s とする	ans = "OK"	ans = "OK" <eos>
( x _ b から x _ a を 引 いた 値 、 y _ b から y _ a を 引 いた 値 ) からなる 列 を ab とする	ab = [ x_b - x_a , y_b - y_a ]	xa = [ x_d - ya , yb - y_ab ] <eos>
c に buf の 1 番目の 整数値 に b の d 番目の 先頭 を 掛け た 値 を加え た 値を c 2 とする	c2 = c + int ( buf [ 1 ] ) * b [ d ] [ 0 ]	c2 = c + int ( buf [ 1 ] ) * b [ d ] [ 0 ] <eos>
0 から H 未 満 までの 数 列 の各要素 を i と し 、 readline ( ) の 両端 から 空白 改行 を取り 除 いた 文字列の 列 を C とする	C = [ readline ( ) . strip ( ) for i in range ( H ) ]	C = [ readline ( ) . strip ( ) for i in range ( H ) ] <eos>
1 を d の b 番目 にする	d [ b ] = 1	d [ b ] = 1 <eos>
0 から e に 1 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 a の 末尾に i を追加する の 列	[ a . append ( i ) for i in range ( 0 , e + 1 ) ]	[ a . append ( i ) for i in range ( e + 1 ) ] <eos>
c を q の r 番目 にする	q [ r ] = c	q [ r ] = c <eos>
1 から H に 1 を加え た 値 未 満 までの 数 列 を 順に y として 、 繰 り 返す	for y in range ( 1 , H + 1 ) :	for y in range ( 1 , H + 1 ) : <eos>
s を i だけ 右 シフト した 値 と 1 の 論理 積 が 0 と 等しい とき 、	if ( s >> i & 1 ) == 0 :	if s >> ( i >> 1 ) == 0 : <eos>
heapq . heappush ( q , ( d [ i ] , i ) )	heapq . heappush ( q , ( d [ i ] , i ) )	heapq . heappush ( q , ( d [ i ] , i ) ) <eos>
f 、 s in k を d 、 v とする	d , v = f , sink	d , v = f , sink <eos>
self の st の 2 に k を 掛け た 値に 1 を加え た 値 番目 、 self の st の 2 に k を 掛け た 値に 2 を加え た 値 番目の 最大 値を self の st の k 番目 にする	self . st [ k ] = max ( self . st [ 2 * k + 1 ] , self . st [ 2 * k + 2 ] )	self . st [ k ] = max ( self . st [ 2 * k + 1 ] , self . st [ 2 * k + 2 ] ) <eos>
a の浮動小数点数 、 b の浮動小数点数 を a 、 b とする	a , b = float ( a ) , float ( b )	a , b = float ( a ) , float ( b ) <eos>
0 を dist の 0 番目 にする	dist [ 0 ] = 0	dist [ 0 ] = 0 <eos>
s to c k を 1 だけ 減 少 させる	stock -= 1	stock -= 1 <eos>
c 1 を 順に b 1 として 、 繰 り 返す	for b1 in c1 :	for b1 in c1 : <eos>
1 を f の i 番目 にする	f [ i ] = 1	f [ i ] = 1 <eos>
file _ input から 読み込んだ 一行 の 整数値 を k とする	k = int ( file_input . readline ( ) )	k = int ( file_input . readline ( ) ) <eos>
find ( x ) が find ( y ) と 等しい とき 、 <blk> 1 を出力する </blk>	if find ( x ) == find ( y ) : <blk> print ( 1 ) </blk>	if find ( x ) == y ( y ) : <blk> print ( 1 ) </blk> <eos>
空 列 を os . path とする	path = [ ]	path = [ ] <eos>
入力された 文字列の 整数値 の 2 乗 の 文字列を 長さ 8 になるように '0' 左 詰 め した 文字列を a とする	a = str ( int ( input ( ) ) ** 2 ) . zfill ( 8 )	a = str ( int ( input ( ) ** 2 ) . zfill ( 8 ) ) . zfill ( 8 ) <eos>
a から b に n から 10 を 引 いた 値に 125 を 掛け た 値 を加え た 値を 引 いた 値 を出力する	print ( a - ( b + ( n - 10 ) * 125 ) )	print ( a - ( b + 10 ) * 125 + ( n - 125 ) ) <eos>
a の 末尾に ( p 、 d ) からなる 列 を追加する	a . append ( [ p , d ] )	a . append ( [ p , d ] ) <eos>
2 に a に b を加え た 値を 掛け た 値を y とする	y = 2 * ( a + b )	y = 2 * a + b <eos>
re c のコピー を odd _ re c とする	odd_rec = rec . copy ( )	rec = rec . copy ( ) <eos>
l の i 番目の node を 順に n として 、 繰 り 返す	for n in l [ i ] . node :	for n in l [ i ] [ n ] : <eos>
d が t と 等しい かどうか が 0 と 等しい とき 、	if d == t == 0 :	if d == t == 0 : <eos>
k が L より 小さく かつ S の k 番目 が ' ' と 等しくない 間 、 次 を 繰 り 返す	while k < L and S [ k ] != ' ' :	while k < L and S [ k ] != ' ' : <eos>
d i stances の x 番目 に d を加え た 値を d i stances の i 番目 にする	distances [ i ] = distances [ x ] + d	distances [ i ] = distances [ x ] + d <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ x 、 y とする	x , y = map ( float , input ( ) . split ( ) )	x , y = map ( float , input ( ) . split ( ) ) <eos>
100 を de b t とする	debt = 100	debt = 100 <eos>
k を 1 だけ 増加 させる	k += 1	k += 1 <eos>
go al の 組 を go al とする	goal = tuple ( goal )	goal = tuple ( goal ) <eos>
p の y に 1 を加え た 値 番目の x 番目 に 1 を加え た 値を p の y に 1 を加え た 値 番目の x 番目 にする	p [ y + 1 ] [ x ] = p [ y + 1 ] [ x ] + 1	p [ y + 1 ] [ x + 1 ] = p [ y + 1 ] [ x ] <eos>
p が mod s に含まれる とき 、	if p in mods :	if p in mods : <eos>
P の i 番目 から P の i に 1 を加え た 値 番目 を 引 いた 値を x とする	x = P [ i ] - P [ i + 1 ]	x = P [ i ] - P [ i + 1 ] <eos>
h に 0.0 1 を 掛け た 値を h とする	h = h * 0.01	h = h * x1 <eos>
T を 順に i として 、 繰 り 返す	for i in T :	for i in T : <eos>
c を a d j _ m at の u 番目の v 番目 にする	adj_mat [ u ] [ v ] = c	adj_mat [ u ] [ v ] = c <eos>
rel ation _ line を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ s 、 t とする	s , t = relation_line . split ( )	s , t = relations . split ( ) <eos>
array の 末尾に y を追加する	array . append ( y )	array . append ( y ) <eos>
i が ls より 小さく かつ s の i 番目 が 全て アルファベット の間 、 次 を 繰 り 返す	while i < ls and s [ i ] . isalpha ( ) :	while i < ls and s [ i ] . isalpha ( ) : <eos>
0 を r _ B とする	r_B = 0	r_A = 0 <eos>
arr の n r 番目の n c 番目 が 1 と 等しい とき 、	if arr [ nr ] [ nc ] == 1 :	if arr [ nr ] [ nc ] == 1 : <eos>
d の 0 番目 を x の i 番目 から y の i 番目 を 引 いた 値の 絶対値 だけ 増加 させる	d [ 0 ] += abs ( x [ i ] - y [ i ] )	d [ 0 ] += abs ( x [ i ] - y [ i ] ) <eos>
i に 1 を加え た 値 から N 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( i + 1 , N ) :	for j in range ( i + 1 , N ) : <eos>
search _ blank _ in _ row ( y ) を 順に x として 、 繰 り 返す	for x in search_blank_in_row ( y ) :	for x in <unk> ( y ) : <eos>
( 0 ) からなる 列 の N 回 分 の 列 を u とする ( 0 ) からなる 列 の N 回 分 の 列 を zero s とする	u = [ 0 ] * N zeros = [ 0 ] * N	su = [ 0 ] * N zeros = [ 0 ] * N <eos>
st の 末尾に i を追加する	st . append ( i )	st . append ( i ) <eos>
n を 400 だけ 増加 させる	n += 400	n += <unk> <eos>
grap h の 、 つまり 現在の 日時 番目の 2 番目 から 、 つまり 末 尾 までの 部分 列 を 順に next として 、 繰 り 返す	for next in graph [ now ] [ 2 : ] :	for next in graph [ now : ] [ 2 : ] : <eos>
h の集合 の 長さが 1 と 等 し く または h の集合 の 長さが 3 と 等しい とき 、	if len ( set ( h ) ) == 1 or len ( set ( h ) ) == 3 :	if len ( set ( h ) == 1 or len ( set ( h ) ) == 3 : <eos>
i が g と 等しい とき 、 <blk> box の 末尾に co st に 1 を加え た 値 を追加する </blk>	if i == g : <blk> box . append ( cost + 1 ) </blk>	if i == g : <blk> cost . append ( ( box + 1 ) </blk> <eos>
m の d 番目の コピー された 列 を score d _ tea m とする	scored_team = m [ d ] [ : ]	scored_team = m [ : ] <eos>
t 500 が m 500 の i 番目 より 小さく かつ t 1 000 が m 1 000 の i 番目 より小さい とき 、	if t500 < m500 [ i ] and t1000 < m1000 [ i ] :	if t500 < m500 [ i ] and t1000 < m1000 [ i ] : <eos>
dist が r a に rb を加え た 値 より大きい とき 、	if dist > ra + rb :	if dist > ra + rb : <eos>
c の i 番目の j 番目 が 1 と 等しい とき 、	if c [ i ] [ j ] == 1 :	if c [ i ] [ j ] == 1 : <eos>
( P の 2 番目 から P の先頭 を 引 いた 値 、 P の 3 番目 から P の 1 番目 を 引 いた 値 ) からなる 列 を A B とする	AB = [ P [ 2 ] - P [ 0 ] , P [ 3 ] - P [ 1 ] ]	B = [ P [ 2 ] - P [ 0 ] , P [ 1 ] - P [ 1 ] ] <eos>
0 から 30 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 30 ) :	for i in range ( 30 ) : <eos>
-1 を money とする	money = - 1	money = - 1 <eos>
x を 2 6 だけ 減 少 させる	x -= 26	x -= 26 <eos>
board の 末尾に row を追加する	board . append ( row )	board . append ( row ) <eos>
1 を left とする	left = 1	left = 1 <eos>
t が an s より大きい とき 、 <blk> t を an s とする </blk>	if t > ans : <blk> ans = t </blk>	if t > ans : <blk> ans = t </blk> <eos>
x 2 から x 3 を 引 いた 値の 2 乗 に y 2 から y 3 を 引 いた 値の 2 乗 を加え た 値を a とする	a = ( x2 - x3 ) ** 2 + ( y2 - y3 ) ** 2	a = ( ( x2 - x3 ) ** 2 + ( y2 - y3 ) ** 2 <eos>
1 を d の color 番目 にする	d [ color ] = 1	d [ color ] = 1 <eos>
an s の 末尾に k のリスト を追加する	ans . append ( list ( k ) )	ans . append ( list ( k ) ) <eos>
_ num _ node s を 1 だけ 減 少 させる	_num_nodes -= 1	_num_nodes -= 1 <eos>
S を 空白 で 分割 した 字句 列 を words とする	words = S . split ( )	words = S . split ( ) <eos>
s の先頭 を そうでなければ 、 とする 入力された 文字列の 整数値 を d とする	else = s [ 0 ] d = int ( input ( ) )	d = int ( s [ 0 ] ) if s [ 0 ] <eos>
S が " END _ O F _ F IR ST _ P AR T " と 等しくない 間 、 次 を 繰 り 返す	while S != "END_OF_FIRST_PART" :	while S != <unk> : <eos>
a の 3 乗 を x とする	x = a ** 3	x = a ** 3 <eos>
oct ( n ) [ 2 : ] 内の ' 7 ' を ' 9 ' で 置き換え た 文字列 内の ' 6 ' を ' 8 ' で 置き換え た 文字列 内の ' 5 ' を ' 7 ' で 置き換え た 文字列 内の ' 4 ' を ' 5 ' で 置き換え た 文字列 を出力する	print ( oct ( n ) [ 2 : ] . replace ( '7' , '9' ) . replace ( '6' , '8' ) . replace ( '5' , '7' ) . replace ( '4' , '5' ) )	print ( <unk> . replace ( n . replace ( '9' , '3' . replace ( '9' ) , '3' . replace ( '9' ) , '3' ) ) <eos>
p t を パラメータ として ( p t の x 座 標 、 p t の y 座 標 ) の 組 を返す 関数を key として verti ce s を ソート する	vertices . sort ( key = lambda pt : ( pt . x , pt . y ) )	vertices . sort ( key = lambda pt : ( pt . x , pt . y ) ) <eos>
x が pos と 等しい とき 、 <blk> y を pos とする </blk>	if x == pos : <blk> pos = y </blk>	if x == pos : <blk> pos = pos </blk> <eos>
self の p t 1 の x 座 標 に t を self の abs で 割 った 値に self の vec t or の x 座 標 を 掛け た 値 を加え た 値を x とする	x = self . pt1 . x + t / self . abs * self . vector . x	xt = self . pt1 + self . x * self . x + self . vector . x / t . x <eos>
N の l 番目の 整数値 を a とする	a = int ( N [ l ] )	a = int ( N [ l ] ) <eos>
B の 0 番目 が A の 0 番目 以下 かどうか が C の 0 番目 以下 または C の 0 番目 が A の 0 番目 以下 かどうか が B の先頭 以下の とき 、	if B [ 0 ] <= A [ 0 ] <= C [ 0 ] or C [ 0 ] <= A [ 0 ] <= B [ 0 ] :	if B [ 0 ] <= A [ 0 ] <= C [ 0 ] or C [ 0 ] <= C [ 0 ] <= C [ 0 ] : <eos>
( ' M on ' 、 ' T ue s ' 、 ' W ed n es ' 、 ' T h ur s ' 、 ' F r i ' 、 ' S a tur ' 、 ' Sun ' ) からなる 列 の datetime 、 2004 、 m 、 d の 日付 の 週 番目 に ' day ' を加え た 値 を出力する	print ( [ 'Mon' , 'Tues' , 'Wednes' , 'Thurs' , 'Fri' , 'Satur' , 'Sun' ] [ datetime . date ( 2004 , m , d ) . weekday ( ) ] + 'day' )	print ( [ "Monday" , "Tuesday" , "Wednesday" , "Thursday" , n , <unk> ] [ i ] ) . <unk> <eos>
( 0 ) からなる 列 の N 回 分 の 列 を co ls とする	cols = [ 0 ] * N	cols = [ 0 ] * N <eos>
K が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if K == 0 : <blk> break </blk>	if K == 0 : <blk> break </blk> <eos>
s が " an i " と 等しい とき 、	if s == "ani" :	if s == <unk> : <eos>
t の i 番目 が b の先頭 と 等しい とき 、	if t [ i ] == b [ 0 ] :	if t [ i ] == b [ 0 ] : <eos>
find _ cycle ( min _ incoming _ ed ge s , root ) を C とする	C = find_cycle ( min_incoming_edges , root )	C = <unk> ( <unk> ) <eos>
v を min v とする	minv = v	minv = v <eos>
file _ input から 読み込んだ 一行 の 整数値 を Q とする	Q = int ( file_input . readline ( ) )	Q = int ( file_input . readline ( ) ) <eos>
re t val または _ check ( _ pi ) を re t val とする	retval = retval or _check ( _pi )	retval = retval ( <unk> ) <eos>
math モジュール を用い る	from math import acos	from math import cos , cos , radians <eos>
readline ( ) を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ S 、 T とする	S , T = readline ( ) . split ( )	S , T = readline ( ) . split ( ) <eos>
d q . popleft ( ) を cur _ ver t ex とする	cur_vertex = dq . popleft ( )	ret = dq . popleft ( ) <eos>
table の x 番目の y から i を 引 いた 値 番目の とき 、	if table [ x ] [ y - i ] :	if table [ x ] [ y - i ] : <eos>
100 を self の Ma x にする	self . Max = 100	self . Max = 100 <eos>
1 e -5 を E P S とする	EPS = 1 e -5	EPS = 1 e <unk> <eos>
\\\\\ ' \\\\ \\\\ n ' を 間 に入れ て an s を 連結 した 文字列 を出力する \\\\\	\\\\\print ( '\\\\\\\\n' . join ( ans ) )\\\\\	\\\\\print ( '\\\\\\\\n' . join ( ans ) ) <eos>\
A の 1 番目 が B の 1 番目 以下 または A の 1 番目 が C の 1 番目 より大きい とき 、	if A [ 1 ] <= B [ 1 ] or A [ 1 ] > C [ 1 ] :	if A [ 1 ] <= B [ 1 ] or A [ 1 ] > C [ 1 ] : <eos>
heapq . heappush ( Q , ( 0 , i , 0 ) )	heapq . heappush ( Q , ( 0 , i , 0 ) )	heapq . heappush ( Q , ( 0 , i , 0 ) ) <eos>
( a の k 番目 、 a の i 番目 ) の 組 を ( a の i 番目 、 a の k 番目 ) の 組 とする	( a [ i ] , a [ k ] ) = ( a [ k ] , a [ i ] )	a [ i ] = ( a [ k ] , a [ i ] ) <eos>
dist an t ( A , B , 1 )	distant ( A , B , 1 )	distant ( A , B , 1 ) <eos>
c の i 番目 を 1 だけ 増加 させる	c [ i ] += 1	c [ i ] += 1 <eos>
si e ve ( )	sieve ( )	sieve ( ) <eos>
( 0 ) からなる 列 の 30 回 分 の 列 を st ud ent とする	student = [ 0 ] * 30	student = [ 0 ] * 30 <eos>
result の -2 番目の 2 番目 を出力する	print ( result [ - 2 ] [ 2 ] )	print ( result [ - 2 ] [ 2 ] ) <eos>
readline ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ M 、 N とする	M , N = map ( int , readline ( ) . split ( ) )	N , M = map ( int , readline ( ) . split ( ) ) <eos>
re t val を white の i 番目 から white の先頭 を 引 いた 値 だけ 増加 させる	retval += white [ i ] - white [ 0 ]	retval += white [ 0 ] - white [ 0 ] <eos>
com の先頭 が ' insert ' と 等しい とき 、 <blk> d q の先頭に com の 1 番目 を追加する </blk>	if com [ 0 ] == 'insert' : <blk> dq . appendleft ( com [ 1 ] ) </blk>	if com [ 0 ] == 'insert' : <blk> dq . appendleft ( com [ 1 ] ) </blk> <eos>
phase ( v 12 ) を t とする	t = phase ( v12 )	t = phase ( v ) <eos>
s から 1 を 引 いた 値 、 d から 1 を 引 いた 値を s 、 d とする	s , d = s - 1 , d - 1	s , d = s - 1 , d - 1 <eos>
( K 、 d p ) の 組 を返す	return ( K , dp )	return ( K , dp ) <eos>
pre _ x が p on d s の末尾 の先頭 より小さい とき 、	if pre_x < ponds [ - 1 ] [ 0 ] :	if pre_x [ - 1 ] < ponds : <eos>
1000 から n を 引 いた 値を change とする	change = 1000 - n	change = 1000 - n <eos>
d p の m 番目 を出力する	print ( dp [ m ] )	print ( dp [ m ] ) <eos>
heapq . heappush ( q , ( d _ tmp , node [ 0 ] ) )	heapq . heappush ( q , ( d_tmp , node [ 0 ] ) )	heapq . heappush ( q , ( node , 0 ) ) <eos>
24 を返す	return 24	return 24 <eos>
{ : . 6 f } を 書式 として result で 整 形 した 文字列 を出力する	print ( "{:.6f}" . format ( result ) )	print ( <unk> . format ( result ) ) <eos>
n を 36 00 で 割 った 商 を hour とする	hour = n // 3600	hour = n // 3600 <eos>
C の i に 1 を加え た 値 から j 番目 までの 部分 列 を C 1 の i 番目 から j から 1 を 引 いた 値 までの 部分 列 にする	C1 [ i : j - 1 ] = C [ i + 1 : j ]	C [ i : j ] = C [ i + 1 : i - 1 ] <eos>
0 から n から 1 を 引 いた 値 未 満 までの 数 列 の各要素 を i と し 、 file _ input から 読み込んだ 一行 の 整数値 の 列 を s hop とする	shop = [ int ( file_input . readline ( ) ) for i in range ( n - 1 ) ]	shop = [ int ( file_input . readline ( ) ) for i in range ( n - 1 ) ] <eos>
c の p の i 番目の j 番目 番目の j 番目 が 1 と 等しい とき 、 <blk> s を p の i 番目の j 番目 だけ 増加 させる </blk>	if c [ p [ i ] [ j ] ] [ j ] == 1 : <blk> s += p [ i ] [ j ] </blk>	if c [ p [ i ] [ j ] ] == s [ i ] [ j ] : <blk> s [ i ] += 1 </blk> <eos>
f が an s より大きい とき 、 <blk> f を an s とする </blk>	if f > ans : <blk> ans = f </blk>	if f > ans : <blk> ans = f </blk> <eos>
key を j だけ 増加 させる	key += j	key += j <eos>
{} , {} を返す	return { self . pt1 } , { self . pt2 }	return { self . pt2 } , { self . pt2 } <eos>
node が 、 つまり 未 定 値 と 等しくない とき 、 <blk> 何も 返さ ない </blk>	if node is None : <blk> return </blk>	if node is None : <blk> return </blk> <eos>
k o ch ( n , a , b )	koch ( n , a , b )	koch ( n , a , b ) <eos>
lines の 2 番目 から 2 に N を加え た 値 までの 部分 列 を 順に l として 、 繰 り 返す	for l in lines [ 2 : 2 + N ] :	for l in lines [ 2 : N + 2 ] : <eos>
tmp が an s より大きい とき 、	if tmp > ans :	if tmp > ans : <eos>
state と - state の 論理 積 を b とする	b = state & - state	b = state & - state <eos>
mag ic _ s qua re ( n ) を s q とする	sq = magic_square ( n )	sq = <unk> ( n ) <eos>
Point ( C 6 0 * p . x - S 6 0 * p . y , S 6 0 * p . x + C 6 0 * p . y ) を返す	return Point ( C60 * p . x - S60 * p . y , S60 * p . x + C60 * p . y )	return Point ( C . x * s60 + Point ( xp , yp - x0 * y * CD . x , yp ) + 0 <eos>
入力された 文字列の 整数値 を line _ number とする	line_number = int ( input ( ) )	number_list = int ( input ( ) ) <eos>
an s を 10 だけ 増加 させる	ans += 10	ans += 10 <eos>
row の 末尾に sum s の -1 番目 に r h o m b ic の k 番目 の末尾 を加え た 値 を追加する	row . append ( sums [ - 1 ] + rhombic [ k ] [ - 1 ] )	row . append ( sums [ - 1 ] + rhombic [ k ] [ - 1 ] ) <eos>
S の top から 1 を 引 いた 値 番目 が L EFT と 等しくない 間 、 次 を 繰 り 返す	while S [ top - 1 ] != LEFT :	while S [ top - 1 ] != LEFT : <eos>
p を出力する	print ( p )	print ( p ) <eos>
ON を first とする	first = "ON"	first = "ON" <eos>
line を ', ' で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ n 、 w 、 t とする	n , w , t = map ( float , line . split ( ',' ) )	t , w , t = map ( float , line . split ( ',' ) ) <eos>
2 、 0 を i 、 c とする	i , c = 2 , 0	i , c = 2 , 0 <eos>
0 が x に d x を加え た 値 以下 かどうか が 8 より 小さく かつ 0 が y に d y を加え た 値 以下 かどうか が 8 より 小さく かつ a の y に d y を加え た 値 番目の x に d x を加え た 値 番目 が '1' と 等しい とき 、 <blk> f ( a , x + d x , y + d y )	if 0 <= x + dx < 8 and 0 <= y + dy < 8 and a [ y + dy ] [ x + dx ] == '1' : <blk> f ( a , x + dx , y + dy ) </blk>	if 0 <= x + d < 8 and 0 <= y < 8 and a [ y + dx ] [ y + dy ] == '1' : <blk> f ( x , y + a [ x - y ] [ x ] ) </blk> <eos>
l を a に 100 を 掛け た 値 だけ 減 少 させる	l -= a * 100	l -= a * 100 <eos>
0 から 5 1 未 満 までの 数 列 の各要素 を i と し 、 0 の 列 を an s とする	ans = [ 0 for i in range ( 51 ) ]	ans = [ 0 for i in range ( 51 ) ] <eos>
v 1 を v とする	v = v1	v = v1 <eos>
1 を d の a 番目 にする	d [ a ] = 1	d [ a ] = 1 <eos>
u を U の i 番目 にする	U [ i ] = u	U [ i ] = u <eos>
空 列 を D 0 とする 空 列 を z 0 とする	D0 = [ ] z0 = [ ]	z0 = [ ] z = [ ] <eos>
sum _ s を sent だけ 増加 させる	sum_s += sent	<unk> += <unk> <eos>
入力された 文字列 の浮動小数点数 を q とする	q = float ( input ( ) )	q = float ( input ( ) ) <eos>
find _ from ( self . root , key ) の とき 、	if find_from ( self . root , key ) :	if <unk> ( self . root , key ) : <eos>
0 から 6 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 6 ) :	for j in range ( 6 ) : <eos>
self . root s ( ) の 長さ を返す	return len ( self . roots ( ) )	return self . root ( len ( self ) ) <eos>
( ( value , C O DE 1 の キーと値 の集まり の各要素 を key 、 value と し 、 key の 列 ) ) からなる 辞書を C O DE 1 _ rev とする	CODE1_rev = { value : [ key for key , value in CODE1 . items ( ) ] }	<unk> = { value : [ key for key , value in CODE2 . items ( ) ] } <eos>
do t ( a , b ) が 0 より小さい とき 、	if dot ( a , b ) < 0 :	if dot ( a , b ) < 0 : <eos>
fib を出力する	print ( fib )	print ( fib ) <eos>
s cal er ( n a is ek i ( P 1 P 2 , P 1 Q ) / size ( P 1 P 2 ) , P 1 P 2 ) を P 1 H とする	P1H = scaler ( naiseki ( P1P2 , P1Q ) / size ( P1P2 ) , P1P2 )	<unk> = <unk> ( a1 , P1 , P2 , d_P1_P2 ) / ( P1 , P2 ) <eos>
dist の s in k 番目 が self の inf と 等しい とき 、 <blk> -1 を返す </blk>	if dist [ sink ] == self . inf : <blk> return - 1 </blk>	if dist [ sink ] == self . inf : <blk> return - 1 </blk> <eos>
S eg ment ( p 0 , Point ( p 1 _ x , p 1 _ y ) ) を s eg とする	seg = Segment ( p0 , Point ( p1_x , p1_y ) )	seg = Segment ( Point ( p0_x , p0_y ) , Point ( p1_x , p1_y ) ) <eos>
es の先頭 を an s とする	ans = es [ 0 ]	ans = es [ 0 ] <eos>
n の各要素 を x と し 、 x の 整数値 の 列 の 総 和 を出力する	print ( sum ( [ int ( x ) for x in n ] ) )	print ( sum ( [ int ( x ) for x in n ] ) ) <eos>
0 を total L en とする	totalLen = 0	total = 0 <eos>
dir ec に 1 を加え た 値を 4 で 割 った 余 り を dir ec とする	direc = ( direc + 1 ) % 4	direc = ( direc + 1 ) % 4 <eos>
St a c k under f low ! を出力する	print ( "Stack underflow!" )	print ( <unk> <unk> <unk> ) <eos>
l b l の i 番目 が -1 と 等しくない とき 、	if lbl [ i ] != - 1 :	if lbl [ i ] != - 1 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 i 、 j とする	n , i , j = map ( int , input ( ) . split ( ) )	n , i , j = map ( int , input ( ) . split ( ) ) <eos>
b の x 番目 、 b の i 番目 を a の x 番目 、 a の y 番目 とする c n t を 1 だけ 増加 させる	a [ x ] , a [ y ] = b [ x ] , b [ i ] cnt += 1	b [ x ] , a [ y ] = b [ i ] , b [ c ] <eos>
( 、 つまり 偽 ) からなる 列 の 400 01 回 分 の 列 を me m とする	mem = [ False ] * 40001	memo = [ False ] * 100001 <eos>
改行 せずに str ( L [ j ] ) . r just ( 5 ) を出力する	print ( str ( L [ j ] ) . rjust ( 5 ) , end = "" )	print ( str ( L [ j ] ) . rjust ( 5 ) , end = "" ) <eos>
空 列 を verti cal とする	vertical = [ ]	vertical = [ ] <eos>
y 2 から y 1 を 引 いた 値を x 2 から x 1 を 引 いた 値で 割 った 値を d _ P 1 _ P 2 とする	d_P1_P2 = ( y2 - y1 ) / ( x2 - x1 )	d_P1_P2 = ( y2 - y1 ) / ( x2 - x1 ) <eos>
find ( self . root , key ) の とき 、	if find ( self . root , key ) :	if find ( self . root , key ) : <eos>
s a を r a だけ 増加 させる	sa += ra	sa += aqr <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列の 列 を g r id とする	grid = [ input ( ) . strip ( ) for _ in range ( n ) ]	grid = [ input ( ) . strip ( ) for _ in range ( n ) ] <eos>
9 から 0 未 満 までの -1 間 隔 の数 列 を 順に k として 、 繰 り 返す	for k in range ( 9 , 0 , - 1 ) :	for k in range ( 9 , 0 , - 1 ) : <eos>
y を x の 2 乗 に y の 2 乗 を加え た 値 の平方根 で 割 った 値を a とする	a = y / ( math . sqrt ( x ** 2 + y ** 2 ) )	a = math . sqrt ( y ** 2 + x ** 2 / y ) <eos>
n に i を加え た 値 から 1 を 引 いた 値が 500 21 より 小さく かつ b が 0 と 等 し く かつ c の n に i を加え た 値 から 1 を 引 いた 値 番目 が 1 と 等しい とき 、	if n + i - 1 < 50021 and b == 0 and c [ n + i - 1 ] == 1 :	if n + i - 1 == 0 and b [ i + 1 ] == 0 and c == n - 1 : <eos>
n に price の t 番目 を 掛け た 値 を出力する	print ( n * price [ t ] )	print ( n * price [ t ] ) <eos>
s が os . path の末尾 と 等しい とき 、	if s == path [ - 1 ] :	if s == path [ - 1 ] : <eos>
\\\\\ write ( " % . 1 f \\\\ \\\\ n " % round ( an s , 1 ) ) \\\\\	\\\\\write ( "%.1f\\\\\\\\n" % round ( ans , 1 ) )\\\\\	\\\\\write ( <unk> % ( 1 , round ( ans , round ( ans ) ) ) )\\\\ <eos>\
input _ command の 7 番目 から 、 つまり 末 尾 までの 部分 列 を key とする	key = input_command [ 7 : - 1 ]	key = input_command [ 7 : ] <eos>
空 列 を b k _ init とする	bk_init = [ ]	bk_init = [ ] <eos>
x の 1 番目 を 展開 して を出力する	print ( * x [ 1 ] )	print ( * x [ 1 ] ) <eos>
v 3 の 整数値 を V の v 3 番目 にする	V [ v3 ] = int ( v3 )	V [ v3 ] = int ( v3 ) <eos>
d ice の 2 番目 を出力する	print ( dice [ 2 ] )	print ( dice [ 2 ] ) <eos>
入力された 文字列を S とする	S = input ( )	S = input ( ) <eos>
mp の キーと値 の集まり を 順に k 、 v として 、 繰 り 返す	for k , v in mp . items ( ) :	for k , v in mp . items ( ) : <eos>
S の i 番目の j 番目 で ないとき 、	if not S [ i ] [ j ] :	if S [ i ] [ j ] : <eos>
H IT を出力する	print ( "HIT" )	print ( H ) <eos>
check ( b , n )	check ( b , n )	check ( b , n ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を in p とする	inp = list ( map ( int , input ( ) . split ( ) ) )	inp = list ( map ( int , input ( ) . split ( ) ) ) <eos>
[ MASK ] の 両端 キュー を D 1 とする	D1 = deque ( )	D1 = collections . deque ( ) <eos>
tb l を 順に i として 、 繰 り 返す <blk> i を展開し て を出力する </blk>	for i in tbl : <blk> print ( * i ) </blk>	for i in tbl : <blk> print ( * i ) </blk> <eos>
insert _ node を p の left にする	p . left = insert_node	p . left = insert_node <eos>
left _ child が -1 と 等しくない とき 、	if left_child != - 1 :	if left_child != - 1 : <eos>
answer を box だけ 増加 させる	answer += box	answer += box <eos>
' ABC ' を 順に tra y として 、 繰 り 返す	for tray in 'ABC' :	for tray in <unk> : <eos>
b m _ i から b w _ i を 引 いた 値を d とする	d = bm_i - bw_i	d = bm_i - b_w <eos>
0 から M 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を G とする	G = [ [ ] for i in range ( M ) ]	G = [ [ ] for i in range ( M ) ] <eos>
m を 2 で 割 った 余 り の とき 、	if m % 2 :	if m % 2 : <eos>
path 1 の c 番目 に path 2 の c 番目 を 掛け た 値を path 2 の先頭 で 割 った 値 を出力する	print ( ( path1 [ c ] * path2 [ c ] ) / path2 [ 0 ] )	print ( path1 [ c ] * path2 [ 0 ] / path2 [ 2 ] ) <eos>
x を 1 だけ 減 少 させる	x -= 1	x -= 1 <eos>
input ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の 総 和 を k で 割 った 商 を出力する	print ( sum ( map ( int , input ( ) . split ( ) ) ) // k )	print ( sum ( map ( int , input ( ) . split ( ) ) // k ) ) <eos>
入力された 文字列の 逆 順 を出力する	print ( input ( ) [ : : - 1 ] )	print ( input ( ) . : - 1 ) <eos>
入力された 文字列の 整数値 を card s _ num とする	cards_num = int ( input ( ) )	cards_s = int ( input ( ) ) <eos>
p _ all を ソート した 列 を p _ all とする	p_all = sorted ( p_all )	p_all = sorted ( p_all ) <eos>
array の left 番目 から left に n _ for e を加え た 値 までの 部分 列 を l _ for e とする	l_fore = array [ left : left + n_fore ]	l_fore = array [ left : n + <unk> ] <eos>
d の id 番目の 文字列のリスト を 展開 して を出力する	print ( * list ( str ( d [ id ] ) ) )	print ( * list ( input ( ) ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 から 1 を 引 いた 値の 列 を 展開 し 、 それぞれ x g 、 y g とする	xg , yg = [ int ( _ ) - 1 for _ in input ( ) . split ( ) ]	gx , gy = [ int ( _ ) for _ in input ( ) . split ( ) ] <eos>
i に i を 掛け た 値が 1 000000 より小さい 間 、 次 を 繰 り 返す	while i * i < 1000000 :	while i * 1000000 < 1000000 : <eos>
1 から node s の 長さ を 2 で 割 った 商 に 1 を加え た 値 未 満 までの 数 列 の 逆 順 を 順に i として 、 繰 り 返す	for i in range ( 1 , len ( nodes ) // 2 + 1 ) [ : : - 1 ] :	for i in range ( 1 , len ( nodes ) // 2 + 1 ) [ : : : - 1 ] : <eos>
10 に v を 掛け た 値に 9 を加え た 値を v とする	v = 10 * v + 9	v = 10 * v + 9 <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を 展開 し 、 それぞれ no 、 p とする	no , p = [ int ( _ ) for _ in input ( ) . split ( ',' ) ]	no , p = [ int ( _ ) for _ in input ( ) . split ( ',' ) ] <eos>
OK を返す	return "OK"	return "OK" <eos>
current _ dist が d i j k str a _ gree d y より小さい とき 、	if ( current_dist < dijkstra_greedy ) :	if current_dist < dijkstra : <eos>
me m o の a 番目の b 番目の state 番目 が -1 と 等しくない とき 、	if memo [ a ] [ b ] [ state ] != - 1 :	if memo [ a ] [ b ] [ state ] != - 1 : <eos>
\\\\\ \\\\ \\\\ n {} \\\\ \\\\ n を 間 に入れ て 1 から 5 未 満 までの 数 列 の各要素 を b と し 、 ' \\\\ \\\\ n ' を 間 に入れ て range ( 1 , 4 ) の各要素 を f と し 、 ' ' + ' ' . join ( [ str ( res ident s [ ( b , f , r ) ]\	\\\\\print ( \\\\\\\\ n { "#" * 20 }\\\\\\\\ n . join ( [ '\\\\\\\\n' . join ( [ ' ' + ' ' . join ( [ str ( residents [ ( b , f , r ) ] ) for r in range ( 1 , 11 ) ] ) for f in range ( 1 , 4 ) ] ) for b in range ( 1 , 5 ) ] ) )\\\\\	\\\\\ans = '\\\\\\\\n' . join ( [ '\\\\\\\\n' . join ( [ { b } for b in range ( 1 , 4 + 1 ) ] , n + 1 ) )\\\\ <eos>\
P の 末尾に Point s の i 番目 に 10 の 5 乗 を 掛け た 値の 整数値 を追加する	P . append ( int ( Points [ i ] * 10 ** 5 ) )	P . append ( int ( Point ( s [ i ] * 10 ) ** 5 ) ) <eos>
未 定 値を S とする	S = None	S = None <eos>
pp 0 の 、 つまり 先頭から 、 つまり 末 尾 までの 部分 列 を p o とする	po = pp0 [ 0 : ]	po = 0 [ : ] <eos>
0 から w 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( w ) :	for j in range ( w ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ ID 、 m 1 、 s 1 、 m 2 、 s 2 、 m 3 、 s 3 、 m 4 、 s 4 とする	ID , m1 , s1 , m2 , s2 , m3 , s3 , m4 , s4 = map ( int , input ( ) . split ( ) )	s , m1 , s1 , m2 , s3 , m3 , s3 = map ( int , input ( ) . split ( ) ) <eos>
0 から 10 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を G とする	G = [ [ ] for i in range ( 10 ) ]	G = [ [ ] for i in range ( 10 ) ] <eos>
0 から 15 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 15 ) :	for i in range ( 15 ) : <eos>
2 から 100 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 2 , 100 ) :	for i in range ( 2 , 100 ) : <eos>
sys の stdin の各要素 を line と し 、 line の 浮動小数点数の 列 を height s とする	heights = [ float ( line ) for line in sys . stdin ]	heights = [ float ( line ) for line in sys . stdin ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を 展開 し 、 それぞれ y 1 、 m 1 、 d 1 、 y 2 、 m 2 、 d 2 とする	y1 , m1 , d1 , y2 , m2 , d2 = list ( map ( int , input ( ) . split ( ) ) )	y1 , m1 , d1 , d2 , m2 , d2 = list ( map ( int , input ( ) . split ( ) ) ) <eos>
s の 文字列の長さ が 80 より大きい とき 、	if len ( str ( s ) ) > 80 :	if len ( str ( len ( s ) ) > 80 : <eos>
y を an s とする	ans = y	ans = y <eos>
x を 順に i として 、 繰 り 返す	for i in x :	for i in x : <eos>
parse ( S . strip ( ) ) を res とする	res = parse ( S . strip ( ) )	res = parse ( S . strip ( ) ) <eos>
h を 1 だけ 減 少 させる	h -= 1	h -= 1 <eos>
an s の逆 順 を出力する	print ( ans [ : : - 1 ] )	print ( ans [ : - 1 ] ) <eos>
C a se 、 i の 文字列に ":" を加え た 値 、 x の文字列 を出力する	print ( "Case" , str ( i ) + ":" , str ( x ) )	print ( str ( "Case " , i + ":" , x ) ) <eos>
k が prime s に含まれる とき 、	if k in primes :	if k in primes : <eos>
0 から n を 4 で 割 った 値の 整数値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( int ( n / 4 ) ) :	for i in range ( int ( n / 4 ) ) : <eos>
入力された 文字列の 整数値 の 3 乗 を出力する	print ( int ( input ( ) ) ** 3 )	print ( int ( input ( ) ) ** 3 ) <eos>
node { 0 } : key = { 1 } , left key = { 2 } , right key = { 3 } , を 書式 として k 、 key の k 番目 、 key の lk 番目 、 key の r k 番目 で 整 形 した 文字列 を出力する	print ( "node {0}: key = {1}, left key = {2}, right key = {3}, " . format ( k , key [ k ] , key [ lk ] , key [ rk ] ) )	print ( "node "node "node "node {0}: key = {1}, parent key = {2}, left key = {2}, left key = {2}, left key = {2}, <unk> " . format ( k , key [ k ] , key [ lk ] , key [ lk ] , key [
an s を stack に 1000 を 掛け た 値 だけ 増加 させる	ans += stack * 1000	ans += stack * 1000 <eos>
24 に 60 を 掛け た 値を A とする	A = 24 * 60	A = 24 * 60 <eos>
j が k と 等しくな く かつ p u z z le の i 番目の j 番目 が p u z z le の i 番目の k 番目 と 等しい とき 、	if j != k and puzzle [ i ] [ j ] == puzzle [ i ] [ k ] :	if j != k and puzzle [ i ] [ j ] == puzzle [ i ] [ k ] : <eos>
2 に a * b + b * c に c * a を加え た 値に 3 に n を 掛け た 値 を加え た 値 から s を 引 いた 値を 掛け た 値 を出力する	print ( 2 * ( ( a * b + b * c + c * a ) + 3 * n - s ) )	print ( 2 * a + b * b + c * 3 + s * n - s * s ) <eos>
left が right より小さい 間 、 次 を 繰 り 返す	while left < right :	while left < right : <eos>
0 が x 1 以下 かどうか が 10 より 小さく かつ 0 が y 1 以下 かどうか が 10 より小さい とき 、	if 0 <= x1 < 10 and 0 <= y1 < 10 :	if 0 <= x1 < 10 and 0 <= y1 < 10 : <eos>
next ( n ) を an s _ c n t とする	ans_cnt = next ( n )	ans_cnt = next ( n ) <eos>
入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列を 順に char として 、 繰 り 返す	for char in input ( ) . strip ( ) :	for char in input ( ) . strip ( ) : <eos>
f ( n , x ) の とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if f ( n , x ) : <blk> continue </blk>	if f ( n , x ) : <blk> continue </blk> <eos>
S 2 の 末尾に ( left _ ed ge 、 new _ p ud d le ) の 組 を追加する	S2 . append ( ( left_edge , new_puddle ) )	S2 . append ( ( left_edge , <unk> ) ) <eos>
x から r を 引 いた 値が 0 より 小さく または x に r を加え た 値が W より大きく または y から r を 引 いた 値が 0 より 小さく または y に r を加え た 値が H より大きい とき 、	if ( x - r < 0 or x + r > W or y - r < 0 or y + r > H ) :	if x - r > 0 or x + r - W > 0 or y + r > H or y - y - r > 0 : <eos>
0 から N 未 満 までの 数 列 を 順に row として 、 繰 り 返す	for row in range ( N ) :	for row in range ( N ) : <eos>
stack で ないとき 、	if not stack :	if not stack : <eos>
d p の n に 1 を加え た 値 番目の s に k を加え た 値 番目 を d p の n 番目の s 番目 だけ 増加 させる	dp [ n + 1 ] [ s + k ] += dp [ n ] [ s ]	dp [ n + 1 ] [ k + s ] += dp [ n ] [ s ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 浮動小数点数の 列 を 展開 し 、 それぞれ x 1 、 y 1 、 x 2 、 y 2 、 x 3 、 y 3 とする	x1 , y1 , x2 , y2 , x3 , y3 = [ float ( i ) for i in input ( ) . split ( ) ]	x1 , y1 , x2 , y2 , x3 , y3 = [ float ( i ) for i in input ( ) . split ( ) ] <eos>
p の 長さが 1 と 等しい とき 、 <blk> 空 列 を m s とする </blk>	if len ( p ) == 1 : <blk> ms = [ ] </blk>	if len ( p ) == 1 : <blk> s = s </blk> <eos>
( 1 ) からなる 列 の 3 00 回 分 の 列 を d p とする	dp = [ 1 ] * 300	dp = [ 1 ] * 300 <eos>
self の p t 2 から self の p t 1 を 引 いた 値を self の vec t or にする	self . vector = self . pt2 - self . pt1	self . pt1 = self . pt2 - self . pt1 <eos>
a の r 番目の 1 番目 を x とする	x = a [ r ] [ 1 ]	x = a [ r ] [ 1 ] <eos>
pointer を 1 だけ 増加 させる	pointer += 1	pointer += 1 <eos>
C の i 番目 が -1 と 等しい とき 、	if C [ i ] == - 1 :	if C [ i ] == - 1 : <eos>
S が T の j 番目 から 、 つまり 末 尾 までの 部分 列 に T の 、 つまり 先頭から j 番目 までの 部分 列 を加え た 値 と 等しくない とき 、	if S != T [ j : ] + T [ : j ] :	if S == T [ j : ] : <eos>
move を 順に m v として 、 繰 り 返す	for mv in move :	for v in move : <eos>
( e から 2 に pi を 掛け た 値を 引 いた 値 、 1 ) の 組 を cd に ソート 順 で 最後に 挿入 する	insort ( cd , ( e - 2 * pi , 1 ) )	insort ( cd , ( e - 2 * pi , - 1 ) ) <eos>
readline ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ N 、 M とする	N , M = map ( int , readline ( ) . split ( ) )	N , M = map ( int , readline ( ) . split ( ) ) <eos>
e の とき 、	if e :	if e : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を _ と し 、 _ の 整数値 の 列 を ソート した 列 を 展開 し 、 それぞれ a 、 b 、 c とする	a , b , c = sorted ( [ int ( _ ) for _ in input ( ) . split ( ) ] )	a , b , c = sorted ( [ int ( _ ) for _ in input ( ) . split ( ) ] ) <eos>
y 1 が y 2 と 等しい かどうか が 0 と 等しい とき 、	if y1 == y2 == 0 :	if y1 == y2 == 0 : <eos>
expr ( ) を p 1 とする	p1 = expr ( )	p1 = expr ( ) <eos>
tree _ walk _ 2 ( p )	tree_walk_2 ( p )	tree_walk_1 ( p ) <eos>
node 2 が self の ed ge s の node 1 番目 に 含まれない とき 、	if node2 not in self . edges [ node1 ] :	if node2 not self . edges [ node1 ] : <eos>
ch a ir s の id x に 1 を加え た 値 番目 が ' A ' と 等しい とき 、	if chairs [ idx + 1 ] == 'A' :	if chairs [ idx + 1 ] == 'A' : <eos>
left _ tree _ end s を 順に ll 、 l r として 、 繰 り 返す	for ll , lr in left_tree_ends :	for <unk> , r in right_tree_ends : <eos>
typing モジュール を用い る	from typing import Union , Tuple , List	from typing import List <eos>
R S の 長さ を B とする	B = len ( RS )	B = len ( RS ) <eos>
( ( 0 、 1 、 X ) の 組 ) からなる 列 を h q とする	hq = [ ( 0 , 1 , X ) ]	hq = [ ( 0 , 1 , X ) ] <eos>
g を追加して q を更新する	q . update ( g )	g . update ( g ) <eos>
pre _ c p の とき 、	if pre_cp :	if pre_cp : <eos>
string モジュール を用い る	from string import digits	from string import ascii_lowercase <eos>
node _ no が -1 と 等しい とき 、	if node_no == - 1 :	if node_no == - 1 : <eos>
3 000 を返す	return 3000	return 3000 <eos>
0 から l 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( l ) :	for i in range ( l ) : <eos>
y から 1 を 引 いた 値 から y に 2 を加え た 値 未 満 までの 数 列 を 順に n y として 、 繰 り 返す	for ny in range ( y - 1 , y + 2 ) :	for ny in range ( y - 1 , y2 + 2 ) : <eos>
入力された 文字列を "," で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ s 、 w 、 h とする	s , w , h = map ( float , input ( ) . split ( "," ) )	s , w , h = map ( float , input ( ) . split ( "," ) ) <eos>
空 列 を line _ list とする	line_list = [ ]	line_list = [ ] <eos>
{ 0 } { 1 } を 書式 として x 、 y で 整 形 した 文字列 を出力する	print ( "{0} {1}" . format ( x , y ) )	print ( "{0} {1} {2}" . format ( x , y ) ) <eos>
( ( k , 1 から 7 未 満 までの 数 列 の各要素 を k と し 、 0 の 列 ) ) からなる 辞書を dist とする	dist = { k : [ 0 for k in range ( 1 , 7 ) ] }	dist = { k : [ 0 for k in range ( 7 ) ] } <eos>
parent _ id x が 0 と 等しくない とき 、	if parent_idx != 0 :	if parent_idx != 0 : <eos>
at の 整数値 を at とする	at = int ( at )	at = int ( inorder ) <eos>
score の先頭 を t とする	t = score [ 0 ]	t = score [ 0 ] <eos>
( 0 ) からなる 列 の 両端 キュー を que とする	que = deque ( [ 0 ] )	que = deque ( [ 0 ] ) <eos>
a の i 番目 が b の i 番目 より大きい とき 、	if a [ i ] > b [ i ] :	if a [ i ] > b [ i ] : <eos>
入力された 文字列を "," で 分割 した 字句 列 のリスト を N とする	N = list ( input ( ) . split ( "," ) )	N = list ( input ( ) . split ( "," ) ) <eos>
a の i 番目 から b の j 番目 を 引 いた 値を 1 だけ 左 シフト した 値が s a と 等しい とき 、	if ( ( a [ i ] - b [ j ] ) << 1 ) == sa :	if a [ i ] - b [ j ] == s [ 1 ] - a == s : <eos>
p 1 に v に 2.0 を 掛け た 値を 3.0 で 割 った 値 を加え た 値を c とする	c = p1 + v * 2.0 / 3.0	c = p1 + 2.0 * v / 3.0 <eos>
set He a p Do w n _ max ( heap , pos )	setHeapDown_max ( heap , pos )	<unk> ( heap , pos ) <eos>
R の 末尾に number の i 番目 を追加する	R . append ( number [ i ] )	R . append ( number [ i ] ) <eos>
i を n _ close の " " を 間 に入れ て b _ now の node の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 番目 にする	n_close [ "" . join ( map ( str , b_now . node ) ) ] = i	<unk> [ b_now . join ( map ( str , b_now . node ) ) ] = i <eos>
-1 000 1 を an s とする	ans = - 10001	ans = - 10001 <eos>
is V is it ed の v 番目 が 、 つまり 真 と 等しい とき 、	if isVisited [ v ] == True :	if isVisited [ v ] == True : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を b r 2 とする	br2 = list ( map ( int , input ( ) . split ( ) ) )	br2 = list ( map ( int , input ( ) . split ( ) ) ) <eos>
prime s の 末尾に 真 を追加する	primes . append ( True )	primes . append ( True ) <eos>
'' を 間 に入れ て 0 から n 未 満 までの 数 列 の各要素 を c と し 、 0 が row に c を加え た 値 以下 かどうか が n より小さい ときの g r id の row に c を加え た 値 番目の c 番目の 列 を 連結 した 文字列を d ia g とする	diag = '' . join ( [ grid [ row + c ] [ c ] for c in range ( n ) if 0 <= row + c < n ] )	<unk> = '' . join ( [ grid [ row + c ] [ c ] for c in range ( n ) if 0 <= row <= row + c < row ] ) <eos>
member 2 を groups の person 番目 と の 論理和 にする	member2 | = groups [ person ]	groups [ <unk> ] | = <unk> <eos>
op が '*' と 等しい とき 、	if op == '*' :	if op == '*' : <eos>
a から b から 1 を 引 いた 値 未 満 までの -1 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( a , b - 1 , - 1 ) :	for i in range ( a , b - 1 , - 1 ) : <eos>
w を t の 2 乗 で 割 った 値が 25 以上の とき 、 <blk> n の 整数値 を出力する </blk>	if w / t ** 2 >= 25 : <blk> print ( int ( n ) ) </blk>	if w / t ** 2 >= 25 : <blk> print ( int ( n ) ) </blk> <eos>
p x が py と 等しい とき 、	if px == py :	if px == py : <eos>
min _ ed ge を min _ incoming _ ed ge s の min _ ed ge の 2 番目 番目 にする	min_incoming_edges [ min_edge [ 2 ] ] = min_edge	min_edge [ 2 ] = <unk> <eos>
tmp を i だけ 増加 させる	tmp += i	tmp += i <eos>
s の p 2 から s の p 1 を 引 いた 値を v 2 とする	v2 = s . p2 - s . p1	v2 = s . p2 - s . p1 <eos>
集合 を X とする	X = set ( )	X = set ( ) <eos>
n が " END O F IN PUT " と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if n == "END OF INPUT" : <blk> break </blk>	if n == "END OF INPUT" : <blk> break </blk> <eos>
self の ed ge s を出力する	print ( self . edges )	print ( self . edges ) <eos>
s 内の " H os hi no " を " H os h in a " で 置き換え た 文字列 を出力する	print ( s . replace ( "Hoshino" , "Hoshina" ) )	print ( s . replace ( "Hoshino" , "Hoshina" ) ) <eos>
d ice s を 順に d ice として 、 繰 り 返す	for dice in dices :	for dice in dices : <eos>
P P e Q ( tb l [ i ] , tb l [ j ] ) の とき 、	if PPeQ ( tbl [ i ] , tbl [ j ] ) :	if PPeQ ( tbl [ i ] [ j ] , tbl [ i ] ) : <eos>
r p を P S の state 0 番目 に R S の state 1 番目 に d 0 を 掛け た 値に SS の state 1 番目 を加え た 値を 掛け た 値 だけ 減 少 させる	rp -= PS [ state0 ] * ( RS [ state1 ] * d0 + SS [ state1 ] )	rr -= P0 [ state ] * cross ( PS [ state ] * R + 1 ) <eos>
e を R の y から l を 引 いた 値 番目 にする C の y から l を 引 いた 値 番目 を c だけ 増加 させる	R [ y - l ] = e C [ y - l ] += c	e [ R - l ] += C [ y - l ] <eos>
self の table の x _ root 番目 が self の table の y _ root 番目 より小さい とき 、	if self . table [ x_root ] < self . table [ y_root ] :	if self . table [ x_root ] < self . table [ y_root ] : <eos>
S 2 の 長さが 5 以上の とき 、	if len ( S2 ) >= 5 :	if len ( S2 ) >= 5 : <eos>
v s を 逆 順に する	vs . reverse ( )	vs . reverse ( ) <eos>
s a が s b と 等しい とき 、	if sa == sb :	if sa == sb : <eos>
vec t or の先頭 を取り出し た 値	vector . pop ( )	vec_a . pop ( ) <eos>
( -1 ) からなる 列 の 1 を 25 だけ 左 シフト した 値 回 分 の 列 を me m o とする	memo = [ - 1 ] * ( 1 << 25 )	memo = [ - 1 ] * ( 1 << 25 ) <eos>
0 を money とする	money = 0	money = 0 <eos>
1 を 無限 の 整数 列 とする	count = 1	count = 1 <eos>
m の n 乗 を 10 の i 乗 で 割 った 商 を 10 000 で 割 った 余 り を b とする	b = m ** n // ( 10 ** i ) % 10000	b = m ** n // 10000 <eos>
C S の 末尾に w を追加する	CS . append ( w )	CS . append ( w ) <eos>
0 から 6 未 満 までの 数 列 の各要素 を __ _ と し 、 0 から 6 未 満 までの 数 列 の各要素 を __ と し 、 0 から 4 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 偽 の 列 の 列 の 列 を board とする	board = [ [ [ False for _ in range ( 4 ) ] for __ in range ( 6 ) ] for ___ in range ( 6 ) ]	board = [ [ False for __ in range ( 4 ) ] for __ in range ( 6 ) ] <eos>
0 から 31 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を score とする	score = [ [ ] for i in range ( 31 ) ]	score = [ [ ] for i in range ( 31 ) ] <eos>
i の 先頭の 文字列に " " を加え た 値に i の 1 番目の 文字列 を加え た 値 を出力する	print ( str ( i [ 0 ] ) + " " + str ( i [ 1 ] ) )	print ( str ( i [ 0 ] ) + " " + str ( i [ 1 ] ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ hi 、 low とする	hi , low = map ( int , input ( ) . split ( ) )	hi , low = map ( int , input ( ) . split ( ) ) <eos>
n t が ' E ' と 等しい とき 、	if nt == 'E' :	if nt == 'E' : <eos>
' ' を 間 に入れ て index の word 番目 を ソート した 列 の各要素 を page と し 、 page の 文字列の 列 を 連結 した 文字列 を出力する	print ( ' ' . join ( [ str ( page ) for page in sorted ( index [ word ] ) ] ) )	print ( ' ' . join ( [ str ( page ) for word in sorted ( page ) ] ) ) <eos>
{ 0 : . 5 f } { 1 : . 5 f } を 書式 として a 、 b で 整 形 した 文字列 を出力する	print ( "{0:.5f} {1:.5f}" . format ( a , b ) )	print ( "{0:.8f} {1:.8f}" . format ( a , b ) ) <eos>
set _ node ( x )	set_node ( x )	<unk> ( x ) <eos>
v 1 が O VER より大きい とき 、 <blk> ( 、 つまり 偽 、 0 ) からなる 列 を返す </blk>	if v1 > OVER : <blk> return [ False , 0 ] </blk>	if v1 > OVER : <blk> return [ False , 0 ] </blk> <eos>
an s の 長さ を出力する	print ( len ( ans ) )	print ( len ( ans ) ) <eos>
m が 0 と 等しくな く または d が 0 と 等しくない 間 、 次 を 繰 り 返す	while m != 0 or d != 0 :	while m != 0 or d != 0 : <eos>
を 代わり の 行 末 として an s を出力する	print ( ans , end = " " )	print ( ans , end = " " ) <eos>
v の 3 番目 を e とする	e = v [ 3 ]	e = v [ 3 ] <eos>
- n を an s とする	ans = - n	ans = - n <eos>
div is or s を ソート した 列 を返す	return sorted ( divisors )	return sorted ( divisors ) <eos>
p の i 番目 を 展開 し 、 それぞれ y 、 x とする	y , x = p [ i ]	x , y = p [ i ] <eos>
y を 400 で 割 った 余 り が 0 と 等しい とき 、	if y % 400 == 0 :	if y % 400 == 0 : <eos>
1 を S の i 番目の j 番目 にする	S [ i ] [ j ] = 1	S [ i ] [ j ] = 1 <eos>
black を color の a 番目の b 番目 にする	color [ a ] [ b ] = "black"	color [ a ] [ b ] = "black" <eos>
tmp の 1 番目 を m とする	m = tmp [ 1 ]	m = tmp [ 1 ] <eos>
c ( ( int ( self ) - int ( n ) ) % p ) を返す	return c ( ( int ( self ) - int ( n ) ) % p )	return c ( ( int ( self ) - int ( n ) % p ) ) <eos>
find _ value が r の value と 等しい とき 、	if find_value == r . value :	if <unk> == r . value : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を 展開 し 、 それぞれ T 、 H 、 S とする	T , H , S = list ( map ( int , input ( ) . split ( ) ) )	H , S , S = list ( map ( int , input ( ) . split ( ) ) <eos>
an s の 末尾に w を追加する	ans . append ( w )	ans . append ( w ) <eos>
i が d ic に含まれる とき 、 <blk> d ic の i 番目 を 1 だけ 増加 させる </blk>	if i in dic : <blk> dic [ i ] += 1 </blk>	if i in dic : <blk> dic [ dic [ i ] += 1 </blk> <eos>
l 2 を ソート した 列 を l 2 とする	l2 = sorted ( l2 )	l2 = sorted ( l1 ) <eos>
ed ge s の とき 、	if edges :	if edges : <eos>
( 0 ) からなる 列 の N 回 分 の 列 を C とする 0 を s とする	C = [ 0 ] * N s = 0	C = [ 0 ] * N <eos>
0 を p 3 を p 2 とすると する を p 1 とする	p1 = p2 = p3 = 0	p1 = p3 = p2 = 0 <eos>
a が 13 と 等しい とき 、 <blk> 最初 から もう 一度 、 繰 り 返す </blk>	if a == 13 : <blk> continue </blk>	if a == 13 : <blk> continue </blk> <eos>
de gree の 末尾に 1 を追加する	degree . append ( 1 )	degree . append ( 1 ) <eos>
x 1 に x 1 を 掛け た 値 から x 3 に x 3 を 掛け た 値を 引 いた 値に y 1 に y 1 を 掛け た 値 を加え た 値 から y 3 に y 3 を 掛け た 値を 引 いた 値を c 2 とする	c2 = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3	c = x1 * x1 - x3 * y3 + y1 - y3 * y1 <eos>
0 から 、 つまり 入力された 文字列の 整数値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( int ( input ( ) ) ) :	for i in range ( int ( input ( ) ) ) : <eos>
tb l の d に N を 掛け た 値に a を加え た 値 から 1 を 引 いた 値 番目の 末尾に ( k 、 t ) の 組 を追加する	tbl [ d * N + a - 1 ] . append ( ( k , t ) )	tbl [ d * ( N + 1 - a ) ] . append ( ( t - 1 , t ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト に 番号 付 した 組 の 列 を 順に i 、 x として 、 繰 り 返す	for i , x in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ) :	for i , x in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) : <eos>
入力された 文字列の 整数値 から 1 を 引 いた 値 、 入力された 文字列の 整数値 を N 、 K とする	N , K = int ( input ( ) ) - 1 , int ( input ( ) )	N , K = int ( input ( ) ) - 1 , int ( input ( ) ) <eos>
l a を返す	return la	return la <eos>
10 の 9 乗 に 7 を加え た 値を M O D とする	MOD = 10 ** 9 + 7	M = 10 ** 9 + 7 <eos>
heappop ( p q ) を展開し 、 それぞれ u _ f a re 、 u とする	u_fare , u = heappop ( pq )	fare , u = heappop ( pq ) <eos>
x の 長さ を出力する	print ( len ( x ) )	print ( len ( x ) ) <eos>
0 を second とする	second = 0	second = 0 <eos>
merge S or t ( a , left , m id )	mergeSort ( a , left , mid )	mergeSort ( a , left , mid ) <eos>
p から r 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( p , r ) :	for j in range ( p , r ) : <eos>
si b l ing を self の si b l ing にする	self . sibling = sibling	self . sibling = sibling <eos>
Node ( children ) を node s の node _ no 番目 にする	nodes [ node_no ] = Node ( children )	nodes [ node_no ] = Node ( children ) <eos>
a に b を 掛け た 値 、 a に b を加え た 値に 2 を 掛け た 値 を出力する	print ( a * b , ( a + b ) * 2 )	print ( a * b , a + b * 2 ) <eos>
f の i 番目 から f の i から 1 を 引 いた 値 番目 を 引 いた 値が d 以上の とき 、 <blk> c を 1 だけ 増加 させる </blk>	if f [ i ] - f [ i - 1 ] >= d : <blk> c += 1 </blk>	if f [ i ] - f [ i - 1 ] >= d : <blk> c += 1 </blk> <eos>
check _ t r ip le ( [ board [ i ] [ i ] for i in range ( 3 ) ] ) の とき 、	if check_triple ( [ board [ i ] [ i ] for i in range ( 3 ) ] ) :	if check_triple ( [ board [ i ] [ 3 ] for i in range ( 3 ) ] ) : <eos>
depth の p 1 番目 から depth の p 0 番目 を 引 いた 値を d とする	d = depth [ p1 ] - depth [ p0 ]	dd = depth [ 1 ] - depth [ 0 ] <eos>
S ame が 、 つまり 真 と 等しい とき 、	if Same == True :	if Same == True : <eos>
l c s ( s [ : - sep ] , s [ - sep : ] , an s , an s _ len ) を展開し 、 それぞれ an s 、 an s _ len とする	ans , ans_len = lcs ( s [ : - sep ] , s [ - sep : ] , ans , ans_len )	ans , ans_len = lcs ( s [ : sep ] - s [ sep : ] , ans , ans_len ) <eos>
s を 正規表現 ' [ w | n ] ' で 分割 した 文字列 リスト の先頭 を 除 いた 部分 列 を s とする 1 を c とする	s = re . split ( '[w|n]' , s ) [ 1 : ] c = 1	s = re . split ( <unk> <unk> ( n [ 1 : ] ) [ 1 : ] <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 i の 列 の k 個 までの コン ビ ネ ーション を 順に iter として 、 繰 り 返す	for iter in itertools . combinations ( [ i for i in range ( n ) ] , k ) :	for i , iter in itertools . combinations ( [ k for i in range ( n ) ] ) : <eos>
push B a c k ( j + b , j + a )	pushBack ( j + b , j + a )	pushBack ( j + b , a + b ) <eos>
0 を point とする	point = 0	point = 0 <eos>
operator s を 順に s として 、 繰 り 返す	for s in operators :	for s in operators : <eos>
s 1 の 長さが 1 より大きく かつ s 1 の 0 番目 が " X " と 等 し く または s 2 の 長さが 1 より大きく かつ s 2 の 0 番目 が " X " と 等 し く または s 3 の 長さが 1 より大きく かつ s 3 の 0 番目 が " X " と 等しい とき 、	if ( len ( s1 ) > 1 and s1 [ 0 ] == "X" ) or ( len ( s2 ) > 1 and s2 [ 0 ] == "X" ) or ( len ( s3 ) > 1 and s3 [ 0 ] == "X" ) :	if len ( s1 ) > 1 and s [ 0 ] == "X" and len ( s [ 1 ] == "X" ) == "X" and s [ 2 ] == "X" : <eos>
a の b の i 番目 から 1 を 引 いた 値 番目 を 1 だけ 増加 させる	a [ b [ i ] - 1 ] += 1	a [ b [ i ] - 1 ] += 1 <eos>
改行 せずに " left key = {} , " を 書式 として node s の left _ id x から 1 を 引 いた 値 番目 で 整 形 した 文字列 を出力する	print ( "left key = {}, " . format ( nodes [ left_idx - 1 ] ) , end = "" )	print ( <unk> key = {}, " . format ( nodes [ left_idx - 1 ] , end = "" ) ) <eos>
x に d x を加え た 値を n x とする y に d y を加え た 値を n y とする	nx = x + dx ny = y + dy	nx = x + dx y = x + dy <eos>
A の S の v 番目 番目 が 0 より大きい とき 、	if A [ S [ v ] ] > 0 :	if A [ S [ v ] > 0 : <eos>
limit の d 番目 を l im とする	lim = limit [ d ]	lim = limit [ d ] <eos>
0 から n に 1 を加え た 値 未 満 までの 数 列 の各要素 を _ と し 、 " white " の 列 を color とする	color = [ "white" for _ in range ( n + 1 ) ]	color = [ "white" for _ in range ( n + 1 ) ] <eos>
line 2 の 長さ に 1 を加え た 値を n _ row s とする	n_rows = len ( line2 ) + 1	<unk> = len ( line2 ) + 1 <eos>
b の i 番目 を 順に j として 、 繰 り 返す	for j in b [ i ] :	for j in b [ i ] : <eos>
node の key が k と 等しい とき 、	if node . key == k :	if node . key == k : <eos>
temp を i で 割 った 余 り が 0 と 等しい とき 、	if temp % i == 0 :	if temp % i == 0 : <eos>
' d inner ' 、 cd の とき d に 100 を 掛け た 値を cd で 割 った 商 、 そうでなければ ' no g u est ' を出力する	print ( 'dinner' , d * 100 // cd if cd else 'no guest' )	print ( <unk> , 100 * 100 // cm if 100 else 'no guest' ) <eos>
link ed list . print _ all _ node ( )	linkedlist . print_all_node ( )	linkedlist . <unk> ( ) <eos>
0 、 1 を c n t 、 track とする	cnt , track = 0 , 1	cnt , track = 0 , 1 <eos>
k を S の top 番目 にする	S [ top ] = k	S [ top ] = k <eos>
r 0 に C を 掛け た 値に c 0 を加え た 値を v 0 とする	v0 = r0 * C + c0	v0 = r0 * C + c0 <eos>
re c の key 番目の 各 要素を l 、 r と し 、 ( base に l を加え た 値 、 base に r を加え た 値 ) の 組 の 列 の集合 を返す	return set ( [ ( base + l , base + r ) for l , r in rec [ key ] ] )	return set ( [ l ] + base [ r for l , base in rec ( l + r , l + r ) ] ) <eos>
d f _ lower _ search ( l , 0 , s , n , None ) の とき 、	if df_lower_search ( l , 0 , s , n , None ) :	if <unk> ( 0 , s , n , s , n ) : <eos>
' A ' を返す	return 'A'	return 'A' <eos>
0 を tmp とする	tmp = 0	tmp = 0 <eos>
空 列 を delta _ list とする	delta_list = [ ]	delta_list = [ ] <eos>
c _ check の キーと値 の集まり を 順に k 、 v として 、 繰 り 返す	for k , v in c_check . items ( ) :	for k , v in c_check . items ( ) : <eos>
: を 区切り として h 、 m 、 s を出力する	print ( h , m , s , sep = ":" )	print ( h , m , s , sep = <unk> , m ) <eos>
state を self の state にする	self . state = state	self . state = state <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ r 、 c とする	r , c = map ( int , input ( ) . split ( ) )	r , c = map ( int , input ( ) . split ( ) ) <eos>
max _ a re a 、 rect _ h に i から rect _ i を 引 いた 値を 掛け た 値の 最大 値を max _ a re a とする	max_area = max ( max_area , rect_h * ( i - rect_i ) )	max_area = max ( max_area , rect_h * ( rect_i - rect_i ) ) <eos>
tmp の 、 つまり 先頭から k 番目 までの 部分 列 を an s とする	ans = tmp [ : k ]	ans = tmp [ : k ] <eos>
ls を L の t 番目 にする	L [ t ] = ls	L [ t ] = ls <eos>
s a を A の v 番目 にする	A [ v ] = sa	A [ v ] = sa <eos>
tmp を 11 で 割 った 余 り を tmp とする	tmp = tmp % 11	tmp = tmp % 11 <eos>
1 を table の max top 番目の i 番目 にする	table [ maxtop ] [ i ] = 1	table [ maxtop ] [ i ] = 1 <eos>
a の 末尾に line の 整数値 を追加する	a . append ( int ( line ) )	a . append ( int ( line ) ) <eos>
0 から D 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( D ) :	for i in range ( D ) : <eos>
i の 整数値 を出力する	print ( int ( i ) )	print ( int ( i ) ) <eos>
A を 反 転 した 列 を 順に i として 、 繰 り 返す	for i in reversed ( A ) :	for i in reversed ( A ) : <eos>
s 1 に s 2 を加え た 値を max _ s とする	max_s = s1 + s2	max_s = s1 + s2 <eos>
stack の先頭 を取り出し た 値の 整数値 を right とする	right = int ( stack . pop ( ) )	right = int ( stack . pop ( ) ) <eos>
s に p c 1 の np 1 番目 、 p c 2 の np 2 番目の 最大 値 を加え た 値を new _ h _ cos t とする	new_h_cost = s + max ( pc1 [ np1 ] , pc2 [ np2 ] )	new_cost = max ( s + p1 [ p2 ] , <unk> [ c1 ] ) <eos>
( s ) からなる 列 を X とする	X = [ s ]	X = [ s ] <eos>
p o ly g on の i に 1 を加え た 値を M で 割 った 余 り 番目の 先頭 、 p o ly g on の i に 1 を加え た 値を M で 割 った 余 り 番目の 1 番目 を x 2 、 y 2 とする	x2 , y2 = polygon [ ( i + 1 ) % M ] [ 0 ] , polygon [ ( i + 1 ) % M ] [ 1 ]	x1 , y1 = ( polygon [ i + 1 ] [ 0 ] ) % M [ i ] , ( polygon [ i + 1 ] [ 2 ] ) % 2 ] <eos>
b r id ge s の 末尾に ( a 、 b 、 c 、 d ) の 組 を追加する	bridges . append ( ( a , b , c , d ) )	bridge . append ( ( a , b , c , d ) ) <eos>
an s を 15 に b を 掛け た 値に 15 から 2 を 引 いた 値に 5 を 掛け た 値に b を 掛け た 値 を加え た 値 だけ 増加 させる	ans += 15 * b + ( 15 - 2 ) * 5 * b	ans += 15 * 15 + 2 * b * 5 + b <eos>
l a den _ ba g g age を返す	return laden_baggage	return laden_baggage <eos>
length が 60 以下 かつ w が 2 以下の とき 、	if length <= 60 and w <= 2 :	if length <= 60 and w <= 2 : <eos>
delta _ list の 末尾に h _ list の i に 1 を加え た 値 番目 から h _ list の i 番目 を 引 いた 値 を追加する	delta_list . append ( h_list [ i + 1 ] - h_list [ i ] )	delta_list . append ( h [ i + 1 ] - h [ i ] ) <eos>
7 1 が x 以下 かどうか が 9 6 以下の とき 、	if 71 <= x <= 96 :	if 7 <= x <= 9 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の集合 を b とする	b = set ( map ( int , input ( ) . split ( ) ) )	b = set ( map ( int , input ( ) . split ( ) ) ) <eos>
node _ list のコピー された 列 を node _ tmp とする	node_tmp = node_list [ : ]	node_tmp = node_list [ : ] <eos>
' ' を 代わり の 行 末 として ' [ % d ] ' を a の index 番目 で 割 った 余 り を出力する	print ( '[%d]' % a [ index ] , end = ' ' )	print ( <unk> % d [ index ] , end = ' ' ' ) <eos>
max _ point を出力する	print ( max_point )	print ( max_d ) <eos>
y と x を y で 割 った 余 り の 最大 公 約 数 を返す	return gcd ( y , x % y )	return math . gcd ( y , x % y ) <eos>
0 、 0 、 0 を i 、 a 、 b とする	i , a , b = 0 , 0 , 0	a , b , a = 0 , 0 , 0 <eos>
heapq . heappush ( b _ open , ( b _ start . f , b _ start . h , 0 , b _ start ) )	heapq . heappush ( b_open , ( b_start . f , b_start . h , 0 , b_start ) )	heapq . heappush ( b_open , ( b_open , ( 0 , b , start , 0 ) ) <eos>
k の順序 数 から ' A ' の順序 数 を 引 いた 値を cd とする	cd = ord ( k ) - ord ( 'A' )	cd = ord ( k ) - ord ( 'A' ) <eos>
ls の 長さが 1 と 等しい とき 、	if len ( ls ) == 1 :	if len ( ls ) == 1 : <eos>
-2 に 10 の 9 乗 を 掛け た 値を max v とする	maxv = - 2 * 10 ** 9	maxv = 2 * 10 ** 9 <eos>
n が 6 17 4 と 等しい とき 、	if n == 6174 :	if n == 6 : <eos>
S の index 番目 が x と 等しい かどうか を返す	return S [ index ] == x	return S [ index ] == x <eos>
( P の 6 番目 から P の 4 番目 を 引 いた 値 、 P の 7 番目 から P の 5 番目 を 引 いた 値 ) からなる 列 を C D とする	CD = [ P [ 6 ] - P [ 4 ] , P [ 7 ] - P [ 5 ] ]	C = [ P [ 6 ] - P [ 4 ] , P [ 7 - 6 ] <eos>
' SS S W S SS ' を com 1 とする	com1 = 'SSSWSSS'	com1 = <unk> <eos>
pos の 0 番目 が 1 と 等 し く かつ pos の 1 番目 が 1 と 等しい とき 、	if pos [ 0 ] == 1 and pos [ 1 ] == 1 :	if pos [ 0 ] == 1 and pos [ 1 ] == pos [ 1 ] : <eos>
num を _ pow ( 10 , 12 ) で 割 った 余 り を num とする	num = num % _pow ( 10 , 12 )	num = num % _pow ( 10 , 12 ) <eos>
i が n より大きい とき 、 <blk> 真 を f とする </blk>	if i > n : <blk> f = True </blk>	if i > n : <blk> f = True </blk> <eos>
( -1 ) からなる 列 の q 回 分 の 列 を r r とする	rr = [ - 1 ] * q	rr = [ - 1 ] * q <eos>
array の min _ id x 番目 を array の i 番目 にする	array [ i ] = array [ min_idx ]	array [ i ] = array [ min_idx ] <eos>
tmp が an s より 小さく かつ flag の とき 、	if tmp < ans and flag :	if tmp < ans and ans : <eos>
x が i と 等しくない 間 、 次 を 繰 り 返す	while x != i :	while x != i : <eos>
d p の i 番目の k と 1 を i だけ 左 シフト した 値の 論理和 番目 、 d p の j 番目の k 番目 に d の r の i 番目 番目の r の j 番目 番目 を加え た 値の 最小 値を d p の i 番目の k と 1 を i だけ 左 シフト した 値の 論理和 番目 にする	dp [ i ] [ k | ( 1 << i ) ] = min ( dp [ i ] [ k | ( 1 << i ) ] , dp [ j ] [ k ] + d [ r [ i ] ] [ r [ j ] ] )	dp [ i ] [ j ] = min ( min ( dp [ i ] [ 1 << k [ i ] ) | ( 1 << i [ j ] ) + d [ k [ i ] [ j ] [ k ] [ i ] )
f が ' r ' と 等しい とき 、 <blk> c を 1 だけ 増加 させる </blk>	if f == 'r' : <blk> c += 1 </blk>	if f == rr : <blk> c += 1 </blk> <eos>
1 から 6 未 満 までの 数 列 を 順に r として 、 繰 り 返す	for r in range ( 1 , 6 ) :	for r in range ( 1 , 6 ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ p 2 _ x 、 p 2 _ y とする	p2_x , p2_y = map ( int , input ( ) . split ( ) )	x_p2 , y_p2 = map ( int , input ( ) . split ( ) ) <eos>
f を 1 だけ 減 少 させる	f -= 1	f -= 1 <eos>
N の 2 番目 から 、 つまり 末 尾 までの 部分 列 を 順に j として 、 繰 り 返す <blk> box の 末尾に j を追加する </blk>	for j in N [ 2 : ] : <blk> box . append ( j ) </blk>	for j in N [ 2 : ] : <blk> box . append ( j ) </blk> <eos>
A B を出力する	print ( AB )	print ( "B" ) <eos>
p の 24 番目 、 p の 5 番目 を p の 5 番目 、 p の 24 番目 とする	p [ 5 ] , p [ 24 ] = p [ 24 ] , p [ 5 ]	p [ 24 ] , p [ 24 ] = p [ 24 ] , p [ 24 ] <eos>
M を 2 の i 乗 だけ 増加 させる	M += 2 ** i	M += 2 ** i <eos>
入力された 文字列を "," で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ a 、 b 、 c 、 d とする	a , b , c , d = map ( int , input ( ) . split ( "," ) )	a , b , c , d = map ( int , input ( ) . split ( "," ) ) <eos>
0 を cat s の - c の i 番目 番目 にする	cats [ - c [ i ] ] = 0	ss [ i ] = 0 <eos>
parse ( list ( b ) , 0 )	parse ( list ( b ) , 0 )	parse ( list ( num_list ) , 0 ) <eos>
S の w 番目 を d の 絶対値 だけ 増加 させる	S [ w ] += abs ( d )	S [ w ] += abs ( d ) <eos>
16 進表記 c c 2 の 5 番目 から 、 つまり 末 尾 までの 部分 列 の 整数値 を b 2 とする	b2 = int ( cc2 [ 5 : ] , 16 )	b2 = int ( cc2 [ 5 : ] , 16 ) <eos>
re t を d f s ( i + 1 , rest _ number s . difference ( { r } ) , remainder ) だけ 増加 させる	ret += dfs ( i + 1 , rest_numbers . difference ( { r } ) , remainder )	ret += dfs ( i + 1 , <unk> ( s , r ) ) <eos>
c 1 を出力する	print ( c1 )	print ( c1 ) <eos>
r を d f s ( s - p n [ i ] , k -1 , i + 1 ) だけ 増加 させる	r += dfs ( s - pn [ i ] , k - 1 , i + 1 )	r += dfs ( n - i [ k - 1 ] , i + 1 ) <eos>
0 から 3 未 満 までの 数 列 を 順に q として 、 繰 り 返す	for q in range ( 3 ) :	for q in range ( 3 ) : <eos>
ar _ i j から ar _ i i を 引 いた 値を single _ row とする	single_row = ar_ij - ar_ii	<unk> = ar_i - ari <eos>
D を L で 割 った 余 り が 0 と 等しい とき 、	if D % L == 0 :	if D % L == 0 : <eos>
an s を 順に v 、 w として 、 繰 り 返す	for v , w in ans :	for v , w in ans : <eos>
node _ tmp の space から 1 を 引 いた 値 番目 、 node _ tmp の space 番目 を node _ tmp の space 番目 、 node _ tmp の space から 1 を 引 いた 値 番目 とする	node_tmp [ space ] , node_tmp [ space - 1 ] = node_tmp [ space - 1 ] , node_tmp [ space ]	node_tmp [ space ] , node_tmp [ space - 1 ] = node_tmp [ space - 1 ] , node_tmp [ space - 1 ] <eos>
入力された 文字列の 整数値 を p _ cal とする	p_cal = int ( input ( ) )	y_p1 = int ( input ( ) ) <eos>
0 から l im 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( lim ) :	for k in range ( lim ) : <eos>
Q を 順に s として 、 繰 り 返す	for s in Q :	for s in Q : <eos>
r に r を 掛け た 値に d に d を 掛け た 値 を加え た 値 から 2 に r を 掛け た 値に d を 掛け た 値に P I から math . f abs ( f ) を 引 いた 値の 余 弦 を 掛け た 値を 引 いた 値 の平方根 を r 2 とする	r2 = math . sqrt ( r * r + d * d - 2 * r * d * math . cos ( PI - math . fabs ( f ) ) )	I = math . sqrt ( r * r + d * d - 2 * f ( r ) - 2 * math . cos ( rad ) ) <eos>
table の x 番目の y 番目 が " >" と 等しい とき 、	if table [ x ] [ y ] == ">" :	if table [ x ] [ y ] == ">" : <eos>
0 から A 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を G とする	G = [ [ ] for i in range ( A ) ]	G = [ [ ] for i in range ( A ) ] <eos>
heappush ( p q , ( new _ f a re , v ) )	heappush ( pq , ( new_fare , v ) )	heappush ( pq , ( new_fare , v ) ) <eos>
a d j の r 番目 を 削 除 する	del adj [ r ]	del adj [ r ] <eos>
a を 順に in p として 、 繰 り 返す	for inp in a :	for inp in a : <eos>
A _ point s の逆 順 を 順に a p として 、 繰 り 返す	for ap in A_points [ : : - 1 ] :	for pa , p_a in A_points [ : - 1 ] : <eos>
a の 、 つまり 先頭から 9 番目 までの 4 間 隔 による 部分 列 内の k o ma の 出現 回数 が 3 と 等 し く または a の 2 番目 から 7 番目 までの 2 間 隔 による 部分 列 内の k o ma の 出現 回数 が 3 と 等しい とき 、 <blk> k o ma を返す </blk>	if a [ 0 : 9 : 4 ] . count ( koma ) == 3 or a [ 2 : 7 : 2 ] . count ( koma ) == 3 : <blk> return koma </blk>	if a [ : 4 ] . count ( koma ) == 3 or a [ 7 : 3 ] . count ( koma ) == 7 : <blk> return koma </blk> <eos>
line を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ x _ p 2 、 y _ p 2 とする	x_p2 , y_p2 = map ( int , line . split ( ) )	x_p2 , y_p2 = map ( int , line . split ( ) ) <eos>
a c の a x is 1 番目 に a c _ r を加え た 値を a c _ ed ge とする	ac_edge = ac [ axis1 ] + ac_r	adj_edge_cp = ac [ axis1 ] + a <eos>
tmp が re t より小さい とき 、	if tmp < ret :	if tmp < ret : <eos>
self の FLAGS を self の Ma s k s の m 番目 と の 排他的 論理和 にする	self . FLAGS ^ = self . Masks [ m ]	self . FLAGS ^ = self . Masks [ m ] <eos>
x i から x j を 引 いた 値の 2 乗 に y i から y j を 引 いた 値の 2 乗 を加え た 値の . 5 乗 を S の j 番目の i 番目 とする を S の i 番目の j 番目 にする	S [ i ] [ j ] = S [ j ] [ i ] = ( ( xi - xj ) ** 2 + ( yi - yj ) ** 2 ) ** . 5	S [ i ] [ j ] = S [ i ] [ j ] = ( xi - xj ) ** 2 + ( yi - yj ) ** 2 <eos>
3 が i の 長さ 以下 かどうか が 6 以下の とき 、	if 3 <= len ( i ) <= 6 :	if 3 <= len ( i ) <= 6 : <eos>
a c の先頭 を a c _ r とする	ac_r = ac [ 0 ]	<unk> = ac [ 0 ] <eos>
numbers の j 番目 が numbers の j から 1 を 引 いた 値 番目 より小さい とき 、	if numbers [ j ] < numbers [ j - 1 ] :	if numbers [ j ] < numbers [ j - 1 ] : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 のリスト を x とする	x = list ( map ( float , input ( ) . split ( ) ) )	x = list ( map ( float , input ( ) . split ( ) ) ) <eos>
0 を time _ re c の s 番目の s 番目の 1 番目 にする	time_rec [ s ] [ s ] [ 1 ] = 0	time_rec [ s ] [ 1 ] [ s ] = 0 <eos>
m at _ mul ( X , X , m ) を X とする	X = mat_mul ( X , X , m )	X = mat_mul ( X , m , X ) <eos>
( ( IN F ) からなる 列 の 0 から N 未 満 までの 数 列 の各要素 を i と し 、 N の 列 回 分 の 列 ) からなる 列 を S とする	S = [ [ INF ] * [ N for i in range ( N ) ] ]	S = [ [ INF ] * [ N for i in range ( N ) ] ] <eos>
入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 k とする	n , k = map ( int , input ( ) . strip ( ) . split ( ) )	k , n = map ( int , input ( ) . strip ( ) . split ( ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ n 、 t とする	n , t = input ( ) . split ( )	n , t = input ( ) . split ( ) <eos>
new を base だけ 増加 させる	new += base	new += base <eos>
0 から 、 つまり 無限 の 整数 列 の 長さ 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( len ( count ) ) :	for j in range ( len ( count ) ) : <eos>
n が x と 等しい かどうか が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if n == x == 0 : <blk> break </blk>	if n == x == 0 : <blk> break </blk> <eos>
真 を free とする	free = True	<unk> = True <eos>
defaultdict ( list ) を Q S とする	QS = defaultdict ( list )	QS = defaultdict ( list ) <eos>
辞書を re c とする	rec = dict ( )	rec = dict ( sorted ( carpets , [ c ] ) ) <eos>
0 から H 未 満 までの 数 列 の各要素 を i と し 、 readline ( ) を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト の 列 を A とする	A = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( H ) ]	A = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( H ) ] <eos>
'' を r とする	r = ''	r = '' <eos>
s を a で 割 った 値に 2.0 を 掛け た 値 を出力する	print ( s / a * 2.0 )	print ( s / a * 2.0 ) <eos>
n が m 以下の とき 、	if n <= m :	if n <= m : <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を x _ list とする	x_list = list ( map ( int , file_input . readline ( ) . split ( ) ) )	prime_list = list ( map ( int , file_input . readline ( ) . split ( ) ) ) <eos>
空 辞書を dict _ f req とする	dict_freq = { }	dict_freq = { } <eos>
無限 の 整数 列  内の j と 等しい 要素を 取り除く	count . remove ( j )	count . remove ( j ) <eos>
r 2 、 c 2 を r 、 c とする	r , c = r2 , c2	r , c = r2 , c2 <eos>
0 を by とする	by = 0	by = 0 <eos>
空 列 を an s _ list とする	ans_list = [ ]	<unk> = [ ] <eos>
r の 末尾に ( S の cur 番目 、 S の p 番目 ) の 組 を追加する	r . append ( ( S [ cur ] , S [ p ] ) )	r . append ( ( S [ cur ] , S [ p ] ) ) <eos>
y 1 から y 2 に 1 を加え た 値 未 満 までの 数 列 の各要素 を year と し 、 is _ leap _ year ( year ) の ときの year の 列 を leap _ years とする	leap_years = [ year for year in range ( y1 , y2 + 1 ) if is_leap_year ( year ) ]	<unk> = [ <unk> for year in range ( 1 , y2 + 1 ) if year ] <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト の 列 を a とする	a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ]	a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <eos>
s s の i 番目の とき 、	if ss [ i ] :	if s [ i ] : <eos>
を num とする	num = ""	num = "" <eos>
max _ high が n より小さい とき 、	if max_high < n :	if high_max < n : <eos>
t が 0 と 等しい とき 、	if t == 0 :	if t == 0 : <eos>
0 から A の 長さ から 1 を 引 いた 値 未 満 までの 数 列 の各要素 を i と し 、 A の i 番目 に A の i に 1 を加え た 値 番目 を加え た 値を 10 で 割 った 余 り の 列 を A とする	A = [ ( A [ i ] + A [ i + 1 ] ) % 10 for i in range ( len ( A ) - 1 ) ]	A = [ ( A [ i ] + A [ i + 1 ] ) % 10 for i in range ( len ( A ) - 1 ) ] <eos>
空 列 を cross とする	cross = [ ]	cross = [ ] <eos>
s a を 3 だけ 増加 させる	sa += 3	sa += 3 <eos>
total _ a mount を n で 割 った 商 を出力する	print ( total_amount // n )	print ( total_amount // n ) <eos>
0.0 001 を E P S とする	EPS = 0.0001	EPS = 0.0 <eos>
x を 10 で 割 った 商 を x とする	x = x // 10	x = x // 10 <eos>
map _ in p の y から 1 を 引 いた 値 番目の x 番目の とき 、	if map_inp [ y - 1 ] [ x ] :	if map_inp [ y - 1 ] [ x ] : <eos>
C を s hop _ name とする	shop_name = "C"	shop_name = "C" <eos>
0 から y 未 満 までの 数 列 を 順に _ として 、 繰 り 返す	for _ in range ( y ) :	for _ in range ( y ) : <eos>
a の i 番目の j 番目 が '.' と 等しくない 間 、 次 を 繰 り 返す	while a [ i ] [ j ] != '.' :	while a [ i ] [ j ] != '.' : <eos>
-1 を INVAL ID とする	INVALID = - 1	<unk> = - 1 <eos>
j を n _ an s とする	n_ans = j	ans_n = j <eos>
r を y とする	y = r	y = r <eos>
集合 を Y とする	Y = set ( )	Y = set ( ) <eos>
b から m を 引 いた 値を an s とする	ans = b - m	ans = b - m <eos>
無限 の 整数 列 を number の 長さ で 割 った 値が 0.5 より小さい とき 、 <blk> " Y ES " を出力する </blk>	if count / len ( number ) < 0.5 : <blk> print ( "YES" ) </blk>	if count / len ( number ) < 0.5 : <blk> print ( "YES" ) </blk> <eos>
j が start から 1 を 引 いた 値 と 等しい とき 、	if j == start - 1 :	if j == start - 1 : <eos>
X を status とする	status = "X"	status = "X" <eos>
s の先頭 を取り出し た 値 の浮動小数点数 を b とする	b = float ( s . pop ( ) )	b = float ( s . pop ( ) ) <eos>
p の j 番目 が s の i 番目 と 等しい とき 、	if p [ j ] == s [ i ] :	if p [ j ] == s [ i ] : <eos>
C が 0 と 等しい とき 、	if C == 0 :	if C == 0 : <eos>
a 、 d は グローバル変数 とする	global a , d	global a , d <eos>
sum に a ce を加え た 値が 21 より大きい とき 、 <blk> 0 を出力する </blk>	if sum + ace > 21 : <blk> print ( 0 ) </blk>	if sum + ace > 21 : <blk> print ( 0 ) </blk> <eos>
d ic の n m 番目 を buf の 、 つまり 現在の 日時 番目 にする	buf [ now ] = dic [ nm ]	dic [ now ] = dic [ n ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ x 、 y とする	x , y = map ( int , input ( ) . split ( ) )	x , y = map ( int , input ( ) . split ( ) ) <eos>
table の c から j を 引 いた 値 番目の j 番目 が 0 より大きい とき 、	if table [ c - j ] [ j ] > 0 :	if table [ c - j ] [ j ] > 0 : <eos>
( '0' ) からなる 列 の w に 2 を加え た 値 回 分 の 列 を are a _ map とする	area_map = [ '0' ] * ( w + 2 )	area_map = [ '0' ] * ( w + 2 ) <eos>
\\\\\ write ( " yes \\\\ \\\\ n " ) \\\\\	\\\\\write ( "yes\\\\\\\\n" )\\\\\	\\\\\write ( <unk> )\\\\ <eos>\
A _ s を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の 組 を A とする	A = tuple ( map ( int , A_s . split ( ) ) )	A = tuple ( map ( int , <unk> . split ( ) ) ) <eos>
sys の stdin の各要素 に 整数 を 適用 した 列 のリスト を T とする	T = list ( map ( int , sys . stdin ) )	T = list ( map ( int , sys . stdin ) ) <eos>
b の 4 に f ( r ) を加え た 値 番目 を 1 だけ 増加 させる	b [ 4 + f ( r ) ] += 1	b [ 4 + f [ r ] ] += 1 <eos>
line を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ s 、 t 、 w とする	s , t , w = map ( int , line . split ( ) )	s , t , w = map ( int , line . split ( ) ) <eos>
a から b を 引 いた 値を d とする	d = a - b	d = a - b <eos>
x y _ diff の各要素 を i と し 、 i の 2 乗 の 列 の 総 和 の 0.5 乗 を E u _ d とする	Eu_d = sum ( [ i ** 2 for i in xy_diff ] ) ** 0.5	<unk> = sum ( [ pow ( i ** 2 for i , 2 ) for i in xy_diff ] ) <eos>
'' を k とする	k = ''	k = '' <eos>
j が 0 より大きい とき 、	if j > 0 :	if j > 0 : <eos>
A を ソート した 列 を 順に i として 、 繰 り 返す	for i in sorted ( A ) :	for i in sorted ( A ) : <eos>
code を 順に in p として 、 繰 り 返す	for inp in code :	for inp in code : <eos>
y を a を b で 割 った 商 に x を 掛け た 値 だけ 減 少 させる	y -= ( a // b ) * x	y -= a // b * x <eos>
辞書の key t b l の j 番目 番目 が 0 より大きい とき 、 <blk> key t b l の j 番目 、 辞書の key t b l の j 番目 番目 を出力する </blk>	if dict [ keytbl [ j ] ] > 0 : <blk> print ( keytbl [ j ] , dict [ keytbl [ j ] ] ) </blk>	if dict [ j ] > 0 : <blk> print ( <unk> [ j ] , keytbl [ j ] ) </blk> <eos>
s witch の 末尾に s witch の m 番目の 各 要素を dist と し 、 dist に i を加え た 値の 列 を追加する	switch . append ( [ dist + i for dist in switch [ m ] ] )	switch [ m ] . append ( dist + dist [ i ] ) <eos>
L が " 0 " と 等しい とき 、	if L == "0" :	if L == "0" : <eos>
right Child を self の right Child にする	self . rightChild = rightChild	self . rightChild = rightChild <eos>
0 を max _ do w n とする	max_down = 0	max_down = 0 <eos>
Point ( x 1 , y 1 ) を P 1 とする	P1 = Point ( x1 , y1 )	P1 = Point ( x1 , y1 ) <eos>
' K UP C ' の各要素 を i と し 、 s 内の i の 出現 回数 の 列 の 最小 値 を出力する	print ( min ( [ s . count ( i ) for i in 'KUPC' ] ) )	print ( min ( [ min ( s . count ( i ) for i in CS ] ) ) <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を line とする	line = list ( map ( int , f_i . readline ( ) . split ( ) ) )	line = list ( map ( int , f_i . readline ( ) . split ( ) ) ) <eos>
t を time だけ 増加 させる	t += time	t += time <eos>
n 1 が g と 等しい とき 、	if n1 == g :	if n1 == g : <eos>
n に 1 を加え た 値 を出力する	print ( n + 1 )	print ( n + 1 ) <eos>
c 1 が 0 と 等しくない 間 、 次 を 繰 り 返す	while c1 != 0 :	while c1 != 0 : <eos>
0 を self の de gree にする	self . degree = 0	self . degree = 0 <eos>
d p の j 番目の k 番目 、 0 の 最大 値に s の k に 1 を加え た 値 番目 を加え た 値 から s の j 番目 を 引 いた 値を d p の j 番目の k 番目 にする	dp [ j ] [ k ] = max ( dp [ j ] [ k ] , 0 ) + s [ k + 1 ] - s [ j ]	dp [ k ] [ j ] = max ( dp [ j ] [ k ] , max ( s [ k ] [ k ] [ j - 1 ] + d [ j ] ) ) <eos>
reconstruct ( pre order [ node _ div + 1 : ] , in order [ node _ div + 1 : ] , post order )	reconstruct ( preorder [ node_div + 1 : ] , inorder [ node_div + 1 : ] , postorder )	<unk> ( preorder [ : 1 ] + inorder , postorder + 1 ) <eos>
in p が ( ' -1 ' ) からなる 列 の 4 回 分 の 列 と 等しい とき 、	if inp == [ '-1' ] * 4 :	if inp == [ - 1 ] * 4 : <eos>
N を 順に i として 、 繰 り 返す <blk> num を first _ dict の i 番目 だけ 増加 させる </blk>	for i in N : <blk> num += first_dict [ i ] </blk>	for i in N : <blk> first [ num ] += <unk> </blk> <eos>
a に b を 掛け た 値に c の 正 弦 を 掛け た 値に 0.5 を 掛け た 値を s とする	s = a * b * sin ( c ) * 0.5	s = a * b * math . sin ( c ) * math . sin ( c ) <eos>
y に r を加え た 値が H より大きい とき 、	if y + r > H :	if y + r > H : <eos>
d の s 番目 を 順に item として 、 繰 り 返す	for item in d [ s ] :	for item in d [ s ] : <eos>
0 から out の 長さ 未 満 までの 数 列 を 順に k として 、 繰 り 返す	for k in range ( len ( out ) ) :	for k in range ( len ( out ) ) : <eos>
0 を er とする	er = 0	er = 0 <eos>
a で ないとき 、	if not a :	if not a : <eos>
n が mp に含まれる とき 、	if n in mp :	if n in mp : <eos>
m から 1 を 引 いた 値を i とする	i = m - 1	i = m - 1 <eos>
s u から s の i 番目 を 引 いた 値 から s の i i 番目 を 引 いた 値が m 以上の とき 、	if su - s [ i ] - s [ ii ] >= m :	if su - s [ i ] - s [ i ] >= m : <eos>
0 から N 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 真 の 列 を prime とする	prime = [ True for i in range ( N ) ]	prime = [ True for i in range ( N ) ] <eos>
re c ( n , s , 0 ) を出力する	print ( rec ( n , s , 0 ) )	print ( rec ( n , s , 0 ) ) <eos>
u が v より大きい とき 、 <blk> u と v を 入れ替え る </blk>	if u > v : <blk> u , v = v , u </blk>	if u > v : <blk> u , v = u , u </blk> <eos>
L S の j 番目 を 展開 し 、 それぞれ q 0 、 q 1 とする	q0 , q1 = LS [ j ]	q0 , q1 = LS [ j ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ s 、 f とする	s , f = [ int ( i ) for i in input ( ) . split ( ) ]	s , f = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
辞書を un s al v age d とする	unsalvaged = dict ( )	unsalvaged = dict ( ) <eos>
2 から N の 長さ 未 満 までの 数 列 を 順に l として 、 繰 り 返す	for l in range ( 2 , len ( N ) ) :	for l in range ( 2 , len ( N ) ) : <eos>
u と 1 を cd だけ 左 シフト した 値の 論理 積 の とき 、	if u & ( 1 << cd ) :	if u & ( 1 << cd ) : <eos>
0 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( n ) :	for i in range ( n ) : <eos>
x の m から 1 を 引 いた 値 番目の とき x の 総 和 に 100 から p を 引 いた 値を 掛け た 値を x の m から 1 を 引 いた 値 番目 で 割 った 商 、 そうでなければ 0 を出力する	print ( sum ( x ) * ( 100 - p ) // x [ m - 1 ] if x [ m - 1 ] else 0 )	print ( x [ m - 1 ] * 100 // m [ x - 1 ] if x [ 0 ] ) // 100 else 0 ) <eos>
file _ input から 読み込んだ 一行 を line とする	line = file_input . readline ( )	line = file_input . readline ( ) <eos>
t prime s の i 番目の とき 、	if tprimes [ i ] :	if <unk> [ i ] : <eos>
0 から l 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( l ) :	for j in range ( l ) : <eos>
q の 0 番目 が '1' と 等しい とき 、 <blk> d q の in d 番目の 先頭 を出力する </blk>	if q [ 0 ] == '1' : <blk> print ( dq [ ind ] [ 0 ] ) </blk>	if q [ 0 ] == '1' : <blk> print ( q [ d ] [ 0 ] ) </blk> <eos>
( 1 、 2 、 4 、 8 、 16 、 32 、 64 、 128 、 256 、 512 ) からなる 列 を w _ a とする	w_a = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ]	a = [ 1 , 2 , 4 , 8 , 16 , 128 , 256 , 512 ] <eos>
c を d の a 番目の b 番目 にする	d [ a ] [ b ] = c	d [ a ] [ b ] = c <eos>
comp _ re c が no _ r out e と 等しくない とき 、	if comp_rec != no_route :	if <unk> != no_route : <eos>
St e p _ Check ( block ) の とき 、	if Step_Check ( block ) :	if <unk> ( block ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を num s とする	nums = list ( map ( int , input ( ) . split ( ) ) )	nums = list ( map ( int , input ( ) . split ( ) ) ) <eos>
ed ge s の num 番目 を 順に ed ge として 、 繰 り 返す	for edge in edges [ num ] :	for edge in edges [ num ] : <eos>
l の i 番目の j から 1 を 引 いた 値 から j に 2 を加え た 値 までの 部分 列 の 総 和 が 0 より大きい とき 、	if sum ( l [ i ] [ j - 1 : j + 2 ] ) > 0 :	if sum ( l [ i - j ] ) > 0 : <eos>
( 0 ) からなる 列 の n 回 分 の 列 、 ( 0 ) からなる 列 の n 回 分 の 列 を c n t 、 v max とする	cnt , vmax = [ 0 ] * n , [ 0 ] * n	vmax , cnt = [ 0 ] * n , [ 0 ] * nmax <eos>
data の 3 番目 を 1 だけ 増加 させる	data [ 3 ] += 1	data [ 3 ] += 1 <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 input ( ) . split ( ) の各要素 に int を 適用 した 列 のリスト の先頭 を 除 いた 部分 列 の集合 の 列 を a とする	a = [ set ( list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ) for _ in range ( n ) ]	a = set ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <eos>
x に 1 を加え た 値 、 y から 2 を 引 いた 値 、 depth に 1 を加え た 値 、 max _ depth において 正規表現 table が 最初 にマッチする 位置 の とき 、	if search ( table , x + 1 , y - 2 , depth + 1 , max_depth ) :	if search ( table , x + 1 , y - 2 , depth + 1 , max_depth ) : <eos>
cur s ol _ W を 1 だけ 増加 させる	cursol_W += 1	cursol_W += 1 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ x 、 y 、 b 、 p とする	x , y , b , p = [ int ( i ) for i in input ( ) . split ( ) ]	x , y , b , p = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
make _ list ( H ) を h _ list とする	h_list = make_list ( H )	<unk> = make_list ( H ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を b とする	b = list ( map ( int , input ( ) . split ( ) ) )	b = list ( map ( int , input ( ) . split ( ) ) ) <eos>
p _ f latten の 最大 値 を出力する	print ( max ( p_flatten ) )	print ( max ( p_flatten ) ) <eos>
0 から n m 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( nm ) :	for i in range ( n ) : <eos>
x y r 1 を展開し 、 それぞれ x 1 、 y 1 、 r 1 とする	x1 , y1 , r1 = xyr1	x1 , y1 , r1 = x1 <eos>
t の 長さ から x を 引 いた 値が b 以下の とき 、 <blk> 繰り返し を 中断 する </blk>	if len ( t ) - x <= b : <blk> break </blk>	if len ( t ) - x <= b : <blk> break </blk> <eos>
1 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> 改行 せずに ' % d ' を a の i 番目 で 割 った 余 り を出力する </blk>	for i in range ( 1 , n ) : <blk> print ( ' %d' % a [ i ] , end = '' ) </blk>	for i in range ( 1 , n ) : <blk> print ( <unk> % a [ i ] , end = '' ) </blk> <eos>
self の vec t or の x 座 標 に other の vec t or の x 座 標 を 掛け た 値に self の vec t or の y 座 標 に other の vec t or の y 座 標 を 掛け た 値 を加え た 値を返す	return self . vector . x * other . vector . x + self . vector . y * other . vector . y	return self . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector . vector self . vector . vector . vector . vector .
Node ( num , -1 , children ) を node とする	node = Node ( num , - 1 , children )	node = Node ( num , - 1 , children ) <eos>
check ed の n u 番目 で ないとき 、 <blk> d f s ( n u ) </blk>	if not checked [ nu ] : <blk> dfs ( nu ) </blk>	if not checked [ u ] : <blk> dfs ( n ) </blk> <eos>
r の 絶対値 が E P S より 小さく または r 2 の 絶対値 が E P S より小さい とき 、	if math . fabs ( r ) < EPS or math . fabs ( r2 ) < EPS :	if abs ( r ) < EPS or abs ( S < r2 ) or abs ( S < EPS : <eos>
b r id ge _ find ing ( G , N ) を展開し 、 それぞれ G 1 、 L B とする	G1 , LB = bridge_finding ( G , N )	G , G1 = <unk> ( L , B ) <eos>
r 0 を 1 を C の i 番目の x 1 番目の 順序 数 から ' A ' の順序 数 を 引 いた 値 だけ 左 シフト した 値 と の 論理和 にする	r0 | = 1 << ( ord ( C [ i ] [ x1 ] ) - ord ( 'A' ) )	r0 | = 1 << ( ord ( C [ x1 ] [ i ] ) - ord ( 'A' ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 して の 複素数 を c とする	c = complex ( * map ( float , input ( ) . split ( ) ) )	c = complex ( * float ( input ( ) . split ( ) ) <eos>
current _ time に new _ dest から cur _ h t を 引 いた 値の 絶対値 を v で 割 った 値 を加え た 値を at とする	at = current_time + abs ( new_dest - cur_ht ) / v	at = abs ( current_time + cur_ht - new_dest ) / v <eos>
ly 、 l x 、 li の 要素を それぞれ 組 に した 列 のリスト を P とする	P = list ( zip ( ly , lx , li ) )	P = list ( zip ( ly , li ) ) <eos>
( 1 から n 未 満 までの 数 列 の各要素 を i と し 、 i の 2 乗 を n で 割 った 余 り の 列 ) の集合 を rest とする	rest = { [ i ** 2 % n for i in range ( 1 , n ) ] }	rest = set ( [ ( n ) ** 2 for i in range ( 1 , n ) ] ) % n <eos>
( x に i を加え た 値 、 y に j を加え た 値 ) の 組 が a に 含まれない とき 、 <blk> 0 を a の ( x に i を加え た 値 、 y に j を加え た 値 ) の 組 番目 にする </blk>	if ( x + i , y + j ) not in a : <blk> a [ ( x + i , y + j ) ] = 0 </blk>	if ( x + i , y + j ) not in a : <blk> a [ i + j + x ] = 0 </blk> <eos>
0 から d 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( d ) :	for j in range ( d ) : <eos>
0 を re t val の先頭に する	retval [ 0 ] = 0	retval [ 0 ] = 0 <eos>
x から r を 引 いた 値が 0 より 小さく または y から r を 引 いた 値が 0 より 小さく または x に r を加え た 値が W より大きく または y に r を加え た 値が H より大きい とき 、 <blk> ' No ' を出力する </blk>	if ( x - r < 0 or y - r < 0 or x + r > W or y + r > H ) : <blk> print ( 'No' ) </blk>	if x - r < 0 or y - r + x < W or y - r > 0 or y + r > 0 : <blk> print ( "Yes" ) </blk> <eos>
a の 10 番目 を v 1 とする	v1 = a [ 10 ]	v1 = a [ 10 ] <eos>
p の 1 番目 を 1 だけ 増加 させる	p [ 1 ] += 1	p [ 1 ] += 1 <eos>
x 1 に x 2 を 掛け た 値 から y 1 に y 2 を 掛け た 値を 引 いた 値 から z 1 に z 2 を 掛け た 値を 引 いた 値 から w 1 に w 2 を 掛け た 値を 引 いた 値を a 1 とする	a1 = x1 * x2 - y1 * y2 - z1 * z2 - w1 * w2	a1 = x1 * x2 - y1 * y2 - z1 * z2 - w1 * z2 <eos>
S は グローバル変数 とする	global S	global S <eos>
0 から encode d の 長さ を 5 で 割 った 商 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( encoded ) // 5 ) :	for i in range ( len ( encoded ) // 5 ) : <eos>
max val に 1 を加え た 値を m とする	m = maxval + 1	m = max_val + 1 <eos>
l _ C を 1 だけ 増加 させる	l_C += 1	l_C += 1 <eos>
in p  の " 1 " と 等しい 要素の 最初の 位置 が in d と 等しい とき 、	if inp . index ( "1" ) == ind :	if inp . index ( "1" ) == ind : <eos>
0 から l から 2 を 引 いた 値 から k を 引 いた 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( l - 2 - k ) :	for i in range ( l - 2 - k - i ) : <eos>
V を 順に X 、 Y として 、 繰 り 返す	for X , Y in V :	for X , Y in V : <eos>
tb l に x を 追加した 集 まり	tbl . add ( x )	tbl . add ( x ) <eos>
0 から n 未 満 までの 数 列 を 順に w として 、 繰 り 返す	for w in range ( n ) :	for w in range ( n ) : <eos>
a に b を加え た 値が c 以下 または b に c を加え た 値が a 以下 または c に a を加え た 値が b 以下の とき 、	if a + b <= c or b + c <= a or c + a <= b :	if a + b <= c or c + a <= b or c + a <= a <= b : <eos>
偽 を d neg の i から j を 引 いた 値に 7 を加え た 値 番目 にする	dneg [ i - j + 7 ] = False	dneg [ i - 7 + 7 ] = False <eos>
入力された 文字列の 整数値 を a _ i とする	a_i = int ( input ( ) )	a_i = int ( input ( ) ) <eos>
0 、 255 、 0 を R 、 G 、 B とする	R , G , B = 0 , 255 , 0	R , G , B = 0 , 255 , 0 <eos>
C を 円 周 率 を 1 80 で 割 った 値 倍 にする	C *= math . pi / 180	C *= math . pi / 180 <eos>
key を a の j に 1 を加え た 値 番目 にする	a [ j + 1 ] = key	a [ j + 1 ] = key <eos>
an s の 末尾に heap P op _ max ( S ) を追加する	ans . append ( heapPop_max ( S ) )	ans . append ( heap ) <eos>
x を パラメータ として ( x の 3 番目 、 limit _ day の 最小 値 、 - x の 2 番目 ) の 組 を返す 関数を key として 逆 順に b r id ge s を ソート する	bridges . sort ( key = lambda x : ( min ( x [ 3 ] , limit_day ) , - x [ 2 ] ) , reverse = True )	bridges . sort ( key = lambda x : ( min ( x [ 3 ] , reverse = True , - x [ 2 ] ) ) ) <eos>
super ( ) . __ init __ ( p t 1 , p t 2 )	super ( ) . __init__ ( pt1 , pt2 )	init ( . __init__ ( pt1 , pt2 . pt2 ) ) <eos>
comp _ an s の 末尾に an s の値 の集まり を追加する	comp_ans . append ( ans . values ( ) )	<unk> . append ( ans . values ( ) ) <eos>
c 2 が 1 より小さい とき 、 <blk> 1 を c 2 とする </blk>	if c2 < 1 : <blk> c2 = 1 </blk>	if c2 < 1 : <blk> c1 = c1 </blk> <eos>
i が n より小さい とき 、 <blk> a の i 番目 を t とする </blk>	if i < n : <blk> t = a [ i ] </blk>	if i < n : <blk> t = a [ i ] </blk> <eos>
arr の id x 番目 を 削 除 する	del arr [ idx ]	del arr [ idx ] <eos>
ERROR : can ' t remove ed ge 、 node 1 、 " - >" 、 node 2 を出力する	print ( "ERROR: can't remove edge" , node1 , "->" , node2 )	print ( <unk> <unk> <unk> <unk> , - 1 , - 1 , <unk> ) <eos>
0 から matrix の 長さ 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( len ( matrix ) ) :	for j in range ( len ( matrix ) ) : <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 h x 、 h y 、 d x 、 d y とする	n , hx , hy , dx , dy = map ( int , f_i . readline ( ) . split ( ) )	dx , dy , h , dx , dy = map ( int , f_i . readline ( ) . split ( ) ) <eos>
file _ input から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ c x 、 c y 、 r とする	cx , cy , r = map ( int , file_input . readline ( ) . split ( ) )	x , y , r = map ( int , file_input . readline ( ) . split ( ) ) <eos>
a 35 が MAX より大きい とき 、 <blk> 繰り返し を 中断 する </blk>	if a35 > MAX : <blk> break </blk>	if <unk> > MAX : <blk> break </blk> <eos>
R の i から k を 引 いた 値 番目 を R の i に k を加え た 値 番目 にする	R [ i + k ] = R [ i - k ]	R [ i + k ] = R [ i - k ] <eos>
0 から x 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( x ) :	for i in range ( x ) : <eos>
numbers を g cd で 集 約 した 列 を返す	return reduce ( gcd , numbers )	return reduce ( gcd , numbers ) <eos>
num _ org が 9 6 より大きく かつ num _ org が 123 より小さい とき 、	if num_org > 96 and num_org < 123 :	if org_num > 9 and org_num < ord ( 'A' ) : <eos>
空 列 を 辞書の k i 番目 にする	dict [ ki ] = [ ]	dict [ ki ] = [ ] <eos>
X から s 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( X , s ) :	for i in range ( X , s ) : <eos>
self の score の浮動小数点数 が other の score の浮動小数点数 より小さい かどうか を返す	return float ( self . score ) < float ( other . score )	return float ( self . score ) < float ( other . score ) <eos>
word が index に 含まれない とき 、	if word not in index :	if word not in index : <eos>
a d j の u 番目 を 順に v c 、 v として 、 繰 り 返す	for vc , v in adj [ u ] :	for v , c in adj [ u ] : <eos>
2 から a を 引 いた 値を返す	return ( 2 - a )	return 2 - a <eos>
s が 1 を v だけ 左 シフト した 値 から 1 を 引 いた 値 と 等 し く かつ g が 0 と 等しい とき 、	if s == ( 1 << v ) - 1 and g == 0 :	if s == 1 << v and g == 0 and g == 0 : <eos>
入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の集合 を s 1 とする	s1 = set ( map ( int , input ( ) . strip ( ) . split ( ) ) )	s1 = set ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <eos>
0 を f e e とする	fee = 0	fee = 0 <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を a とする </blk>	try : <blk> a = list ( map ( int , input ( ) . split ( ',' ) ) ) </blk>	try : <blk> a = list ( map ( int , input ( ) . split ( ',' ) ) ) </blk> <eos>
e 1 を g で 割 った 商 、 o 1 を g で 割 った 商 を e 1 、 o 1 とする	e1 , o1 = e1 // g , o1 // g	e1 , o1 = e1 // g , o1 // o1 // o1 <eos>
0 を m とする	m = 0	m = 0 <eos>
0 から card の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( card ) ) :	for i in range ( len ( card ) ) : <eos>
n を b だけ 増加 させる	n += b	n += b <eos>
s を b の n から i を 引 いた 値 番目 だけ 増加 させる	s += b [ n - i ]	s += b [ n - i ] <eos>
p o c k et _ page r ( line . strip ( ) ) を出力する	print ( pocket_pager ( line . strip ( ) ) )	print ( <unk> ( line . strip ( ) ) ) <eos>
M e _ w を 1 だけ 減 少 させる	Me_w -= 1	Me_w -= 1 <eos>
- b c の先頭に ab の 1 番目 を 掛け た 値 から b c の 1 番目 に ab の先頭 を 掛け た 値を 引 いた 値を c r s _ b とする	crs_b = - ( bc [ 0 ] * ab [ 1 ] - bc [ 1 ] * ab [ 0 ] )	<unk> = - b [ 0 ] * ab [ 1 ] - bc [ 1 ] * bc [ 0 ] <eos>
'{: f } ' を 書式 として an s で 整 形 した 文字列 を出力する	print ( '{:f}' . format ( ans ) )	print ( '{:.8f}' . format ( ans ) ) <eos>
op の先頭 が ' replace ' と 等しい とき 、	if op [ 0 ] == 'replace' :	if op [ 0 ] == "replace" : <eos>
ll が rl より小さい とき 、	if ll < rl :	if ll < rl : <eos>
0 を d p の先頭に する	dp [ 0 ] = 0	dp [ 0 ] [ 0 ] = 0 <eos>
k a is u を返す	return kaisu	return kaisu <eos>
Y に b を 掛け た 値に x を 掛け た 値に d に a を 掛け た 値に X を 掛け た 値 を加え た 値を g で 割 った 商 、 d に Y を g で 割 った 商 を 掛け た 値を x 、 d とする	x , d = ( Y * b * x + d * a * X ) // g , d * ( Y // g )	X , Y = Y * b + d * x , d * g // g , d * g <eos>
無限大 の j 番目 が -1 と 等しくない とき 、 <blk> e の i 番目の 末尾に ( j 、 無限大 の j 番目 ) からなる 列 を追加する </blk>	if inf [ j ] != - 1 : <blk> e [ i ] . append ( [ j , inf [ j ] ] ) </blk>	if inf [ j ] != - 1 : <blk> e [ i ] . append ( [ j ] , [ j ] ) </blk> <eos>
空 列 を g 4 とする	g4 = [ ]	g4 = [ ] <eos>
d f s ( pos + 1 , t + 1 , sum + pos )	dfs ( pos + 1 , t + 1 , sum + pos )	dfs ( pos + 1 , t + 1 , sum ) <eos>
number を j だけ 増加 させる	number += j	number += j <eos>
self の cursor の next を self の cursor にする	self . cursor = self . cursor . next	self . cursor . cursor = self . cursor . next <eos>
k p rt の先頭 を p rt とする	prt = kprt [ 0 ]	prt = kprt [ 0 ] <eos>
65 が point 以下の とき 、 <blk> point が 80 以上の とき " A " 、 そうでなければ " B " を出力する </blk>	if 65 <= point : <blk> print ( "A" if point >= 80 else "B" ) </blk>	if 65 <= point : <blk> print ( "A" if A >= 80 else "" ) </blk> <eos>
n から 1 を 引 いた 値 から 1 未 満 までの -1 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( n - 1 , 1 , - 1 ) :	for i in range ( n - 1 , 1 , - 1 ) : <eos>
si k i の 末尾に num を追加する	siki . append ( num )	siki . append ( num ) <eos>
A の 先頭の 4 番目 かつ d f s ( 0 , 4 , -1 , -1 , -1 , -1 ) の とき 、	if A [ 0 ] [ 4 ] and dfs ( 0 , 4 , - 1 , - 1 , - 1 , - 1 ) :	if A [ 0 ] [ 4 ] and f ( s [ 0 ] , - 1 , - 1 , - 1 , - 1 ) : <eos>
1 から st one s の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , len ( stones ) ) :	for i in range ( 1 , len ( stones ) ) : <eos>
0 から 4 未 満 までの 数 列 を 順に x として 、 繰 り 返す	for x in range ( 4 ) :	for x in range ( 4 ) : <eos>
x の an s 番目 を そうでなければ 、 とする 0 を x の an s 番目 にする	else = x [ ans ] x [ ans ] = 0	ans [ x ] = ans [ 0 ] = x = x <eos>
ソートされた 順序 を 保 った まま n を p r に 挿入 できる 最後の 位置 を n とする	n = bisect . bisect_right ( pr , n )	n = bisect . bisect_right ( p , n ) <eos>
n y が g y と 等 し く かつ n x が g x と 等しい とき 、	if ny == gy and nx == gx :	if ny == gy and gx == gx : <eos>
C o m ( a tar i [ j ] , s ) が 、 つまり 真 と 等しい とき 、	if Com ( atari [ j ] , s ) == True :	if <unk> ( a [ i ] , s ) == True : <eos>
b ub ble ( a , n )	bubble ( a , n )	bubble ( a , n ) <eos>
r に C を 掛け た 値に c を加え た 値を p とする	p = r * C + c	p = r * C + c <eos>
project ( x , y ) を展開し て を出力する	print ( * project ( x , y ) )	print ( * x ( y , ) ) <eos>
空 列 を second とする	second = [ ]	second = [ ] <eos>
self . is Full ( ) の とき 、	if self . isFull ( ) :	if self . <unk> ( ) : <eos>
真 を c ol の j 番目 にする	col [ j ] = True	col [ j ] = True <eos>
s に " 1 " を加え た 値を s とする	s = s + "1"	s = s + "1" <eos>
self の top を 1 だけ 増加 させる	self . top += 1	self . top += 1 <eos>
B it Flag ( digits ) を b f とする	bf = BitFlag ( digits )	<unk> = <unk> ( ) <eos>
1 を i i とする	ii = 1	ii = 1 <eos>
self . d f s ( to , t , min ( f , cap ) ) を d とする	d = self . dfs ( to , t , min ( f , cap ) )	d = self . dfs ( to , min ( t , cap ) ) <eos>
31 + 2 9 に 31 を加え た 値に 30 を加え た 値に 31 を加え た 値に 30 を加え た 値に D を加え た 値を days とする	days = 31 + 29 + 31 + 30 + 31 + 30 + D	days = 31 + 29 + 31 + 31 + 31 + D <eos>
x の間 、 次 を 繰 り 返す	while x :	while x : <eos>
score _ a 、 score _ b を出力する	print ( score_a , score_b )	print ( score_a , score_b ) <eos>
( 1 、 0 、 -1 、 0 ) からなる 列 を D Y とする	DY = [ 1 , 0 , - 1 , 0 ]	Y = [ 1 , 0 , - 1 , 0 ] <eos>
t _ c ar p et s の 長さが 1 と 等しい とき 、	if len ( t_carpets ) == 1 :	if len ( t_carpets ) == 1 : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を op e とする	ope = list ( map ( int , input ( ) . split ( ) ) )	ope = list ( map ( int , input ( ) . split ( ) ) ) <eos>
y に m を加え た 値に d を加え た 値の 整数値 を date とする	date = int ( y + m + d )	date = int ( y + m + d ) <eos>
D を出力する	print ( "D" )	print ( D ) <eos>
tree の x 番目の 1 番目 を そうでなければ 、 とする	else = tree [ x ] [ 1 ]	else = tree [ x ] [ 1 ] <eos>
next _ c ity が p と 等しい とき 、	if next_city == p :	if next_cp == p : <eos>
cp _ l の 末尾に e 2 _ c p の -2 番目 を追加する	cp_l . append ( e2_cp [ - 2 ] )	cp_l . append ( e2_cp [ - 2 ] ) <eos>
i 、 j に 1 を加え た 値 を出力する	print ( i , j + 1 )	print ( i , j + 1 ) <eos>
, を 間 に入れ て ( self の top 、 self の f r on t 、 self の right 、 self の left 、 self の be hi nd 、 self の bottom ) の 組 の各要素 を i と し 、 i を object として 整数の 列 を 連結 した 文字列 を返す	return "," . join ( [ str ( object = i ) for i in ( self . top , self . front , self . right , self . left , self . behind , self . bottom ) ] )	return ( " . join ( [ self . top , self . behind , self . bottom , self . left , self . bottom , self . bottom ( self . bottom , self . bottom , self . bottom , self . bottom , self . bottom
1 を m ark ed の y 番目の x 番目 にする	marked [ y ] [ x ] = 1	marked [ y ] [ x ] = 1 <eos>
a 0 の imag が b i の imag より小さい かどうか が a 1 の imag より小さい とき 、	if a0 . imag < bi . imag < a1 . imag :	if a0 . imag < b . imag < a1 . imag : <eos>
l から 1 を 引 いた 値を 2 で 割 った 商 を ll とする	ll = ( l - 1 ) // 2	ll = l - 1 // 2 <eos>
真 を eof とする	eof = True	eof = True <eos>
- 10 の 9 乗 を r i ek i とする	rieki = - ( 10 ** 9 )	<unk> = - 10 ** 9 <eos>
s の 整数値 から l の 整数値 を 引 いた 値の 文字列を 長さ 4 になるように '0' 左 詰 め した 文字列を n とする	n = str ( int ( s ) - int ( l ) ) . zfill ( 4 )	n = str ( int ( s ) - int ( l ) ) . zfill ( 4 ) <eos>
'% . 10 f ' を d p の n 番目 で 割 った 余 り を出力する	print ( '%.10f' % dp [ n ] )	print ( <unk> % dp [ n ] ) <eos>
q の先頭に command の 1 番目 を追加する	q . appendleft ( command [ 1 ] )	q . appendleft ( command [ 1 ] ) <eos>
f ab の y に d y [ i ] を加え た 値に 2 を加え た 値 番目の x に d x の i 番目 を加え た 値に 2 を加え た 値 番目 で ないとき 、	if not fab [ y + dy [ i ] + 2 ] [ x + dx [ i ] + 2 ] :	if not fab [ y + d [ i ] [ y + x [ i ] ] + dx [ 2 ] : <eos>
t _ an s を an s とする	ans = t_ans	ans = t_ans <eos>
a d j _ list の x 番目 を 順に i 、 d として 、 繰 り 返す	for i , d in adj_list [ x ] :	for dx , dy in adj_list [ x ] : <eos>
node _ tmp の space に 3 を加え た 値 番目 、 node _ tmp の space 番目 を node _ tmp の space 番目 、 node _ tmp の space に 3 を加え た 値 番目 とする	node_tmp [ space ] , node_tmp [ space + 3 ] = node_tmp [ space + 3 ] , node_tmp [ space ]	node_tmp [ space + 3 ] , node_tmp [ space + 3 ] = node_tmp [ space + 3 ] , node_tmp [ space ] <eos>
2 に x 2 から x 1 を 引 いた 値を 掛け た 値 、 2 に y 2 から y 1 を 引 いた 値を 掛け た 値 、 x 1 の 2 乗 から x 2 の 2 乗 を 引 いた 値に y 1 の 2 乗 を加え た 値 から y 2 の 2 乗 を 引 いた 値を a 、 b 、 c とする	a , b , c = 2 * ( x2 - x1 ) , 2 * ( y2 - y1 ) , x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2	c , x2 , y2 = 2 * ( x1 - x2 ) , 2 * ( y1 - y2 ) , 2 * ( x1 - y1 ) + x2 ** 2 + y1 ** 2 - y2 ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ x 0 、 y 0 、 x 1 、 y 1 、 x 2 、 y 2 、 x 3 、 y 3 とする	x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 = map ( int , input ( ) . split ( ) )	x0 , y1 , x2 , y2 , x3 , y3 , x3 , y3 = map ( int , input ( ) . split ( ) ) <eos>
r の . 5 乗 の 整数値 に 1 を加え た 値を M とする	M = int ( r ** . 5 ) + 1	M = int ( r ** . 5 ) + 1 <eos>
an s の k 番目 を 1 だけ 増加 させる	ans [ k ] += 1	ans [ k ] += 1 <eos>
x 1 、 y 1 を x 0 、 y 0 とする	x0 , y0 = x1 , y1	x0 , y0 = x1 , y1 <eos>
N の l ll 番目 を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の浮動小数点数 に 10 を 掛け た 値の 整数値 の 列 を 展開 し 、 それぞれ l 、 r とする	l , r = [ int ( float ( i ) * 10 ) for i in N [ lll ] . split ( ) ]	l , r = [ float ( i ) for i in N [ l ] . split ( ) ] <eos>
p に T に V を 掛け た 値 を加え た 値を cur とする	cur = p + T * V	cur = p + T * V <eos>
p a int ( map _ in p , x , y -1 ) を map _ in p とする	map_inp = paint ( map_inp , x , y - 1 )	map_inp = paint ( map_inp , x - 1 ) <eos>
lines の i 番目 を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ q 、 x とする	q , x = lines [ i ] . split ( )	x , q = lines [ i ] . split ( ) <eos>
w の i 番目 を s とする	s = w [ i ]	s = w [ i ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を a とする	a = [ int ( i ) for i in input ( ) . split ( ) ]	a = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
r 1 から r 2 に 1 を加え た 値 未 満 までの 数 列 を 順に r として 、 繰 り 返す	for r in range ( r1 , r2 + 1 ) :	for r in range ( r1 , r2 + 1 ) : <eos>
b を a の -2 番目 にする	a [ - 2 ] = b	a [ - 2 ] = b <eos>
a < b を出力する	print ( "a < b" )	print ( "a < b ) <eos>
l に x を加え た 値 から 1 を 引 いた 値を x で 割 った 商 に x を 掛け た 値 から r に 1 を加え た 値 未 満 までの x 間 隔 の数 列 を 順に y として 、 繰 り 返す	for y in range ( ( l + x - 1 ) // x * x , r + 1 , x ) :	for x in range ( l + x - 1 , x + 1 ) : <eos>
b を出力する	print ( "b" )	print ( b ) <eos>
m に 1 を加え た 値を l is の i 番目 にする	lis [ i ] = m + 1	lis [ i ] = m + 1 <eos>
( 0 ) からなる 列 の N 回 分 の 列 を used とする	used = [ 0 ] * N	used = [ 0 ] * N <eos>
score を line の i 番目 に line の i に 1 を加え た 値 番目 を加え た 値 だけ 増加 させる	score += line [ i ] + line [ i + 1 ]	score += line [ i + 1 ] <eos>
Q の query の 1 番目 番目の index に query の 2 番目 を 挿入 する	Q [ query [ 1 ] ] . insert ( index , query [ 2 ] )	Q [ query [ 1 ] ] [ query [ 2 ] ] <eos>
0 から n 未 満 までの 数 列 を 順に c として 、 繰 り 返す <blk> k を n 1 から c を 引 いた 値を 1 だけ 右 シフト した 値 だけ 右 シフト した 値 と 1 の 論理 積 を arr の 先頭の c 番目 にする </blk>	for c in range ( n ) : <blk> arr [ 0 ] [ c ] = ( k >> ( ( n1 - c ) >> 1 ) ) & 1 </blk>	for c in range ( n ) : <blk> arr [ 0 ] [ 1 >> ( n - 1 ) >> 1 ] = 1 </blk> <eos>
0 から r の 長さ 未 満 までの 数 列 の各要素 を i と し 、 1 の 列 を table とする	table = [ 1 for i in range ( len ( r ) ) ]	table = [ [ 1 for i in range ( len ( table ) ) ] <eos>
e が '+' と 等しい とき 、	if e == '+' :	if e == '+' : <eos>
( k に A の先頭 を 掛け た 値 、 k に A の 1 番目 を 掛け た 値 ) からなる 列 を返す	return [ k * A [ 0 ] , k * A [ 1 ] ]	return [ k * A [ 0 ] , A [ k [ 1 ] * A [ 1 ] ] <eos>
( '' ) からなる 列 を an s とする	ans = [ '' ]	ans = [ '' ] <eos>
n max が 2 と 等しい とき 、 <blk> c n t の 1 番目の 1 番目 が 2 と 等しい とき " two pair " 、 そうでなければ " one pair " を返す </blk>	if nmax == 2 : <blk> return "two pair" if cnt [ 1 ] [ 1 ] == 2 else "one pair" </blk>	if nmax == 2 : <blk> return <unk> if cnt [ 1 ] [ 1 ] == 2 else <unk> </blk> <eos>
i を conversion の Name 番目 にする	conversion [ Name ] = i	conversion [ <unk> ] = i <eos>
stack の 末尾に char の 整数値 を追加する	stack . append ( int ( char ) )	stack . append ( int ( char ) ) <eos>
p に project ( s , p ) から p を 引 いた 値に 2.0 を 掛け た 値 を加え た 値を返す	return p + ( project ( s , p ) - p ) * 2.0	return p + ( s , p - q ) * 2.0 <eos>
( 0 ) からなる 列 の 10 1 回 分 の 列 を r とする	r = [ 0 ] * 101	r = [ 0 ] * 101 <eos>
items の各要素 を v 、 w 、 t 、 d 、 n と し 、 ( v の 整数値 、 w の 整数値 、 t 、 d の 整数値 、 n ) の 組 の 列 を items とする	items = [ ( int ( v ) , int ( w ) , t , int ( d ) , n ) for v , w , t , d , n in items ]	items = ( [ int ( w , t , d ) , int ( w ) , int ( w ) , d for v , t in items ( ) ] ) <eos>
( 0 ) からなる 列 の 1 500 回 分 の 列 を tb l とする	tbl = [ 0 ] * 1500	tbl = [ 0 ] * 1001 <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列のリスト を n とする </blk>	try : <blk> n = list ( input ( ) ) </blk>	try : <blk> n = list ( input ( ) ) </blk> <eos>
l ight f ly を出力する	print ( "light fly" )	print ( "light fly" ) <eos>
an s を v だけ 増加 させる	ans += v	ans += v <eos>
c から a を 引 いた 値に g から e を 引 いた 値を 掛け た 値が - ( d - b ) に h から f を 引 いた 値を 掛け た 値 と 等しい とき 1 、 そうでなければ ( c - a ) に ( h - f ) を 掛け た 値が ( d - b ) に ( g - e ) を 掛け た 値 と 等しい	print ( 1 if ( c - a ) * ( g - e ) == - ( d - b ) * ( h - f ) else ( 2 if ( c - a ) * ( h - f ) == ( d - b ) * ( g - e ) else 0 ) )	h = ( a - a ) * ( b - d - e ) if c - ( b - d == - e ) * ( b - d ) else ( a - b ) <eos>
a に b を 9 だけ 左 シフト した 値 を加え た 値を k とする	k = a + ( b << 9 )	k = a + ( b << 9 ) <eos>
d i j k str a ( M , A , B , to , t i ) を node とする	node = dijkstra ( M , A , B , to , ti )	t = dijkstra ( A , M , node , t ) <eos>
seq の 末尾に key を追加する	seq . append ( key )	seq . append ( key ) <eos>
i の とき 、 <blk> 改行 せずに " " を出力する </blk>	if i : <blk> print ( " " , end = "" ) </blk>	if i : <blk> print ( " " , end = "" ) </blk> <eos>
' z ' 、 '.' 、 '?' 、 ' !' 、 ' ' を a の 6 1 番目 、 a の 6 2 番目 、 a の 63 番目 、 a の 64 番目 、 a の 65 番目 とする	a [ 61 ] , a [ 62 ] , a [ 63 ] , a [ 64 ] , a [ 65 ] = 'z' , '.' , '?' , '!' , ' '	a [ 6 ] , a [ 6 ] , a [ 6 ] , a [ 6 ] = 'z' , 'g' , 'g' , 'g' , 'g' , 'g' [ 6 ] , 'g' [ 6 ] <eos>
n と 1 の 論理 積 が 0 と 等しい とき 、 <blk> an s を k だけ 増加 させる </blk>	if n & 1 == 0 : <blk> ans += k </blk>	if n & 1 == 0 : <blk> ans += k </blk> <eos>
points の i 番目 を table の points の 長さ から i を 引 いた 値 から 1 を 引 いた 値 番目の i 番目 にする	table [ len ( points ) - i - 1 ] [ i ] = points [ i ]	table [ len ( points [ i - 1 ] ) - i ] [ i - 1 ] = points [ i ] <eos>
an s の末尾 から 空白 改行 を取り 除 いた 文字列 を出力する	print ( ans . rstrip ( ) )	print ( ans . rstrip ( ) ) <eos>
amount _ s os u ( n , n * 2 ) を出力する	print ( amount_sosu ( n , n * 2 ) )	print ( <unk> ( n , 2 * n ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ m 、 e 、 j とする	m , e , j = [ int ( i ) for i in input ( ) . split ( ) ]	m , e , j = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
A が B より小さい とき 、	if A < B :	if A < B : <eos>
空 辞書を ingredients _ dict とする	ingredients_dict = { }	ingredients_dict = { } <eos>
0 から v 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 空 列 の 列 を M とする	M = [ [ ] for _ in range ( v ) ]	M = [ [ ] for _ in range ( v ) ] <eos>
0 から n 未 満 までの 数 列 の各要素 を __ と し 、 0 から l 未 満 までの 数 列 の各要素 を _ と し 、 0 の 列 の 列 を n m l _ arr とする	nml_arr = [ [ 0 for _ in range ( l ) ] for __ in range ( n ) ]	arr = [ [ 0 for _ in range ( n ) ] for __ in range ( n ) ] <eos>
_ path の 末尾に os . path の末尾 の 末尾に s の末尾 を加え た 値 を追加する	_path . append ( path [ - 1 ] [ - 1 ] + s [ - 1 ] )	_path . append ( path [ - 1 ] [ - 1 ] + s [ - 1 ] ) <eos>
an s _ num が 0 より大きい とき 、	if ans_num > 0 :	if <unk> > 0 : <eos>
black を出力する	print ( "black" )	print ( "black" ) <eos>
m x 、 my を出力する	print ( mx , my )	print ( m , my ) <eos>
lo z en ge s を出力する	print ( lozenges )	print ( <unk> ) <eos>
b o w l が 0 と 等しい とき 、	if bowl == 0 :	if bowl == 0 : <eos>
p を an s とする	ans = p	ans = p <eos>
s が go al と 等 し く かつ v が 1 と 等しい とき 、 <blk> t を返す </blk>	if s == goal and v == 1 : <blk> return t </blk>	if s == goal and v == 1 : <blk> return t </blk> <eos>
0 から y 未 満 までの 数 列 を 順に _ として 、 繰 り 返す <blk> a を a に r を 掛け た 値の 整数値 から d を 引 いた 値 だけ 増加 させる </blk>	for _ in range ( y ) : <blk> a += int ( a * r ) - d </blk>	for _ in range ( y ) : <blk> a += int ( a * r - a * d ) </blk> <eos>
0 から H 未 満 までの 数 列 の各要素 を __ と し 、 0 から W 未 満 までの 数 列 の各要素 を _ と し 、 0 の 列 の 列 を g r id とする	grid = [ [ 0 for _ in range ( W ) ] for __ in range ( H ) ]	grid = [ [ 0 for _ in range ( W ) ] for __ in range ( H ) ] <eos>
' C ' を出力する	print ( 'C' )	print ( 'C' ) <eos>
a d j _ m at の u 番目 に 番号 付 した 組 の 列 を 順に v 、 r _ cap a c ity として 、 繰 り 返す	for v , r_capacity in enumerate ( adj_mat [ u ] ) :	for v , accel_time in enumerate ( adj_mat [ u ] ) : <eos>
r の left を p の right にする	p . right = r . left	p . right = r . left <eos>
i に c 1 を 掛け た 値を c j とする	cj = i * c1	cj = i * c1 <eos>
mouse の先頭 を cur _ pos とする	cur_pos = mouse [ 0 ]	<unk> = mouse [ 0 ] <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を Q とする	Q = [ [ ] for i in range ( n ) ]	Q = [ [ ] for i in range ( n ) ] <eos>
空 辞書を done とする	done = { }	done = { } <eos>
digits の 、 つまり 入力された 文字列の 整数値 番目 を a とする	a = digits [ int ( input ( ) ) ]	a = int ( digits ) [ int ( input ( ) ] <eos>
i を q d の i に i を 掛け た 値 番目 にする	qd [ i * i ] = i	dq [ i * i ] = i <eos>
cmd が " print " と 等しい とき 、	if cmd == "print" :	if cmd == <unk> : <eos>
an s の n 番目 を出力する	print ( ans [ n ] )	print ( ans [ n ] ) <eos>
d ice の right _ pos の ( p _ top 、 p _ f r on t ) の 組 番目 から 1 を 引 いた 値 番目 を返す	return dice [ right_pos [ ( p_top , p_front ) ] - 1 ]	return ( dice . right [ ( to_base , p ) - 1 ] ) <eos>
0 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> 入力された 文字列を ', ' で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ x の i 番目 、 y の i 番目 とする </blk>	for i in range ( n ) : <blk> x [ i ] , y [ i ] = map ( float , input ( ) . split ( ',' ) ) </blk>	for i , y in range ( n ) : <blk> x [ i ] , y [ i ] = map ( float , input ( ) . split ( ',' ) ) </blk> <eos>
改行 せずに " T " を出力する	print ( "T" , end = "" )	print ( "T" , end = "" ) <eos>
v を 9 . 8 で 割 った 値を t とする	t = v / 9.8	t = v / 9 <eos>
( ( 66 0 、 8 99 ) からなる 列 、 ( 10 80 、 12 59 ) からなる 列 、 ( 12 6 0 、 15 59 ) からなる 列 ) からなる 列 を t t とする	tt = [ [ 660 , 899 ] , [ 1080 , 1259 ] , [ 1260 , 1559 ] ]	<unk> = [ <unk> , 0 ] , [ <unk> , <unk> , [ 10 ] , [ 6 ] ] <eos>
a 1 が b 1 と 等しい とき 、	if a1 == b1 :	if a1 == b1 : <eos>
S を 順に s として 、 繰 り 返す	for s in S :	for s in S : <eos>
t と 30 を 割 ったとき の ( 商 を 展開 し 、 それぞれ t q 、 t r とする	tq , tr = divmod ( t , 30 )	t , rr = divmod ( t , 30 ) <eos>
( IN IT ) からなる 列 の MAX に 1 を加え た 値 回 分 の 列 を table とする	table = [ INIT ] * ( MAX + 1 )	table = [ INF ] * ( MAX + 1 ) <eos>
code が 2 7 と 等しい とき 、	if code == 27 :	if code == 27 : <eos>
0 から n に 1 を加え た 値 未 満 までの 数 列 の各要素 を j と し 、 、 つまり 改行 せずに "{ : > 5 }" を 書式 として an s [ i ] の j 番目の 文字列で 整 形 した 文字列 を出力する の 列	[ print ( "{:>5}" . format ( str ( ans [ i ] [ j ] ) ) , end = "" ) for j in range ( n + 1 ) ]	print ( " " . format ( str ( str ( [ j ] ) for j in range ( n + 1 ) ] ) ) ) <eos>
stack の先頭 を取り出し た 値を y とする	y = stack . pop ( )	y = stack . pop ( ) <eos>
i を S の v 番目 にする	S [ v ] = i	S [ v ] = i <eos>
d が r a に rb を加え た 値に r a に rb を加え た 値を 掛け た 値 より大きい とき 、 <blk> 0 を an s とする </blk>	if d > ( ra + rb ) * ( ra + rb ) : <blk> ans = 0 </blk>	if d > r + rb : <blk> ans = a * rb + 0 </blk> <eos>
in p の 長さが 1 と 等しい とき 、	if len ( inp ) == 1 :	if len ( inp ) == 1 : <eos>
in p を 順に dir として 、 繰 り 返す	for dir in inp :	for dir in inp : <eos>
next _ p の i 番目の k 番目 が next _ p の i 番目の j 番目 より小さい とき 、	if next_p [ i ] [ k ] < next_p [ i ] [ j ] :	if next_p [ i ] [ k ] < next_p [ i ] [ j ] : <eos>
card の 辞書 カウンタ の 出現 頻 度 順 の 列 を pair とする	pair = Counter ( card ) . most_common ( )	pair = Counter ( card ) . <unk> ( ) <eos>
un v is it ed の r 番目の とき 、	if unvisited [ r ] :	if unvisited [ r ] : <eos>
n t が node の e 番目の s 番目の n v 番目 より小さい とき 、	if nt < node [ e ] [ s ] [ nv ] :	if nt < node [ e ] [ s ] [ nv ] : <eos>
ver の 末尾に ( i 、 j ) からなる 列 を追加する	ver . append ( [ i , j ] )	ver . append ( [ i , j ] ) <eos>
a の 整数値 に b の 整数値 を 掛け た 値 を出力する	print ( int ( a ) * int ( b ) )	print ( int ( a ) * int ( b ) ) <eos>
( source ) からなる 列 を queue とする	queue = [ source ]	queue = [ source ] <eos>
n の 階 乗 の 文字列の 逆 順 を n とする	n = str ( math . factorial ( n ) ) [ : : - 1 ]	n = math . factorial ( n ) [ : : - 1 ] <eos>
1 から math . log 10 ( n ) の 整数値 に 1 を加え た 値 未 満 までの 数 列 の各要素 を x と し 、 n を 10 の x 乗 で 割 った 商 に n を 10 の x 乗 で 割 った 余 り を 掛け た 値の 列 の 最大 値を n とする	n = max ( [ ( n // ( 10 ** x ) ) * ( n % ( 10 ** x ) ) for x in range ( 1 , int ( math . log10 ( n ) ) + 1 ) ] )	x = max ( [ int ( n - 1 ) * 10 ** n + x ) for x in range ( 1 , int ( n ) // 10 ) ] ) <eos>
次 は 例外 に関する 条件 がある <blk> 入力された 文字列の 両端 から 空白 改行 を取り 除 いた 文字列のリスト を buf とする </blk>	try : <blk> buf = list ( input ( ) . strip ( ) ) </blk>	try : <blk> buf = list ( input ( ) . strip ( ) ) </blk> <eos>
an s が B i g M 以上の とき 、 <blk> an s を M で 割 った 余 り にする </blk>	if ans >= BigM : <blk> ans % = M </blk>	if ans >= B : <blk> ans % M = M </blk> <eos>
C を block とする	block = "C"	block = "C" <eos>
remove ( x + d x , y + d y )	remove ( x + dx , y + dy )	<unk> ( x + d , y + d ) <eos>
a を 1 だけ 増加 させる x を f とする	a += 1 f = x	a = a += 1 <eos>
an s を '0' だけ 増加 させる	ans += '0'	ans += '0' <eos>
0 を m st _ weights とする	mst_weights = 0	mst_weights = 0 <eos>
self の f _ keys 、 f a ce _ val の 要素を それぞれ 組 に した 列 を 順に f _ key 、 val として 、 繰 り 返す	for f_key , val in zip ( self . f_keys , face_val ) :	for face , val in zip ( self . f_keys , face_val ) : <eos>
a _ list を 順に a として 、 繰 り 返す	for a in a_list :	for a in list_a : <eos>
x を 100 で 割 った 商 を year とする	year = x // 100	year = x // 100 <eos>
me m o の i 番目 に key を 追加した 集 まり	memo [ i ] . add ( key )	memo [ i ] . add ( key ) <eos>
k が 0 と 等 し く または k が 2 と 等しい かどうか を an s とする	ans = ( k == 0 or k == 2 )	ans = k == 0 or k == 2 <eos>
f _ i を 順に l _ i として 、 繰 り 返す	for l_i in f_i :	for i_l in f_i : <eos>
0 から n 未 満 までの 数 列 の各要素 を i と し 、 、 つまり 空 列 の 列 を M とする	M = [ [ ] for i in range ( n ) ]	M = [ [ ] for i in range ( n ) ] <eos>
third かつ last の とき 、	if third and last :	if third and last : <eos>
c の 、 つまり 先頭から n 番目 までの 部分 列 の 総 和 を出力する	print ( sum ( c [ : n ] ) )	print ( sum ( c [ : n ] ) ) <eos>
tree . root . in _ order _ search ( )	tree . root . in_order_search ( )	tree . root . in_order_search ( ) <eos>
d in ic ( s , t ) を出力する	print ( dinic ( s , t ) )	print ( <unk> ( s , t ) ) <eos>
heappush ( h q , ( at , ' a ' , i , dest ) )	heappush ( hq , ( at , 'a' , i , dest ) )	heappush ( hq , ( at , dest , i , u ) ) <eos>
b m の各要素 を m と し 、 b w の各要素 を w と し 、 f ( m , w ) の 列 の 列 を e _ gen とする	e_gen = [ [ f ( m , w ) for w in bw ] for m in bm ]	ew = [ ( w , m ) for w in b ] <eos>
g r id の i を 2 で 割 った 商 に 1 を加え た 値 番目の j に 1 を加え た 値 番目 を " R " だけ 増加 させる	grid [ i // 2 + 1 ] [ j + 1 ] += "R"	grid [ i // 2 + 1 ] [ j + 1 ] += "R" <eos>
com が 0 と 等しい とき 、	if com == 0 :	if com == 0 : <eos>
an s を x 0 から x 1 を 引 いた 値の 2 乗 に y 0 から y 1 を 引 いた 値の 2 乗 を加え た 値の . 5 乗 だけ 増加 させる	ans += ( ( x0 - x1 ) ** 2 + ( y0 - y1 ) ** 2 ) ** . 5	ans += ( ( x0 - x1 ) ** 2 + ( y1 - y0 ) ** 2 ) ** . 5 <eos>
f _ i から 読み込んだ 一行 を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 の 両端 キュー を book s とする	books = deque ( map ( int , f_i . readline ( ) . split ( ) ) )	book = deque ( map ( int , f_i . readline ( ) . strip ( ) . split ( ) ) <eos>
a を出力する	print ( a )	print ( a ) <eos>
root を ( left 、 right ) からなる 列 の集合 だけ 減 少 させる	root -= set ( [ left , right ] )	root -= set ( [ left , right ] ) <eos>
入力された 文字列の 整数値 を num _ query とする	num_query = int ( input ( ) )	mark_num = int ( input ( ) ) <eos>
0 を x とする 1 を d とする	x = 0 d = 1	dx1 = 0 d = 1 <eos>
is _ prime ( k ) の とき 、	if is_prime ( k ) :	if is_prime ( k ) : <eos>
: を 区切り として H 、 M 、 S を出力する	print ( H , M , S , sep = ":" )	print ( <unk> , M , S , sep = : <eos>
入力された 文字列を n とする	n = input ( )	n = input ( ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ x 1 、 y 1 、 z 1 、 w 1 、 x 2 、 y 2 、 z 2 、 w 2 とする	x1 , y1 , z1 , w1 , x2 , y2 , z2 , w2 = map ( int , input ( ) . split ( ) )	x1 , y1 , x2 , y2 , z1 , w1 , w2 , z2 , w2 = map ( int , input ( ) . split ( ) ) <eos>
d に 1 を加え た 値を dist の w 番目 にする	dist [ w ] = d + 1	dist [ w ] = d + 1 <eos>
a d j _ v を 順に v として 、 繰 り 返す	for v in adj_v :	for v in adj_v : <eos>
N を 正規表現 ' [ + = ] ' で 分割 した 文字列 リスト の各要素 を x と し 、 x の 長さが 1 より大きく かつ x の先頭 が ' X ' と 等しい かどうか の 列 が 少なくとも ひとつ は 真 かどうか を NUMBER とする	NUMBER = any ( [ len ( x ) > 1 and x [ 0 ] == 'X' for x in re . split ( '[+=]' , N ) ] )	<unk> = any ( [ ( x + 1 ) > a [ 0 ] and x [ 0 ] == 'X' for x in re . split ( <unk> ) ] ) <eos>
play ers を ソート した 列 を play ers とする	players = sorted ( players )	players = sorted ( players ) <eos>
a が l 以下 かつ r が b 以下の とき 、 <blk> self の st の k 番目 を返す </blk>	if a <= l and r <= b : <blk> return self . st [ k ] </blk>	if a <= l and b <= r and self . st [ k ] : <blk> return st </blk> <eos>
G の t 番目の 末尾に s を追加する	G [ t ] . append ( s )	G [ t ] . append ( s ) <eos>
an s を s とする	s = ans	s = ans <eos>
c 3 の各要素 を b と し 、 b が b 01 2 の 部分集合 の ときの b の 列 の集合 を last とする	last = set ( [ b for b in c3 if b . issubset ( b012 ) ] )	last = set ( [ b for b in c3 if b . issubset ( b012 ) ] ) <eos>
a 1 が b 2 と 等 し く または a 1 が b 3 と 等 し く または a 1 が b 4 と 等しい とき 、	if a1 == b2 or a1 == b3 or a1 == b4 :	if a1 == b2 or a1 == b3 or a1 == b4 : <eos>
i の末尾 から 空白 改行 を取り 除 いた 文字列 の各要素 に 整数 を 適用 した 列 の 総 和 を出力する	print ( sum ( map ( int , i . rstrip ( ) ) ) )	print ( sum ( map ( str , i . rstrip ( ) ) ) ) <eos>
入力された 文字列の 整数値 を 100 で 割 った 商 を g とする	g = int ( input ( ) ) // 100	g = int ( input ( ) ) // 100 <eos>
1 から 2 7 未 満 までの 数 列 を 順に a として 、 繰 り 返す	for a in range ( 1 , 27 ) :	for a in range ( 1 , 27 ) : <eos>
v を x を 2 だけ 左 シフト した 値 だけ 増加 させる	v += x << 2	v += ( x << 2 ) <eos>
c を 60 で 割 った 商 を m とする	m = c // 60	m = c // 60 <eos>
t の i の 7 番目 から 、 つまり 末 尾 までの 部分 列 の 整数値 に [ MASK ] を 挿入 する	t . insert ( int ( i [ 7 : ] ) )	t . insert ( int ( i [ 7 : ] ) ) <eos>
現在の 日時 が 0 より大きい とき 、 <blk> 現在の 日時 を 1 だけ 減 少 させる </blk>	if now > 0 : <blk> now -= 1 </blk>	if now > 0 : <blk> now -= 1 </blk> <eos>
0 から 3 未 満 までの 数 列 を 順に _ として 、 繰 り 返す	for _ in range ( 3 ) :	for _ in range ( 3 ) : <eos>
hand が m から m に 5 を加え た 値 未 満 までの 数 列 のリスト と 等しい とき 、	if hand == list ( range ( m , m + 5 ) ) :	if hand == list ( range ( m , m + 5 ) ) : <eos>
x が ' A ' と 等しい とき 、 <blk> 0 を a とする </blk>	if x == 'A' : <blk> a = 0 </blk>	if x == 'A' : <blk> a = 0 </blk> <eos>
color 、 out 、 in d eg は グローバル変数 とする	global color , out , indeg	global color , indeg , d <eos>
改行 せずに times の i 番目 を出力する	print ( times [ i ] , end = "" )	print ( times [ i ] , end = "" ) <eos>
文字列 N 内の ' X ' を i で 置き換え た 文字列 を評価し た 値の とき 、	if eval ( N . replace ( 'X' , i ) ) :	if eval ( N . replace ( 'X' , i ) ) : <eos>
N um ( self . x + value . x ) を返す	return Num ( self . x + value . x )	return Num ( self . x + value . x ) <eos>
i に 1 を加え た 値を id x とする	idx = i + 1	idx = i + 1 <eos>
_ a の 整数値 に _ b の 整数値 を加え た 値が _ an s の 整数値 と 等しい とき 、	if int ( _a ) + int ( _b ) == int ( _ans ) :	if int ( _a ) + int ( _b ) == int ( _ans ) : <eos>
a の 末尾に x を追加する	a . append ( x )	a . append ( x ) <eos>
i 、 i に res を加え た 値 を追加して r m q を更新する	rmq . update ( i , i + res )	res . update ( i , i + r ) <eos>
g が s と 等しくない 間 、 次 を 繰 り 返す	while g != s :	while g != s : <eos>
S から T を 引 いた 値を K とする	K = S - T	K = S - T <eos>
1 を st ud ent の a 番目 にする	student [ a ] = 1	student [ a ] = 1 <eos>
sub set s を 順に sub として 、 繰 り 返す	for sub in subsets :	for sub in subsets : <eos>
m が ' C ' と 等しい とき 、 <blk> 真 を c の a の 整数値 から 1 を 引 いた 値 番目 にする </blk>	if m == 'C' : <blk> c [ int ( a ) - 1 ] = True </blk>	if m == 'C' : <blk> a [ a - 1 ] = True </blk> <eos>
card の i 番目 を出力する	print ( card [ i ] )	print ( card [ i ] ) <eos>
bit string の k 番目 から 、 つまり 末 尾 までの 部分 列 を bit string とする	bitstring = bitstring [ k : ]	string = bitstring [ k : ] <eos>
S en b at s u _ a mount を 1 だけ 増加 させる	Senbatsu_amount += 1	Senbatsu_Syozoku += 1 <eos>
table の i から 1 を 引 いた 値 番目の j 番目 、 table の i から 1 を 引 いた 値 番目の j から c の i -1 番目 を 引 いた 値 番目 に 1 を加え た 値 、 table の i 番目の j から c の i -1 番目 を 引 いた 値 番目 に 1 を加え た 値の 最小 値を table の i 番目の j 番目 にする	table [ i ] [ j ] = min ( table [ i - 1 ] [ j ] , table [ i - 1 ] [ j - c [ i - 1 ] ] + 1 , table [ i ] [ j - c [ i - 1 ] ] + 1 )	table [ i ] [ j ] = min ( table [ i - 1 ] [ j - 1 ] , table [ i - 1 ] [ j - 1 ] + table [ i - 1 ] [ j - 1 ] ) <eos>
arg の 1 番目 を d の arg の先頭 番目 にする	d [ arg [ 0 ] ] = arg [ 1 ]	d [ arg [ 0 ] ] = arg [ 1 ] <eos>
0 を h a z u re とする	hazure = 0	u_fare = 0 <eos>
x に n に b を 掛け た 値 を加え た 値を an s とする	ans = x + n * b	ans = x + n * b <eos>
入力された 文字列を ', ' で 分割 した 字句 列 の各要素 を _ と し 、 _ の 浮動小数点数の 列 を 展開 し 、 それぞれ x 1 、 y 1 、 x 2 、 y 2 、 x 3 、 y 3 、 x 4 、 y 4 とする	x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = [ float ( _ ) for _ in input ( ) . split ( ',' ) ]	x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = [ float ( _ ) for _ in input ( ) . split ( ',' ) ] <eos>
check _ win n ing ( in p _ tmp ) の とき 、	if check_winning ( inp_tmp ) :	if <unk> ( inp_tmp ) : <eos>
0 から n 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 空 列 の 列 を self の e にする	self . e = [ [ ] for _ in range ( n ) ]	self . e = [ [ ] for _ in range ( n ) ] <eos>
U の 、 つまり 先頭から x 番目 までの 部分 列 に z に y から x を 引 いた 値を 掛け た 値 を加え た 値に U の y 番目 から 、 つまり 末 尾 までの 部分 列 を加え た 値を U とする	U = U [ : x ] + z * ( y - x ) + U [ y : ]	U = U [ : x ] + y * z + y [ z : ] <eos>
[ MASK ] の 両端 キュー を L とする	L = deque ( )	L = collections . deque ( ) <eos>
t t と 60 を 割 ったとき の ( 商 を 展開 し 、 それぞれ m 、 s とする	m , s = divmod ( tt , 60 )	s , m = divmod ( t , 60 ) <eos>
N が 1 と 等しくない とき 、	if N != 1 :	if N != 1 : <eos>
1 を map H の先頭 の先頭に する	mapH [ 0 ] [ 0 ] = 1	mapH [ 0 ] [ 0 ] = 1 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を line 2 とする	line2 = [ int ( i ) for i in input ( ) . split ( ) ]	line2 = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n a 、 n b 、 n c とする	na , nb , nc = map ( int , input ( ) . split ( ) )	n , a , b , nc = map ( int , input ( ) . split ( ) ) <eos>
s 1 の wi 番目 から i 番目 までの 部分 列 が s 2 の w j 番目 から j 番目 までの 部分 列 と 等しくない とき 、 <blk> k を 1 だけ 増加 させる </blk>	if s1 [ wi : i ] != s2 [ wj : j ] : <blk> k += 1 </blk>	if s1 [ wi : i ] != sw : <blk> k [ j ] += 1 </blk> <eos>
tra in s の l 1 番目 に tra in s の l 2 番目 を加え た 値を co up l ed とする	coupled = trains [ l1 ] + trains [ l2 ]	coupled = trains [ l1 ] + trains [ l2 ] <eos>
3 に n を 掛け た 値に 1 を加え た 値を n とする	n = 3 * n + 1	n = 3 * n + 1 <eos>
x を self の par の y 番目 にする	self . par [ y ] = x	self . par [ y ] = x <eos>
100 を d とする	d = 100	d = 100 <eos>
c を 1 だけ 減 少 させる	c -= 1	c -= 1 <eos>
k を 2 で 割 った 余 り が 0 と 等しい とき 、	if k % 2 == 0 :	if k % 2 == 0 : <eos>
IN F を d p の j 番目 にする	dp [ j ] = INF	dp [ j ] = INF <eos>
u に l を加え た 値を conv ex _ h ul l とする	convex_hull = u + l	convex_hull = u + l <eos>
re _ prime を 順に a として 、 繰 り 返す	for a in re_prime :	for a in <unk> : <eos>
空 辞書を rank とする	rank = { }	rank = { } <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト に 番号 付 した 組 の 列 を 順に j 、 num として 、 繰 り 返す	for j , num in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ) :	for j , num in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) : <eos>
power の 末尾に c を追加する	power . append ( c )	power . append ( c ) <eos>
N を 81 に 2 の l から 1 を 引 いた 値 乗 から 1 を 引 いた 値を 掛け た 値 だけ 減 少 させる	N -= 81 * ( 2 ** ( l - 1 ) - 1 )	N -= 81 * ( 81 * ( 2 * ( l - 1 ) - 1 ) <eos>
card の 辞書 カウンタ を c n t とする	cnt = collections . Counter ( card )	cnt = Counter ( card ) <eos>
child を node の parent の left にする	node . parent . left = child	node . parent . left = child <eos>
q を _ q とする	_q = q	q_pop = q <eos>
missing _ card s の 末尾に " H {0} " を 書式 として i で 整 形 した 文字列 を追加する	missing_cards . append ( "H {0}" . format ( i ) )	missing_cards . append ( "H {0}" . format ( i ) ) <eos>
t に py を 掛け た 値に 1 から t を 引 いた 値に q y を 掛け た 値 を加え た 値を y とする	y = t * py + ( 1 - t ) * qy	y = t * py - 1 + t * y <eos>
number を 順に j として 、 繰 り 返す	for j in number :	for j in number : <eos>
self の e の pre v v の v 番目 番目の pre ve の v 番目 番目の cap を d だけ 減 少 させる	self . e [ prevv [ v ] ] [ preve [ v ] ] . cap -= d	self . e [ v ] [ preve [ v ] ] [ d ] -= d <eos>
s can ( imag e , W ) を出力する	print ( scan ( image , W ) )	print ( <unk> ( e , W ) ) <eos>
a を 順に c として 、 繰 り 返す <blk> an s を t の c 番目 だけ 増加 させる </blk>	for c in a : <blk> ans += t [ c ] </blk>	for c in a : <blk> ans += c [ t ] </blk> <eos>
空 列 、 ( 0 ) からなる 列 の n 回 分 の 列 を B 、 H とする	B , H = [ ] , [ 0 ] * n	B , H = [ ] * n <eos>
max を返す	return max	return max <eos>
st の i に 1 を加え た 値 番目 を st 1 とする	st1 = st [ i + 1 ]	st = st [ i + 1 ] <eos>
s の i 番目 が "," と 等 し く または s の i 番目 が " . " と 等 し く または s の i 番目 が " " と 等しい とき 、	if s [ i ] == "," or s [ i ] == "." or s [ i ] == " " :	if s [ i ] == "," or s [ i ] == "," or s [ i ] == " " ) : <eos>
a num s の j 番目 を 1 だけ 減 少 させる	anums [ j ] -= 1	anums [ j ] -= 1 <eos>
0 から t 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( t ) :	for i in range ( t ) : <eos>
cur が L より 小さく かつ S の cur 番目 が ' ' と 等しい 間 、 次 を 繰 り 返す	while cur < L and S [ cur ] == ' ' :	while cur < L and S [ cur ] == ' ' : <eos>
x に 1 を加え た 値 、 14 の 最小 値 から 0 未 満 までの -1 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( min ( x + 1 , 14 ) , 0 , - 1 ) :	for i in range ( min ( x + 1 , min ( 0 , - 1 ) , - 1 ) : <eos>
0.0 を res とする	res = 0.0	res = 0.0 <eos>
root _ node _ no は グローバル変数 とする	global root_node_no	global root_node_no <eos>
1 から 10 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( 1 , 10 ) :	for j in range ( 1 , 10 ) : <eos>
table の j から 1 を 引 いた 値 番目の i 番目 、 table の j 番目の i から 1 を 引 いた 値 番目 、 table の j から 1 を 引 いた 値 番目の i から 1 を 引 いた 値 番目の 最小 値に 1 を加え た 値を table の j 番目の i 番目 にする	table [ j ] [ i ] = min ( table [ j - 1 ] [ i ] , table [ j ] [ i - 1 ] , table [ j - 1 ] [ i - 1 ] ) + 1	table [ j ] [ i - 1 ] = min ( table [ j - 1 ] [ i - 1 ] , table [ j - 1 ] [ i ] [ j - 1 ] ) + table [ i ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする	A , B = [ int ( i ) for i in input ( ) . split ( ) ]	A , B = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
0 から b の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( b ) ) :	for i in range ( len ( b ) ) : <eos>
final を ( l 1 の先頭 、 l 1 の 1 番目 、 l 2 の先頭 、 l 2 の 1 番目 、 l 3 の先頭 、 l 3 の 1 番目 ) からなる 列 だけ 増加 させる	final += [ l1 [ 0 ] , l1 [ 1 ] , l2 [ 0 ] , l2 [ 1 ] , l3 [ 0 ] , l3 [ 1 ] ]	final += [ l1 [ 1 ] , l [ 0 ] , l [ 1 ] , l [ 1 ] ] <eos>
is V is it ed の i 番目 でなく かつ d の i 番目 が min cos t より小さい とき 、	if ( not isVisited [ i ] ) and ( d [ i ] < mincost ) :	if ( <unk> ) and ( d [ i ] < mincost : <eos>
入力された 文字列のリスト を direction とする	direction = list ( input ( ) )	direction = list ( input ( ) ) <eos>
0 を end _ b r id ge s _ weight とする	end_bridges_weight = 0	end_bridges_weight = 0 <eos>
time の p q の 先頭の 1 番目 番目 を L から pre _ t を 引 いた 値 だけ 増加 させる	time [ pq [ 0 ] [ 1 ] ] += L - pre_t	time [ 0 ] [ q [ 1 ] - L ] += t <eos>
num に 番号 付 した 組 の 列 を 順に j 、 k として 、 繰 り 返す	for j , k in enumerate ( num ) :	for j , k in enumerate ( num ) : <eos>
k に i を 掛け た 値が 100 10 より小さい 間 、 次 を 繰 り 返す	while k * i < 10010 :	while k * i < 100 : <eos>
j の各要素 に 整数 を 適用 した 列 を floor _ str とする	floor_str = map ( str , j )	<unk> = map ( int , j ) <eos>
a に b を加え た 値に c を加え た 値を d とする	d = ( a + b + c )	d = a + b + c <eos>
'0' に b を加え た 値を b とする	b = '0' + b	b = '0' + b <eos>
x の 絶対値 を x とする y の 絶対値 を y とする	x = abs ( x ) y = abs ( y )	y = abs ( abs ( x ) ) y = abs ( x <eos>
x 1 から x 3 を 引 いた 値の 2 乗 に y 1 から y 3 を 引 いた 値の 2 乗 を加え た 値 の平方根 を b とする	b = math . sqrt ( ( x1 - x3 ) ** 2 + ( y1 - y3 ) ** 2 )	b = math . sqrt ( ( x1 - x3 ) ** 2 + ( y1 - y3 ) ** 2 ) <eos>
math モジュール を用い る	from math import radians , atan2	from math import cos , cos , radians <eos>
30 に h に m を 60 で 割 った 値 を加え た 値を 掛け た 値を s とする	s = 30 * ( h + ( m / 60 ) )	s = ( 30 + h * 60 ) / 60 <eos>
( 0 ) からなる 列 の h 回 分 の 列 の各要素 を _ と し 、 、 つまり 入力された 文字列の 列 を a とする	a = [ input ( ) for _ in [ 0 ] * h ]	a = [ 0 ] * h <eos>
s を arr の j & 1 番目の z z 番目の y y 番目の x x 番目 と 1 の 論理 積 だけ 増加 させる	s += arr [ j & 1 ] [ zz ] [ yy ] [ xx ] & 1	s += arr [ j & 1 ] [ z ] [ x & 1 ] [ y ] <eos>
D P の n 番目 を出力する	print ( DP [ n ] )	print ( DP [ n ] ) <eos>
4 000 に n を 掛け た 値を x とする	x = 4000 * n	x = 4000 * n <eos>
neighbor が queue に 含 まれ なく かつ neighbor が visit ed に 含まれない とき 、	if neighbor not in queue and neighbor not in visited :	if neighbor not ( neighbor in queue ) and ( neighbor ) not in neighbor : <eos>
1 から words の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , len ( words ) ) :	for i in range ( 1 , len ( words ) ) : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 のリスト を 展開 し 、 それぞれ x a 、 y a 、 r a 、 xb 、 y b 、 rb とする	xa , ya , ra , xb , yb , rb = list ( map ( float , input ( ) . split ( ) ) )	xa , ya , ra , xb , yb , rb = list ( map ( float , input ( ) . split ( ) ) <eos>
文字 コード ' A ' の順序 数 に a  の b と 等しい 要素の 最初の 位置 を加え た 値の 文字 、 b を出力する	print ( chr ( ord ( 'A' ) + a . index ( b ) ) , b )	print ( chr ( ord ( 'A' ) + b ) , chr ( a ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を list _ in とする	list_in = list ( map ( int , input ( ) . split ( ) ) )	cp_list = list ( map ( int , input ( ) . split ( ) ) ) <eos>
0 から n 未 満 までの 数 列 の各要素 を x と し 、 n m l _ arr の x 番目 を 展開 して を出力する の 列	[ print ( * nml_arr [ x ] ) for x in range ( n ) ]	print ( * [ nm_arr [ x ] for x in range ( n ) ] ) <eos>
array s の arg の先頭 番目の 末尾に arg の 1 番目 を追加する	arrays [ arg [ 0 ] ] . append ( arg [ 1 ] )	arrays [ arg [ 0 ] ] . append ( arg [ 1 ] ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 k とする	n , k = map ( int , input ( ) . split ( ) )	n , k = map ( int , input ( ) . split ( ) ) <eos>
file _ input から 読み込んだ 一行 の 整数値 を t とする	t = int ( file_input . readline ( ) )	t = int ( file_input . readline ( ) ) <eos>
c 1 に f all を加え た 値に t 2 を加え た 値を c 2 とする	c2 = c1 + fall + t2	c2 = c1 + f2 + t2 <eos>
x に x に 1 を加え た 値を 掛け た 値に x に 2 を加え た 値を 掛け た 値を 6 で 割 った 商 を p とする	p = x * ( x + 1 ) * ( x + 2 ) // 6	p = x * ( x + 1 ) // 2 + 2 * x <eos>
6 から -1 未 満 までの -1 間 隔 の数 列 を 順に j として 、 繰 り 返す	for j in range ( 6 , - 1 , - 1 ) :	for j in range ( 6 , - 1 , - 1 ) : <eos>
M T の i 番目の j 番目の とき 、	if MT [ i ] [ j ] :	if MT [ i ] [ j ] : <eos>
0 に accumulate ( [ int ( f _ i . readline ( ) ) for i in range ( M ) ] ) の 組 を加え た 値を X とする	X = ( 0 ) + tuple ( accumulate ( [ int ( f_i . readline ( ) ) for i in range ( M ) ] ) )	X = ( 0 ) + tuple ( accumulate ( [ int ( f_i . readline ( ) for i in range ( M ) ] ) ) ) <eos>
sum _ s of ar が q と 等 し く または sum _ s of ar に array _ a の i 番目 を加え た 値が q と 等しい とき 、	if sum_sofar == q or sum_sofar + array_a [ i ] == q :	if <unk> == q or len ( array_a ) + q == sum_sofar : <eos>
1 を cat s の c の i 番目 番目 にする	cats [ c [ i ] ] = 1	cs [ i ] = 1 <eos>
偽 を done とする	done = False	done = False <eos>
self の x 座 標 の 2 乗 に self の y 座 標 の 2 乗 を加え た 値を返す	return pow ( self . x , 2 ) + pow ( self . y , 2 )	return self . x ** 2 + self . y ** 2 <eos>
A に 2 を 掛け た 値を score _ a とする	score_a = A * 2	score_a = A * 2 <eos>
( 0 ) からなる 列 の n に 1 を加え た 値 回 分 の 列 を in d eg とする	indeg = [ 0 ] * ( n + 1 )	indeg = [ 0 ] * ( n + 1 ) <eos>
x を パラメータ として ( - x の 2 番目 、 x の 3 番目 、 x の先頭 ) の 組 を返す 関数を key として tea m を ソート する	team . sort ( key = lambda x : ( - x [ 2 ] , x [ 3 ] , x [ 0 ] ) )	team . sort ( key = lambda x : ( - x [ 2 ] , x [ 3 ] ) ) <eos>
an s に 0 を 追加した 集 まり	ans . add ( 0 )	ans . add ( 0 ) <eos>
z を T の H から 1 を 引 いた 値 番目の 、 つまり 先頭から 、 つまり 末 尾 までの 部分 列 にする	T [ H - 1 ] [ : ] = z	T [ T - 1 ] [ : ] = z <eos>
pre v v の v 番目 を v とする	v = prevv [ v ]	v = prev [ v ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ w 、 h 、 x 、 y 、 r とする	w , h , x , y , r = map ( int , input ( ) . split ( ) )	x , y , h , w , h = map ( int , input ( ) . split ( ) ) <eos>
ca es ar _ dec r ypt ( k , cipher ) を dec r ypt ed とする	decrypted = caesar_decrypt ( k , cipher )	<unk> = <unk> ( cipher , <unk> ( cipher , r ) <eos>
0 から 4 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> b の i 番目 、 b の 4 に i を加え た 値 番目 を出力する </blk>	for i in range ( 4 ) : <blk> print ( b [ i ] , b [ 4 + i ] ) </blk>	for i in range ( 4 ) : <blk> print ( b [ i ] + b [ 4 ] ) </blk> <eos>
j に 1 を加え た 値が m より小さい 間 、 次 を 繰 り 返す	while j + 1 < m :	while j + 1 < m : <eos>
( ( 0 , 1 ) ) からなる 辞書 を返す	return { 0 : 1 }	return { 0 : 1 } <eos>
x が h と 等しい かどうか が 0 と 等しい とき 、	if x == h == 0 :	if x == h == 0 : <eos>
k が 0 より大きい とき k 、 そうでなければ " N A " を出力する	print ( k if k > 0 else "NA" )	print ( "NA" if k > 0 else "NA" ) <eos>
m の n 乗 の 文字列の 逆 順 を s とする	s = str ( m ** n ) [ : : - 1 ]	s = ( m ** n ) [ : - 1 ] <eos>
d 2 t ( p ) 、 d 2 t ( q ) を p 、 q とする	p , q = d2t ( p ) , d2t ( q )	t , q = d2t ( p2 ) , ( p ) <eos>
C の s 番目 を 1 だけ 増加 させる	C [ s ] += 1	C [ s ] += 1 <eos>
an s が m 以下の とき 、	if ans <= m :	if ans <= m : <eos>
a の i 番目 を ( a の i 番目の 総 和 ) からなる 列 だけ 増加 させる	a [ i ] += [ sum ( a [ i ] ) ]	a [ i ] += sum ( [ a ] ) <eos>
n に c を加え た 値 から a に b を加え た 値を 引 いた 値 を出力する	print ( ( n + c ) - ( a + b ) )	print ( n + c - a + b ) <eos>
0 を cur s ol _ W とする	cursol_W = 0	cursol_W = 0 <eos>
空 列 を rest とする	rest = [ ]	rest = [ ] <eos>
parent _ node _ no を in _ node の parent にする	in_node . parent = parent_node_no	parent_node_no . parent = parent_node_no <eos>
0 から n 未 満 までの 数 列 を 順に c 1 として 、 繰 り 返す	for c1 in range ( n ) :	for c1 in range ( n ) : <eos>
a を b で 割 った 余 り が 0 と 等しくない 間 、 次 を 繰 り 返す	while a % b != 0 :	while a % b != 0 : <eos>
. を T の 2 に i を 掛け た 値 番目の W から 2 を 引 いた 値 番目 にする	T [ 2 * i ] [ W - 2 ] = "."	T [ 2 * i ] [ W - 2 ] = "." <eos>
a の 2 乗 が b の 2 乗 に c の 2 乗 を加え た 値 と 等 し く または b の 2 乗 が c の 2 乗 に a の 2 乗 を加え た 値 と 等 し く または c の 2 乗 が a の 2 乗 に b の 2 乗 を加え た 値 と 等しい とき 、	if a ** 2 == b ** 2 + c ** 2 or b ** 2 == c ** 2 + a ** 2 or c ** 2 == a ** 2 + b ** 2 :	if a ** 2 == b ** 2 + c ** 2 or a [ b ** 2 + c ** 2 ] == a / 2 : <eos>
i に 1 を加え た 値が H より小さい とき 、	if i + 1 < H :	if i + 1 < H : <eos>
g の逆 順 を g とする	g = g [ : : - 1 ]	g = g [ : - 1 ] <eos>
p の y に 2 を加え た 値 番目の x 番目 を 1 だけ 増加 させる	p [ y + 2 ] [ x ] += 1	p [ y + 2 ] [ x ] += 1 <eos>
v に min _ id x を 追加した 集 まり	v . add ( min_idx )	v . add ( min_idx ) <eos>
L に v 1 を 掛け た 値を v 1 に v 2 を加え た 値で 割 った 余 り を p r とする	pr = ( L * v1 ) % ( v1 + v2 )	prv = ( L * v1 + v2 ) % ( v1 ) <eos>
p が 0 以上 かつ S の p 番目 が " B " と 等 し く かつ q が N より 小さく かつ S の q 番目 が " B " と 等しい とき 、	if ( p >= 0 and S [ p ] == "B" ) and ( q < N and S [ q ] == "B" ) :	if p >= 0 and S [ p ] == B [ q and S [ q ] == "W" and S [ q ] == "W" : <eos>
s z を 1 だけ 増加 させる	sz += 1	sz += 1 <eos>
v 1 を v 2 倍 にする	v1 *= v2	v1 *= v2 <eos>
row の 末尾に r h o m b ic の k 番目の i 番目 に sum s の i 番目 、 sum s の i に 1 を加え た 値 番目の 最大 値 を加え た 値 を追加する	row . append ( rhombic [ k ] [ i ] + max ( sums [ i ] , sums [ i + 1 ] ) )	row . append ( max ( rhombic [ k ] [ i + 1 ] , sums [ i + 1 ] ) ) <eos>
f low を返す	return flow	return flowed <eos>
node s の i 番目 を node とする	node = nodes [ i ]	node = nodes [ i ] <eos>
t が n の 0.5 乗 より小さい 間 、 次 を 繰 り 返す	while t < ( n ** 0.5 ) :	while t < n ** 0.5 : <eos>
A に B を 掛け た 値が 0 以上の とき 、	if A * B >= 0 :	if A * B >= 0 : <eos>
dist を min _ d とする	min_d = dist	min_d = dist <eos>
sum を c だけ 増加 させる	sum += c	sum += c <eos>
- b に d を加え た 値 、 - b から d を 引 いた 値 、 a を 1 だけ 左 シフト した 値を d 1 、 d 2 、 a 2 とする	d1 , d2 , a2 = - b + d , - b - d , a << 1	a , b , d1 = - b , d + ( a - d - 1 , - d1 ) <eos>
. を s y m 2 とする	sym2 = "."	sm = "." <eos>
line を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ word 、 page とする	word , page = line . split ( )	word , page = line . split ( ) <eos>
c ol _ max に c ol を加え た 値を c _ an s とする	c_ans = col_max + col	ans = col_max + col <eos>
現在の 日時 を p r v とする	prv = now	prv = now <eos>
1 から T に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> k を s の y に i を加え た 値 番目の x に S を加え た 値 番目 から s の y に i を加え た 値 番目の x 番目 を 引 いた 値 だけ 増加 させる </blk>	for i in range ( 1 , T + 1 ) : <blk> k += s [ y + i ] [ x + S ] - s [ y + i ] [ x ] </blk>	for i in range ( 1 , T + 1 ) : <blk> s [ i + y ] [ x - 1 ] += S [ i + y ] </blk> <eos>
[ MASK ] の 両端 キュー を Q とする	Q = deque ( )	Q = collections . deque ( ) <eos>
100 に s を 掛け た 値を 100 に x を加え た 値で 割 った 値の 整数値 を p とする	p = int ( 100 * s / ( 100 + x ) )	p = int ( 100 * s + x / ( 100 ) ) <eos>
an s の 末尾に ' i ' を追加する	ans . append ( 'i' )	ans . append ( 'i' ) <eos>
len を key として R を ソート する	R . sort ( key = len )	R . sort ( key = len ) <eos>
1 を m ark ed の s y 番目の s x 番目 にする	marked [ sy ] [ sx ] = 1	marked [ y ] [ s ] = 1 <eos>
s を 10 で 割 った 余 り の 整数値 を s とする	s = int ( s % 10 )	s = int ( s % 10 ) <eos>
( ( x s 、 y s ) の 組 ) からなる 列 を queue とする	queue = [ ( xs , ys ) ]	queue = [ ( sx , ys ) ] <eos>
l _ for e の i 番目 が l _ re ar の j 番目 より小さい とき 、	if l_fore [ i ] < l_rear [ j ] :	if l_fore [ i ] < l_rear [ j ] : <eos>
b の q 番目 から q に p を加え た 値 までの 部分 列 を 順に c として 、 繰 り 返す	for c in b [ q : q + p ] :	for c in b [ q : q + p ] : <eos>
空 列 を answer とする	answer = [ ]	answer = [ ] <eos>
0 から s 2 の 長さ に 1 を加え た 値 未 満 までの 数 列 の各要素 を j と し 、 0 から s 1 の 長さ に 1 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 0 の 列 の 列 を table とする	table = [ [ 0 for i in range ( len ( s1 ) + 1 ) ] for j in range ( len ( s2 ) + 1 ) ]	tables = [ [ 0 for i in range ( len ( s1 ) + 1 ) ] for j in range ( len ( s2 ) ) ] <eos>
区切り なしで s の 、 つまり 先頭から 8 番目 までの 部分 列 を出力する	print ( s [ 0 : 8 ] , sep = '' )	print ( s [ : 8 ] , sep = "" ) <eos>
tmp _ an s の 末尾に ( new _ t 、 messages の num 番目 ) の 組 を追加する	tmp_ans . append ( ( new_t , messages [ num ] ) )	tmp_ans . append ( ( ( new_t , _num [ num ] ) ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ a 、 b 、 c とする	a , b , c = map ( int , input ( ) . split ( ) )	a , b , c = map ( int , input ( ) . split ( ) ) <eos>
t x に t y に f l _ i から k を 引 いた 値を 掛け た 値 を加え た 値を b t とする	bt = tx + ty * ( fl_i - k )	t = tx + ty * ( fl_i - k ) <eos>
0 から 10 未 満 までの 数 列 の各要素 を m と し 、 f _ i から 読み込んだ 一行 の 整数値 の 列 のリスト を M とする	M = list ( [ int ( f_i . readline ( ) ) for m in range ( 10 ) ] )	M = list ( [ int ( f_i . readline ( ) ) for i in range ( 10 ) ] ) <eos>
0 から 1000 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> " Hello World " を出力する </blk>	for i in range ( 1000 ) : <blk> print ( "Hello World" ) </blk>	for i in range ( 1000 ) : <blk> print ( "Hello World" ) </blk> <eos>
x が s の i に 1 を加え た 値 番目 以上の とき 、	if x >= s [ i + 1 ] :	if x >= s [ i + 1 ] : <eos>
18 0.0 を r とする	r = 180.0	r = 180.0 <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ n 、 m 、 r とする	n , m , r = map ( int , input ( ) . split ( ) )	n , m , r = map ( int , input ( ) . split ( ) ) <eos>
( 10 、 12 、 15 ) からなる 列 を c とする	c = [ 10 , 12 , 15 ]	c = [ 10 , 12 , 15 ] <eos>
H an ak o _ ten を 3 だけ 増加 させる	Hanako_ten += 3	Hanako_ten += 3 <eos>
0 が x 以下 かどうか が 12 より 小さく かつ 0 が y 以下 かどうか が 12 より 小さく かつ a の y 番目の x 番目 が '1' と 等しい とき 、	if 0 <= x < 12 and 0 <= y < 12 and a [ y ] [ x ] == '1' :	if 0 <= x < 12 and 0 <= y < a [ x ] and a [ y ] [ x ] == '1' : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 浮動小数点数 を 適用 した 列 を 展開 し 、 それぞれ l 、 r とする	l , r = map ( float , input ( ) . split ( ) )	l , r = map ( float , input ( ) . split ( ) ) <eos>
in p 内の i に 1 を加え た 値の 出現 回数 が 4 以上の とき 、	if inp . count ( i + 1 ) >= 4 :	if inp . count ( i + 1 ) >= 4 : <eos>
f a re を a d j _ matrix の y 番目の x 番目 にする	adj_matrix [ y ] [ x ] = fare	adj_matrix [ x ] [ y ] = fare <eos>
空 辞書を hash とする	hash = { }	hash = { } <eos>
k o u h o の i 番目 を 1 だけ 増加 させる	kouho [ i ] += 1	kouho [ i ] += 1 <eos>
B を s hop _ name とする	shop_name = "B"	shop_name = "B" <eos>
m が mod s に 含まれない とき 、 <blk> mod s の 末尾に m を追加する </blk>	if m not in mods : <blk> mods . append ( m ) </blk>	if m not in mods : <blk> s . append ( mod ) </blk> <eos>
q s の i から 1 を 引 いた 値 番目 を 展開 し 、 それぞれ x 0 、 y 0 とする q s の i 番目 を 展開 し 、 それぞれ x 1 、 y 1 とする	x0 , y0 = qs [ i - 1 ] x1 , y1 = qs [ i ]	x0 , y1 = sq [ i - 1 ] , q0 [ i ] <eos>
board の i 番目の k 番目 を d だけ 増加 させる	board [ i ] [ k ] += d	board [ i ] [ k ] += d <eos>
m が -1 と 等 し く または f が -1 と 等 し く または m に f を加え た 値が 30 より小さい とき 、	if m == - 1 or f == - 1 or m + f < 30 :	if m == - 1 or f == - 1 or f + m < d : <eos>
B F S ( 1 ) を D とする	D = BFS ( 1 )	D = BFS ( 1 ) <eos>
num _ of _ in version s を出力する	print ( num_of_inversions )	print ( num_of_inversions ) <eos>
co st が dist に対応する 値 、 もし 存在し なければ key 、 IN F より小さい とき 、	if cost < dist . get ( key , INF ) :	if cost . get ( dist , key ) < INF : <eos>
out の先頭 を 削 除 する	del out [ 0 ]	del out [ 0 ] <eos>
S 2 が " " と 等しくない 間 、 次 を 繰 り 返す	while S2 != "" :	while S2 != " : <eos>
n を 2 で 割 った 商 に 1 を加え た 値 、 n を 2 で 割 った 商 を r 、 c とする	r , c = n // 2 + 1 , n // 2	r , c = n // 2 + 1 , n // 2 <eos>
真 を f とする	f = True	f = True <eos>
( 0 ) からなる 列 の self の n 回 分 の 列 を pre v v とする	prevv = [ 0 ] * self . n	prev = [ 0 ] * self . n <eos>
無限 の 整数 列 を A の i 番目の j 番目 に B の j 番目 を 掛け た 値 だけ 増加 させる	count += A [ i ] [ j ] * B [ j ]	count [ A [ i ] [ j ] * B [ j ] <eos>
空 辞書 、 空 辞書を id x 、 辞書 とする	idx , dict = { } , { }	idx , <unk> = { } <eos>
i を an s id とする	ansid = i	ansid = i <eos>
contains ( p o ly g on , t ) を出力する	print ( contains ( polygon , t ) )	print ( contains ( g , t ) ) <eos>
x が 0 と 等 し く かつ h が 0 と 等しい とき 、	if x == 0 and h == 0 :	if x == 0 and h == 0 : <eos>
( 0 ) からなる 列 の m 回 分 の 列 を 順に _ として 、 繰 り 返す	for _ in [ 0 ] * m :	for _ in [ 0 ] * m : <eos>
d と 1 の 論理 積 が 0 と 等 し く かつ c と 1 の 論理 積 が 0 と 等しい 間 、 次 を 繰 り 返す <blk> d を 2 分 の 一 にする <sep> c を 2 分 の 一 にする </blk>	while d & 1 == 0 and c & 1 == 0 : <blk> d // = 2 <sep> c // = 2 </blk>	while d & 1 and c == 0 and c // = 2 == 0 and d // 2 == 0 : <blk> d /= 2 </blk> <eos>
p が '#' と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if p == '#' : <blk> break </blk>	if p == '#' : <blk> break </blk> <eos>
d ice _ B の 2 番目 が d ice _ A の 2 番目 と 等 し く かつ d ice _ B の 3 番目 が d ice _ A の 3 番目 と 等 し く かつ d ice _ B の 4 番目 が d ice _ A の 4 番目 と 等 し く かつ d ice _ B の 5 番目 が d ice _ A の	if dice_B [ 2 ] == dice_A [ 2 ] and dice_B [ 3 ] == dice_A [ 3 ] and dice_B [ 4 ] == dice_A [ 4 ] and dice_B [ 5 ] == dice_A [ 5 ] :	if dice_B [ 2 ] == dice_A [ 2 ] and dice_B [ 4 ] == dice_A [ 4 ] and dice_B [ 3 ] == dice_A [ 4 ] and dice_B [ 4 ] == dice_A [ 4 ] == dice_A [ 4 ] == dice_A [ 4 ]
check ( ) を ok とする	ok = check ( )	ok = check ( ) <eos>
L 、 d ia g を '0' で 分割 した 字句 列 の各要素 を _ と し 、 _ の 長さ の 列 の 最大 値の 最大 値を L とする	L = max ( L , max ( [ len ( _ ) for _ in diag . split ( '0' ) ] ) )	L = max ( L , max ( [ len ( _ ) for _ in <unk> ] ) ) <eos>
1 を d ic の m 番目 にする	dic [ m ] = 1	dic [ m ] = 1 <eos>
N um ( self . x * value . x ) を返す	return Num ( self . x * value . x )	return Num ( self . x * value . x ) <eos>
func ( i ) を an s とする	ans = func ( i )	ans = func ( i ) <eos>
x を パラメータ として x の 1 番目 を返す 関数を キー として q の キーと値 の集まり を ソート した 列 を x とする	x = sorted ( q . items ( ) , key = lambda x : x [ 1 ] )	x = sorted ( q . items ( ) , key = lambda x : x [ 1 ] ) <eos>
( 0 ) からなる 列 の 200 回 分 の 列 、 0 を S 、 top とする	S , top = [ 0 ] * 200 , 0	S , top = [ 0 ] * 200 , [ 0 ] * 200 <eos>
flag の とき 、 <blk> 空行 を出力する </blk>	if flag : <blk> print ( ) </blk>	if flag : <blk> print ( ) </blk> <eos>
t 1 の順序 数 から ' A ' の順序 数 を 引 いた 値 、 t 2 の順序 数 から ' A ' の順序 数 を 引 いた 値 、 t 3 の順序 数 から ' A ' の順序 数 を 引 いた 値を s 、 t 、 b とする	s , t , b = ord ( t1 ) - ord ( 'A' ) , ord ( t2 ) - ord ( 'A' ) , ord ( t3 ) - ord ( 'A' )	s , t , ord = ord ( t1 ) , ord ( 'A' - ord ( 'A' ) - ord ( 'A' ) , ord ( 'A' ) - ord ( 'A' ) ) <eos>
空 辞書を mono とする	mono = { }	mono = { } <eos>
p から p に 100 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( p , p + 1001 ) :	for i in range ( p , 100 + 1 ) : <eos>
0 を n max とする	nmax = 0	nmax = 0 <eos>
simple _ dict の operation の 7 番目 から 、 つまり 末 尾 までの 部分 列 に [ MASK ] を 挿入 する	simple_dict . insert ( operation [ 7 : ] )	<unk> . insert ( operation [ 7 : ] ) <eos>
j を min とする	min = j	min = j <eos>
A が B と 等しい とき 、	if A == B :	if A == B : <eos>
t r i g のコピー された 列 を 展開 し 、 それぞれ x 1 、 y 1 、 x 2 、 y 2 、 x 3 、 y 3 とする	x1 , y1 , x2 , y2 , x3 , y3 = trig [ : ]	x1 , y1 , x2 , y2 , x3 , y3 = t_sg [ : ] <eos>
1 を l f とする	lf = 1	lf = 1 <eos>
x の i 番目 から x min を 引 いた 値 、 y max から y の i 番目 を 引 いた 値の 最大 値を d 1 とする	d1 = max ( x [ i ] - xmin , ymax - y [ i ] )	d1 = max ( x [ i ] - xmin , y [ i ] - ymin ) <eos>
table の先頭 の先頭 を an s とする	ans = table [ 0 ] [ 0 ]	ans = table [ 0 ] [ 0 ] <eos>
を出力する	print ( "" )	print ( " " ) <eos>
a の間 、 次 を 繰 り 返す <blk> a を 4 で 割 った 余 り の 文字列に an s を加え た 値 、 a を 4 で 割 った 商 を an s 、 a とする </blk>	while a : <blk> ans , a = str ( a % 4 ) + ans , a // 4 </blk>	while a : <blk> ans , a = str ( a // 4 ) + a // 4 , a </blk> <eos>
97 が stat ion の i 番目の 順序 数 以下 かどうか が 12 2 以下の とき 、	if 97 <= ord ( station [ i ] ) <= 122 :	if 97 <= ord ( station [ i ] ) <= 122 : <eos>
r ( x 1 , y 1 , x 2 , y 2 , x 3 , y 3 ) を abc とする	abc = r ( x1 , y1 , x2 , y2 , x3 , y3 )	x3 = r ( x1 , y1 , x2 , y2 , y3 ) <eos>
' Q ' が l に含まれる とき 、	if 'Q' in l :	if 'Q' in l : <eos>
co st を返す	return cost	return cost <eos>
v が source と 等しくない 間 、 次 を 繰 り 返す	while v != source :	while v != source : <eos>
w 3 の i に 1 を加え た 値 番目 に 1 を加え た 値を w 3 の i に 1 を加え た 値 番目 にする	w3 [ i + 1 ] = w3 [ i + 1 ] + 1	w3 [ i + 1 ] = w3 [ i + 1 ] + w [ i ] <eos>
c n t が c より小さい とき 、	if cnt < c :	if cnt < c : <eos>
入力された 文字列 の浮動小数点数 を n とする	n = float ( input ( ) )	n = float ( input ( ) ) <eos>
入力された 文字列の 整数値 を w _ max とする	w_max = int ( input ( ) )	w_max = int ( input ( ) ) <eos>
n _ p を 1 だけ 増加 させる	n_p += 1	n_p += 1 <eos>
x 1 に d 1 を 掛け た 値に x 2 に d 2 を 掛け た 値 を加え た 値に x 3 に d 3 を 掛け た 値 を加え た 値を d sum で 割 った 値を x とする	x = ( x1 * d1 + x2 * d2 + x3 * d3 ) / dsum	sum = x1 * d1 + x2 * x2 + dx * y2 + dx * dx2 <eos>
n を ソート する	n . sort ( )	n . sort ( ) <eos>
self の lazy の k 番目 を x だけ 増加 させる	self . lazy [ k ] += x	self . lazy [ k ] += x <eos>
box の py に y y を加え た 値 番目の p x に x x を加え た 値 番目 が 、 つまり 無限 の 整数 列 と 等 し く かつ ( py に y y を加え た 値 、 p x に x x を加え た 値 ) の 組 が a d res s に 含まれない とき 、 <blk> a d res s の 末尾に ( py に	if box [ py + yy ] [ px + xx ] == count and ( py + yy , px + xx ) not in adress : <blk> adress . append ( ( py + yy , px + xx ) ) </blk>	if box [ y + py ] [ x + y ] == max ( ans , dp [ x + a ) and ans == max ( a + y ) : <blk> res </blk> <eos>
A を P 倍 にする	A *= P	A *= P <eos>
op が '+' と 等しくな く かつ op が '-' と 等しくない とき 、 <blk> 繰り返し を 中断 する </blk>	if op != '+' and op != '-' : <blk> break </blk>	if op != '+' and op != '-' : <blk> break </blk> <eos>
d の間 、 次 を 繰 り 返す	while d :	while d : <eos>
j を result の start 番目の 1 番目 にする	result [ start ] [ 1 ] = j	result [ start ] [ 1 ] = j <eos>
1 を step の start の先頭 番目の start の 1 番目 番目の start の 2 番目 番目 にする	step [ start [ 0 ] ] [ start [ 1 ] ] [ start [ 2 ] ] = 1	step [ start [ 0 ] [ start [ 1 ] ] [ start [ 2 ] ] = 1 <eos>
self . get _ value ( op pos it e ) が other . get _ value ( self . __ B O T T O M ) と 等しくない とき 、	if self . get_value ( opposite ) != other . get_value ( self . __BOTTOM ) :	if self . get_value ( op ) != <unk> ( self . <unk> ( ) : <eos>
P 0 を 順に t として 、 繰 り 返す	for t in P0 :	for t in P0 : <eos>
b を パラメータ として b の 1 番目 を返す 関数を key として a を ソート する	a . sort ( key = lambda b : b [ 1 ] )	a . sort ( key = lambda b : b [ 1 ] ) <eos>
c を a の b 番目 にする	a [ b ] = c	a [ b ] = c <eos>
q の i 番目 が st ud ent に含まれる とき 、	if q [ i ] in student :	if q [ i ] in student : <eos>
a の 1 番目 から a の先頭 を 引 いた 値を an s とする	ans = a [ 1 ] - a [ 0 ]	ans = a [ 1 ] - a [ 0 ] <eos>
i  内の a と 等しい 要素を 取り除く	i . remove ( a )	i . remove ( a ) <eos>
( 0 ) からなる 列 を red とする	red = [ 0 ]	"red" = [ 0 ] <eos>
k に k に 1 を加え た 値を 掛け た 値に k に 2 を加え た 値を 掛け た 値を 6 で 割 った 商 を an s とする	ans = k * ( k + 1 ) * ( k + 2 ) // 6	ans = k * ( k + 1 ) // 26 + k * 26 <eos>
a の 先頭の 2 乗 に a の 1 番目の 2 乗 を加え た 値 の平方根 を返す	return math . sqrt ( a [ 0 ] ** 2 + a [ 1 ] ** 2 )	return math . sqrt ( a [ 0 ] ** 2 + a [ 1 ] ** 2 ) <eos>
insert ( tree , num )	insert ( tree , num )	insert ( tree , num ) <eos>
( an s 、 c n t 1 、 c n t 2 ) からなる 列 の 最大 値を an s とする	ans = max ( [ ans , cnt1 , cnt2 ] )	ans = [ ans , min ( cnt , 1 ) ] <eos>
10 000000 を IN F とする	INF = 10000000	INF = 10000000 <eos>
T の v 番目 を 順に w として 、 繰 り 返す	for w in T [ v ] :	for w in T [ v ] : <eos>
i 、 x を出力する	print ( i , x )	print ( i , x ) <eos>
a 2 が b 2 と 等しい とき 、	if a2 == b2 :	if a2 == b2 : <eos>
n の 8 進表記 の 2 番目 から 、 つまり 末 尾 までの 部分 列 の 文字列を n とする	n = str ( oct ( n ) [ 2 : ] )	n = str ( n [ 2 : ] , "" ) <eos>
a d j _ ed ge _ c p の n 1 番目の 末尾に cp を追加する	adj_edge_cp [ n1 ] . append ( cp )	adj_edge_cp [ n1 ] . append ( cp ) <eos>
( 0 、 1 ) の 組 を返す	return ( 0 , 1 )	return ( 0 , 1 ) <eos>
new _ card をコピーし た 結果を card とする	card = copy . copy ( new_card )	new_card = copy . copy ( card ) <eos>
Target の B の i に 1 を加え た 値 番目 から 1 を 引 いた 値 番目 を 2 だけ 増加 させる	Target [ B [ i + 1 ] - 1 ] += 2	<unk> [ B [ i + 1 ] - 2 ] += 2 <eos>
tmp を index の word 番目 にする	index [ word ] = tmp	index [ word ] = tmp <eos>
q の 末尾に start を追加する	q . append ( start )	q . append ( start ) <eos>
f _ i から 読み込んだ 一行 の 整数値 を d とする	d = int ( f_i . readline ( ) )	d = int ( f_i . readline ( ) ) <eos>
itertools モジュール を用い る	from itertools import accumulate	from itertools import permutations <eos>
heappop ( p q ) を path 1 とする	path1 = heappop ( pq )	path1 = heappop ( pq ) <eos>
a から 6 00 未 満 までの a 間 隔 の数 列 の各要素 を x と し 、 a に x の 2 乗 を 掛け た 値の 列 の 総 和 を出力する	print ( sum ( [ a * x ** 2 for x in range ( a , 600 , a ) ] ) )	print ( sum ( [ x * a for x in range ( 6 , x ) ] ) ** 2 ) <eos>
9 から 0 未 満 までの -1 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( 9 , 0 , - 1 ) :	for i in range ( 9 , 0 , - 1 ) : <eos>
( 0 ) からなる 列 の 100 1 回 分 の 列 を k とする	k = [ 0 ] * 1001	k = [ 0 ] * 1001 <eos>
tree _ walk _ 2 ( c )	tree_walk_2 ( c )	tree_walk_1 ( c ) <eos>
x 2 から x 1 を 引 いた 値の 2 乗 に y 2 から y 1 を 引 いた 値の 2 乗 を加え た 値を c とする	c = ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2	c = ( ( x2 - x1 ) ** 2 + ( y1 - y2 ) ** 2 ) <eos>
quick _ sort ( card s , 0 , n -1 )	quick_sort ( cards , 0 , n - 1 )	quick_sort ( cards , 0 , n - 1 ) <eos>
b _ pos が sh el f と 等しい とき 、	if b_pos == shelf :	if b_pos == shelf : <eos>
0 、 '' 、 1 を i 、 a 、 n とする	i , a , n = 0 , '' , 1	a , i , n = 0 , '' <eos>
t a x ( i , y ) に t a x ( j , y ) を加え た 値 、 maximum の 最大 値を maximum とする	maximum = max ( tax ( i , y ) + tax ( j , y ) , maximum )	maximum = max ( ta , format ( t , j + a , y ) ) <eos>
lines の 1 番目 から 1 に m を加え た 値 までの 部分 列 を rel ation _ lines とする	relation_lines = lines [ 1 : 1 + m ]	dist_from_0 = lines [ 1 : 1 + m ] <eos>
0 x 7 f ffffff を MAX とする	MAX = 0x7fffffff	MAX = <unk> <eos>
0 から a の 長さ から 1 を 引 いた 値 未 満 までの 数 列 を 順に j として 、 繰 り 返す	for j in range ( len ( a ) - 1 ) :	for j in range ( len ( a ) - 1 ) : <eos>
' No ' を出力する	print ( 'No' )	print ( 'No' ) <eos>
0 から H 未 満 までの 数 列 の各要素 を r と し 、 、 つまり 入力された 文字列のリスト の 列 を d とする	d = [ list ( input ( ) ) for r in range ( H ) ]	d = [ list ( input ( ) ) for r in range ( H ) ] <eos>
r i ek i が v から min v を 引 いた 値 より小さい とき 、	if rieki < v - minv :	if <unk> < vmin - minv : <eos>
items を ソート する	items . sort ( )	items . sort ( ) <eos>
S の i 番目 が " ? " と 等しい とき 、	if S [ i ] == "?" :	if S [ i ] == "?" : <eos>
out を k s だけ 増加 させる	out += ks	out += ks <eos>
out の 末尾に op e の先頭 を取り出し た 値 を追加する	out . append ( ope . pop ( ) )	out . append ( ope . pop ( ) ) <eos>
si k i の j から 1 を 引 いた 値 番目の 整数値 から si k i の j に 1 を加え た 値 番目の 整数値 を 引 いた 値の 文字列を si k i の j から 1 を 引 いた 値 番目 にする	siki [ j - 1 ] = str ( int ( siki [ j - 1 ] ) - int ( siki [ j + 1 ] ) )	siki [ j - 1 ] = str ( int ( siki [ j - 1 ] ) + int ( siki [ j - 1 ] ) ) <eos>
0 から H 未 満 までの 数 列 の各要素 を i と し 、 readline ( ) の 両端 から 空白 改行 を取り 除 いた 文字列の 列 を S とする	S = [ readline ( ) . strip ( ) for i in range ( H ) ]	S = [ readline ( ) . strip ( ) for i in range ( H ) ] <eos>
C を 順に x 、 y 、 r 2 として 、 繰 り 返す	for x , y , r2 in C :	for x , y , r2 in C : <eos>
a の リストを T ar o とする	Taro = list ( a )	Taro_ten = list ( a ) <eos>
tea m の 1 番目 を出力する	print ( team [ 1 ] )	print ( team [ 1 ] ) <eos>
prime _ f actor ize ( n ) を A とする	A = prime_factorize ( n )	A = <unk> ( n ) <eos>
( a ) からなる 列 に 0 から 4 未 満 までの 数 列 の各要素 を _ と し 、 、 つまり 入力された 文字列の 整数値 の 列 を加え た 値を a とする	a = [ a ] + [ int ( input ( ) ) for _ in range ( 4 ) ]	a = [ a ] + [ int ( input ( ) ) for _ in range ( 4 ) ] <eos>
Lo se _ B o ar d の board _ i 番目 、 B o ar d の board _ i 番目 を B o ar d の board _ i 番目 、 Lo se _ B o ar d の board _ i 番目 とする	Board [ board_i ] , Lose_Board [ board_i ] = Lose_Board [ board_i ] , Board [ board_i ]	Board [ board_i ] , Board [ board_i ] = <unk> , Board [ board_i ] <eos>
C a se % d : % d を ( case 、 x ) の 組 で 割 った 余 り を出力する	print ( "Case %d: %d" % ( case , x ) )	print ( "Case <unk> % ( x , case ) ) <eos>
b と 1 を i だけ 左 シフト した 値の 論理 積 の とき 、	if b & ( 1 << i ) :	if b & ( 1 << i ) : <eos>
G 2 の y 0 番目 に x 0 を 追加した 集 まり	G2 [ y0 ] . add ( x0 )	G2 [ y0 ] . add ( x0 ) <eos>
score _ a が a より小さい とき 、	if score_a < a :	if score_a < a : <eos>
line の 0 番目 が 0 と 等しい とき 、	if line [ 0 ] == 0 :	if line [ 0 ] == 0 : <eos>
空 列 を time _ re c とする	time_rec = [ ]	time_rec = [ ] <eos>
ab un d an t number を a とする	a = "abundant number"	ta = t_d <eos>
cal c ( S o in s u ( x , 2 ) ) を x _ do or とする	x_door = calc ( Soinsu ( x , 2 ) )	y_door = calc ( <unk> ( x , 2 ) ) <eos>
c s の 0 番目 が 0 と 等しい とき 、 <blk> 繰り返し を 中断 する </blk>	if cs [ 0 ] == 0 : <blk> break </blk>	if cs [ 0 ] == 0 : <blk> break </blk> <eos>
board の x 番目の y から 2 を 引 いた 値 番目 を 1 だけ 増加 させる	board [ x ] [ y - 2 ] += 1	board [ x ] [ y - 2 ] += 1 <eos>
x 、 y 、 z の 最小 値 、 x 、 y 、 z の 最大 値を a 、 c とする	a , c = min ( x , y , z ) , max ( x , y , z )	a , z = min ( x , y , z , max ( z , x ) , z <eos>
'' を 間 に入れ て i を 連結 した 文字列 を出力する	print ( '' . join ( i ) )	print ( '' . join ( i ) ) <eos>
i を 2 で 割 った 余 り が 0 と 等しい とき 、	if i % 2 == 0 :	if i % 2 == 0 : <eos>
post を pre とする	pre = post	pre = post <eos>
0 から n 未 満 までの 数 列 を 順に i として 、 繰 り 返す <blk> time ( ) </blk>	for i in range ( n ) : <blk> time ( ) </blk>	for i in range ( n ) : <blk> time ( i ) </blk> <eos>
( 0 から W に 2 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 '.' の 列 ) からなる 列 を _ property とする	_property = [ [ '.' for i in range ( W + 2 ) ] ]	property = [ [ 0 ] for i in range ( W + 2 ) ] <eos>
空 辞書を tra de 2 とする	trade2 = { }	trade_tmp = { } <eos>
無限 の 整数 列 の 末尾に ( sentence の i 番目 、 1 ) からなる 列 を追加する	count . append ( [ sentence [ i ] , 1 ] )	count . append ( [ sentence [ i ] , sentence [ 1 ] ) <eos>
w が " no b ir o " と 等しい とき 、	if w == "nobiro" :	if w == "b" : <eos>
s 1 と s 2 の 対 称 差 のリスト を ソート した 列 を s とする	s = sorted ( list ( s1 . symmetric_difference ( s2 ) ) )	s = sorted ( list ( sorted ( s1 . difference ( s2 ) ) ) ) <eos>
parse ( S , P ) を res とする	res = parse ( S , P )	res = parse ( S , P ) <eos>
0 から data の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( data ) ) :	for i in range ( len ( data ) ) : <eos>
im possibl e を出力する	print ( "impossible" )	print ( <unk> ) <eos>
c ( int ( self . value / other . value ) ) を返す	return c ( int ( self . value / other . value ) )	return c ( int ( self . value / other . value ) ) <eos>
res を ソート する	res . sort ( )	res . sort ( ) <eos>
s nd f の v 番目の 先頭 で ないとき 、	if not sndf [ v ] [ 0 ] :	if not sndf [ v ] [ 0 ] : <eos>
visit ed 、 0 、 0 において 正規表現 table が 最初 にマッチする 位置	search ( table , visited , 0 , 0 )	search ( table , visited , 0 , 0 , 0 ) <eos>
( p t 1 _ y 、 p t 1 _ x 、 0 ) の 組 を events の num _ events 番目 にする	events [ num_events ] = ( pt1_y , pt1_x , 0 )	events [ num_events ] = ( pt1_y , ( pt1_x , pt2_x ) ) <eos>
- E P S が t 以下 かつ t が E P S 以下 かどうか を返す	return - EPS <= t and t <= EPS	return - EPS <= t and EPS <= EPS <eos>
a 、 b の 最大 値 、 a 、 b の 最小 値を a 、 b とする	a , b = max ( a , b ) , min ( a , b )	a , b = min ( a , max ( b ) , a ) <eos>
foo t が 1 と 等 し く かつ l f が 0 と 等 し く かつ r f が 0 と 等しい とき 、	if foot == 1 and lf == 0 and rf == 0 :	if <unk> == 1 and lf == 0 and f == 0 and f == 0 : <eos>
c i が d 0 と 等 し く かつ m 0 が li 以下の とき 、	if ci == d0 and m0 <= li :	if ci == 0 and li <= li : <eos>
low est の s 番目 、 pre num の i 番目の 最小 値を low est の s 番目 にする	lowest [ s ] = min ( lowest [ s ] , prenum [ i ] )	lowest [ s ] = min ( lowest [ s ] , prenum [ i ] ) <eos>
x に 2 を加え た 値を x とする	x = x + 2	x = x + 2 <eos>
A を 順に i として 、 繰 り 返す	for i in A :	for i in A : <eos>
p に 10 を 掛け た 値を q で 割 った 余 り を p とする	p = ( p * 10 ) % q	p = ( p * 10 ) % q <eos>
N から j ar v is ( points ) の 長さ から 1 を 引 いた 値を 引 いた 値 を出力する	print ( N - ( len ( jarvis ( points ) ) - 1 ) )	print ( N - len ( points ) - 1 ) <eos>
0 から len _ text から len _ pattern を 引 いた 値に 1 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len_text - len_pattern + 1 ) :	for i in range ( len ( text - len_pattern ) + 1 ) : <eos>
S の 末尾に 0 を追加する	S . append ( 0 )	S . append ( 0 ) <eos>
result の a 番目 が max _ v より大きい とき 、	if result [ a ] > max_v :	if result [ max_a ] > max_v : <eos>
input _ text を " " を 間 に入れ て 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 を 連結 した 文字列 だけ 増加 させる	input_text += "" . join ( input ( ) . split ( ) )	<unk> += input ( ) . split ( " " ) <eos>
short から long を 引 いた 値の 絶対値 、 36 0 から short から long を 引 いた 値の 絶対値 を 引 いた 値の 最小 値を j ud ge とする	judge = min ( abs ( short - long ) , 360 - abs ( short - long ) )	<unk> = min ( abs ( abs ( <unk> - 0 ) , abs ( long - j ) ) ) <eos>
m を 1 だけ 左 シフト する	m << = 1	m << = 1 <eos>
a を b の文字列 だけ 増加 させる	a += str ( b )	a += str ( b ) <eos>
c を n 1 から i を 引 いた 値 だけ 増加 させる	c += n1 - i	c += n - i <eos>
flag を f だけ 増加 させる	flag += f	flag += f <eos>
card 内の card の 先頭の 出現 回数 が 4 と 等 し く または card 内の card の 1 番目の 出現 回数 が 4 と 等しい とき 、	if card . count ( card [ 0 ] ) == 4 or card . count ( card [ 1 ] ) == 4 :	if card . count ( card [ 0 ] ) == 4 or card . count ( card [ 4 ] ) == 1 : <eos>
s が s の逆 順 と 等しい とき 、	if s == s [ : : - 1 ] :	if s == s [ : : - 1 ] : <eos>
入力された 文字列を "," で 分割 した 字句 列 の各要素 を i と し 、 D ( i ) の 列 を 展開 し 、 それぞれ x 1 、 y 1 、 x 2 、 y 2 、 x q 、 y q とする	x1 , y1 , x2 , y2 , xq , yq = [ D ( i ) for i in input ( ) . split ( "," ) ]	x1 , y1 , x2 , y2 , xq , yq = [ float ( i ) for i in input ( ) . split ( "," ) ] <eos>
table の i 番目の 先頭 を an s とする	ans = table [ i ] [ 0 ]	ans = table [ i ] [ 0 ] <eos>
\\\\\ write ( " % d \\\\ \\\\ n " % an s ) \\\\\	\\\\\write ( "%d\\\\\\\\n" % ans )\\\\\	\\\\\write ( "%d\\\\\\\\n" % ans )\\\\ <eos>\
c が a より大きい とき 、 <blk> c を a とする </blk>	if c > a : <blk> a = c </blk>	if c > a : <blk> a = c </blk> <eos>
( 0 ) からなる 列 の n 回 分 の 列 を C ar d とする	Card = [ 0 ] * n	Card = [ 0 ] * n <eos>
_ pre _ order _ line ( node . left )	_pre_order_line ( node . left )	_pre_order_line ( node . left ) <eos>
print _ cross _ point ( p 0 , p 1 , p 2 , p 3 )	print_cross_point ( p0 , p1 , p2 , p3 )	print_cross_point ( p , 0 , p1 , p2 , p3 ) <eos>
x _ list を返す	return x_list	return x <eos>
5 を返す	return 5	return 5 <eos>
d f s ( 0 , st one s ) を ed ge _ set とする	edge_set = dfs ( 0 , stones )	<unk> = dfs ( 0 , stone ) <eos>
( -1 ) からなる 列 の bit _ size 回 分 の 列 を d p 1 とする	dp1 = [ - 1 ] * bit_size	dp1 = [ - 1 ] * bit_size <eos>
入力された 文字列を " " で 分割 した 字句 列 の各要素 を i と し 、 D ( i ) の 列 を 展開 し 、 それぞれ x 1 、 y 1 、 x 2 、 y 2 、 x 3 、 y 3 、 x 4 、 y 4 とする	x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = [ D ( i ) for i in input ( ) . split ( " " ) ]	x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = [ input ( ) for i in input ( ) . split ( " " ) ] <eos>
0 を rest とする	rest = 0	rest = 0 <eos>
num を _ pow ( 10 , 48 ) で 割 った 余 り を num とする	num = num % _pow ( 10 , 48 )	num = num % _pow ( 10 , 48 ) <eos>
空 列 を name とする	name = [ ]	name = [ ] <eos>
0 から n + 1 から a を 引 いた 値 から b を 引 いた 値 から c を 引 いた 値 、 10 の 最小 値 未 満 までの 数 列 を 順に d として 、 繰 り 返す	for d in range ( min ( n + 1 - a - b - c , 10 ) ) :	for d in range ( min ( min ( n + 1 - a - b - 10 ) , c ) : <eos>
ch _ x 、 ch _ y を self の s p c _ x 、 self の s p c _ y とする	self . spc_x , self . spc_y = ch_x , ch_y	self , spc_y = _f , self . _find ( pt_x , spc_y ) <eos>
l の i 番目 を 2 で 割 った 余 り が 0 と 等しくない とき 、	if ( l [ i ] % 2 != 0 ) :	if l [ i ] % 2 != 0 : <eos>
p x が 0 と 等 し く かつ py が 0 と 等しい とき 、	if px == 0 and py == 0 :	if px == 0 and py == 0 : <eos>
( 、 つまり 入力された 文字列の 整数値 ) からなる 列 を d p とする	dp = [ int ( input ( ) ) ]	dp = [ int ( input ( ) ) ] <eos>
s 1 、 s 2 を出力する	print ( s1 , s2 )	print ( s1 , s2 ) <eos>
in order _ elements の 、 つまり 先頭から root _ index 番目 までの 部分 列 を in order _ left とする	inorder_left = inorder_elements [ : root_index ]	preorder_left = inorder_elements [ : root_index ] <eos>
d f s ( g , i , r , v )	dfs ( g , i , r , v )	dfs ( i , r , v , v ) <eos>
f r on t が self の f _ keys の self の __ F R ON T 番目 と 等しい とき 、	if front == self . f_keys [ self . __FRONT ] :	if front == self . f_keys [ self . __FRONT ] : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 を arr 1 とする	arr1 = input ( ) . split ( )	state1 = input ( ) . split ( ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を N とする	N = [ int ( i ) for i in input ( ) . split ( ) ]	N = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
0 から 9 未 満 までの 数 列 の各要素 を __ と し 、 0 から 9 未 満 までの 数 列 の各要素 を _ と し 、 ' ' の 列 の 列 を m ark er とする	marker = [ [ ' ' for _ in range ( 9 ) ] for __ in range ( 9 ) ]	marker = [ [ 'x' for __ in range ( 9 ) ] for __ in range ( 9 ) ] <eos>
neighbor が node s に 含 まれ かつ neighbor が queue に 含まれない とき 、	if neighbor in nodes and neighbor not in queue :	if neighbor not in nodes and neighbor not in queue : <eos>
sum の n 番目 を出力する	print ( sum [ n ] )	print ( sum [ n ] ) <eos>
p が 0 と 等 し く かつ s が 0 と 等しい とき 、	if p == 0 and s == 0 :	if p == 0 and s == 0 : <eos>
( int ) ( v ** 2 / 19 . 6 ) を 5 で 割 った 商 に 2 を加え た 値 を出力する	print ( ( int ) ( v ** 2 / 19.6 ) // 5 + 2 )	print ( int ( ( ( ( int ( v ) // 2 ) // 26 + 2 ) // 2 ) ) <eos>
l st . U p date ( q [ 1 ] , q [ 2 ] + 1 , [ i , q [ 3 ] ] )	lst . Update ( q [ 1 ] , q [ 2 ] + 1 , [ i , q [ 3 ] ] )	lst . <unk> ( q [ 1 ] , q [ 2 ] , q [ i + 1 ] , q [ 3 ] ) <eos>
0 から len ( s ) を 2 で 割 った 商 に 1 を加え た 値 未 満 までの 数 列 の各要素 を i と し 、 s の i 番目 が s の -1 から i を 引 いた 値 番目 と 等しい かどうか の 列 が 全て が 真 の とき 、	if all ( [ s [ i ] == s [ - 1 - i ] for i in range ( len ( s ) // 2 + 1 ) ] ) :	if all ( [ s [ i ] == s - 1 for i in range ( len ( s ) // 2 ) ] ) == s [ i - 1 ] : <eos>
g s の 先頭の 整数値 を k とする	k = int ( gs [ 0 ] )	k = int ( gs [ 0 ] ) <eos>
f で ないとき 、 <blk> 1 を出力する </blk>	if not f : <blk> print ( 1 ) </blk>	if not f : <blk> print ( 1 ) </blk> <eos>
readline ( ) の浮動小数点数 を P とする	P = float ( readline ( ) )	P = float ( readline ( ) ) <eos>
( m の 0 番目 から l に n の先頭 を 掛け た 値を 引 いた 値 、 m の 1 番目 から l に n の 1 番目 を 掛け た 値を 引 いた 値 ) からなる 列 を p 2 とする	p2 = [ m [ 0 ] - l * n [ 0 ] , m [ 1 ] - l * n [ 1 ] ]	l = [ m [ 0 ] - l [ 0 ] * n [ 1 ] , m [ 1 ] - l [ 1 ] ] <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 を i と し 、 i の 整数値 の 列 を 展開 し 、 それぞれ m 、 n とする	m , n = [ int ( i ) for i in input ( ) . split ( ) ]	m , n = [ int ( i ) for i in input ( ) . split ( ) ] <eos>
heappush ( h q , ( c 2 , n 2 , h 3 ) )	heappush ( hq , ( c2 , n2 , h3 ) )	heappush ( hq , ( c2 , n2 , h ) ) <eos>
score 内の " A " の 出現 回数 を score _ a とする	score_a = score . count ( "A" )	score_a = score . count ( "A" ) <eos>
d f s ( i + 1 , state ) を r とする を me m o の i 番目の state 番目 にする	memo [ i ] [ state ] = r = dfs ( i + 1 , state )	memo [ i ] [ state ] = dfs ( i + 1 , state ) <eos>
check _ range ( x y , n ) を x y とする	xy = check_range ( xy , n )	nx = <unk> ( x , ny ) <eos>
an g を - a の ラジアン だけ 増加 させる	ang += math . radians ( - a )	ang += math . radians ( a - a ) <eos>
( c の real 、 c の imag ) の 組 を返す	return ( c . real , c . imag )	return ( c . real , c . imag ) <eos>
c が 0 と 等しい とき 、 <blk> b 3 に a 3 を 掛け た 値を m 3 で 割 った 余 り を b 3 とする </blk>	if c == 0 : <blk> b3 = ( b3 * a3 ) % m3 </blk>	if c == 0 : <blk> b = 3 * a3 % m3 </blk> <eos>
S en b at s u _ a mount が 10 より 小さく かつ S en b at s u _ S y o z ok u の T e am の i 番目の 1 番目 番目 が 3 より小さい とき 、	if Senbatsu_amount < 10 and Senbatsu_Syozoku [ Team [ i ] [ 1 ] ] < 3 :	if Senbatsu_Syozoku [ Team [ i ] < 10 and Team [ i ] [ 1 ] < hanako : <eos>
0 から h に 2 を 掛け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の各要素 を _ と し 、 0 から w に 2 を 掛け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の各要素 を _ と し 、 " . " の 列 の 列 を C とする	C = [ [ "." for _ in range ( w * 2 - 1 ) ] for _ in range ( h * 2 - 1 ) ]	C = [ [ "." * ( w - 1 ) for _ in range ( w - 1 ) ] for _ in range ( h * 2 - 1 ) ] <eos>
空 列 を card s とする	cards = [ ]	cards = [ ] <eos>
es に 番号 付 した 組 の 列 を 順に i 、 e として 、 繰 り 返す	for i , e in enumerate ( es ) :	for i , e in enumerate ( es ) : <eos>
total を出力する	print ( total )	print ( total ) <eos>
r ing s の集合 を r ing s とする	rings = set ( rings )	rings = set ( ) <eos>
0 から p as の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( pas ) ) :	for i in range ( len ( pas ) ) : <eos>
X に l を 追加した 集 まり X に r を 追加した 集 まり	X . add ( l ) X . add ( r )	X . add ( l ) <eos>
rect を 1 だけ 増加 させる	rect += 1	rect += 1 <eos>
0 から n に n を 掛け た 値に 1 を加え た 値 未 満 までの 数 列 の各要素 を _ と し 、 0 から s に 1 を加え た 値 未 満 までの 数 列 の各要素 を _ と し 、 0 の 列 の 列 を d p とする	dp = [ [ 0 for _ in range ( s + 1 ) ] for _ in range ( n * n + 1 ) ]	dp = [ [ 0 for _ in range ( 1 + 1 ) ] for _ in range ( n + 1 ) ] <eos>
set Q ue en ( q , b , 0 , q _ in i )	setQueen ( q , b , 0 , q_ini )	<unk> ( b , 0 , q , q ) <eos>
\\\\\ an s を ' \\\\ \\\\ n ' を 間 に入れ て result の各要素 に x を パラメータ として x の末尾 を返す 関数を 適用 した 列 を 連結 した 文字列 だけ 増加 させる \\\\\	\\\\\ans += '\\\\\\\\n' . join ( map ( lambda x : x [ - 1 ] , result ) )\\\\\	\\\\\ans += '\\\\\\\\n' . join ( map ( lambda x : x [ - 1 ] ) , array_s ) <eos>\
t を出力する	print ( t )	print ( t ) <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ N 、 Q とする	N , Q = map ( int , input ( ) . split ( ) )	N , Q = map ( int , input ( ) . split ( ) ) <eos>
this が plain に 含 まれ または " th at " が plain に含まれる とき 、	if ( "this" in plain ) or ( "that" in plain ) :	if "this" in plain or "that" in plain : <eos>
1 から item set s の 長さ 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( 1 , len ( itemsets ) ) :	for i in range ( 1 , len ( itemsets ) ) : <eos>
buf の n 番目の i と j の 論理 積 番目 を k だけ 増加 させる	buf [ n ] [ i & j ] += k	buf [ n ] [ i & j ] += k <eos>
'' 、 0 、 s の 長さ を an s 、 i 、 ls とする	ans , i , ls = '' , 0 , len ( s )	ans , i , ans = '' , 0 <eos>
four card を出力する	print ( "four card" )	print ( "four card" ) <eos>
s を p の i 番目 から c の i に d を加え た 値を 8 で 割 った 余 り 番目 を 引 いた 値 、 0 の 最大 値 だけ 増加 させる	s += max ( p [ i ] - c [ ( i + d ) % 8 ] , 0 )	s += max ( p [ i ] - c [ i + 8 ] , 0 ) % 8 <eos>
x に x を 掛け た 値 から L IM 未 満 までの x 間 隔 の数 列 を 順に y として 、 繰 り 返す	for y in range ( x * x , LIM , x ) :	for y in range ( x * x , L , x ) : <eos>
区切り なしで " node " 、 i 、 " : parent = " 、 p 、 ", depth = " 、 d 、 ", " 、 t 、 ", " 、 c を出力する	print ( "node " , i , ": parent = " , p , ", depth = " , d , ", " , t , ", " , c , sep = "" )	print ( "node <unk> <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , sep = "" ) <eos>
free の とき 、	if free :	if <unk> : <eos>
d i grap h の n 番目 内の 全ての要素 を 取り除く	digraph [ n ] . clear ( )	digraph [ n ] . clear ( ) <eos>
an im al s の 1 番目 を H _ a とする	H_a = animals [ 1 ]	<unk> = <unk> [ 1 ] <eos>
new _ p ud d le を S 2 の末尾 の 1 番目 だけ 増加 させる	new_puddle += S2 [ - 1 ] [ 1 ]	<unk> [ - 1 ] += S2 [ 1 ] <eos>
co st を 100 で 割 った 商 を an s _ 100 とする	ans_100 = cost // 100	ans_500 = cost // 100 <eos>
x の 1 番目の 先頭 を出力する	print ( x [ 1 ] [ 0 ] )	print ( x [ 1 ] [ 0 ] ) <eos>
i の とき 、 <blk> an s を '/ ' だけ 増加 させる </blk>	if i : <blk> ans += '/' </blk>	if i : <blk> ans += '/' </blk> <eos>
n が 19 より小さい とき 、 <blk> " 13 " を出力する </blk>	if n < 19 : <blk> print ( "13" ) </blk>	if n < 19 : <blk> print ( <unk> ) </blk> <eos>
i が a の平方根 以下の 間 、 次 を 繰 り 返す	while i <= sqrt ( a ) :	while i <= math . sqrt ( a ) : <eos>
N の 整数値 を N とする S の リストを S とする	N = int ( N ) S = list ( S )	S = list ( N ) <eos>
stack _ A の 長さ から 1 を 引 いた 値 から -1 未 満 までの -1 間 隔 の数 列 を 順に i として 、 繰 り 返す	for i in range ( len ( stack_A ) - 1 , - 1 , - 1 ) :	for i in range ( len ( stack_A ) - 1 , - 1 ) : <eos>
辞書の key t b l の j 番目 番目 が 1 と 等しい とき 、 <blk> key t b l の j 番目 を出力する </blk>	if dict [ keytbl [ j ] ] == 1 : <blk> print ( keytbl [ j ] ) </blk>	if dict [ j ] == keytbl [ j ] : <blk> print ( keytbl [ j ] ) </blk> <eos>
( a 、 ' A ' ) からなる 列 の s [ 0 ] の集合 が s [ 1 ] の集合 と 等しい かどうか が ( ' =' ) の集合 と 等 し く かつ s の集合 の 長さが 1 と 等しい かどうか 番目 を a とする	a = [ a , 'A' ] [ set ( s [ 0 ] ) == set ( s [ 1 ] ) == { '=' } and len ( set ( s ) ) == 1 ]	s = set ( set ( [ a [ 0 ] == set ( s ) and s [ 1 ] == set ( a ) == int ( s [ 1 ] ) and len ( a [ 1 ] == counts [ 1 ] ) == counts [
line の 両端 から 空白 改行 を取り 除 いた 文字列を string とする	string = line . strip ( )	string = line . strip ( ) <eos>
1 を stack とする	stack = 1	stack = 1 <eos>
t の i 番目 が s の j 番目 と 等しい とき 、 <blk> j を 2 だけ 増加 させる </blk>	if t [ i ] == s [ j ] : <blk> j += 2 </blk>	if t [ i ] == s [ j ] : <blk> 2 += 2 </blk> <eos>
b の N から 1 を 引 いた 値 番目 に 1 を加え た 値 から N に 2 を加え た 値 未 満 までの 数 列 を 順に i として 、 繰 り 返す	for i in range ( b [ N - 1 ] + 1 , N + 2 ) :	for i in range ( b [ N - 1 ] + 2 , N + 1 ) : <eos>
i 2 から i 3 を 引 いた 値の 2 乗 に j 2 から j 3 を 引 いた 値の 2 乗 を加え た 値 の平方根 を b とする	b = math . sqrt ( ( i2 - i3 ) ** 2 + ( j2 - j3 ) ** 2 )	b = math . sqrt ( ( ( <unk> - i ) ** 2 + ( j - j2 ) ** 2 ) <eos>
d ice s の 末尾に 入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 のリスト を追加する	dices . append ( list ( map ( int , input ( ) . split ( ) ) ) )	dices . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
card s が " - " と 等しい とき 、	if cards == "-" :	if cards == "-" : <eos>
' ' を 間 に入れ て A の各要素 に 整数 を 適用 した 列 を 連結 した 文字列 を出力する	print ( ' ' . join ( map ( str , A ) ) )	print ( ' ' . join ( map ( str , A ) ) ) <eos>
1 から t の 長さ 未 満 までの 3 間 隔 の数 列 を 順に x として 、 繰 り 返す	for x in range ( 1 , len ( t ) , 3 ) :	for x in range ( 1 , len ( t ) , 3 ) : <eos>
an s を a の i 番目 から a の i から 1 を 引 いた 値 番目 を 引 いた 値 から 2 に M を 掛け た 値を 引 いた 値 、 0 の 最大 値 だけ 増加 させる	ans += max ( a [ i ] - a [ i - 1 ] - 2 * M , 0 )	ans += max ( a [ i ] - a [ i - 1 ] * M , 0 ) <eos>
in p の 1 番目 内の " X " を i の 文字列で 置き換え た 文字列の 整数値 を right とする	right = int ( inp [ 1 ] . replace ( "X" , str ( i ) ) )	right = int ( inp [ 1 ] . replace ( "X" , str ( i ) ) <eos>
y 1 、 y 0 から q に y 1 を 掛け た 値を 引 いた 値を y 0 、 y 1 とする	y0 , y1 = y1 , ( y0 - q * y1 )	y0 , y1 = y1 , y0 * y1 - y1 <eos>
z から h に 36 00 を 掛け た 値を 引 いた 値を 60 で 割 った 商 を m とする	m = ( z - h * 3600 ) // 60	m = z - ( h * 3600 ) // 60 <eos>
n O r i g in を i で 割 った 余 り が 0 と 等しい 間 、 次 を 繰 り 返す	while nOrigin % i == 0 :	while <unk> % nOrigin == 0 : <eos>
n を 500 で 割 った 余 り が 0 と 等しい とき 、	if n % 500 == 0 :	if n % 500 == 0 : <eos>
10 000 を min _ w とする	min_w = 10000	min_w = 10000 <eos>
T の 末尾に ( left 、 right ) からなる 列 を追加する	T . append ( [ left , right ] )	T . append ( [ left , right ] ) <eos>
i を 3 で 割 った 商 に 3 を 掛け た 値に p を加え た 値を x とする	x = ( i // 3 ) * 3 + p	x = i // 3 + 3 * p <eos>
heappop ( h q ) を展開し 、 それぞれ u _ cos t 、 u とする	u_cost , u = heappop ( hq )	u , u_cost = heappop ( hq ) <eos>
x が g a p 以上の とき 、	if x >= gap :	if x >= gap : <eos>
入力された 文字列を 空白 で 分割 した 字句 列 の各要素 に 整数 を 適用 した 列 を 展開 し 、 それぞれ d 、 w 、 h とする	d , w , h = map ( int , input ( ) . split ( ) )	d , w , h = map ( int , input ( ) . split ( ) ) <eos>
b の 絶対値 を返す	return abs ( b )	return abs ( b ) <eos>
Q . popleft ( ) を展開し 、 それぞれ state 、 x とする	state , x = Q . popleft ( )	state , x = Q . popleft ( ) <eos>
heapq モジュール を用い る	import heapq	from heapq import heappush , heappop , heappush <eos>
s _ r から 1 を 引 いた 値を s _ c とする	s_c = s_r - 1	s_c = s_r - 1 <eos>
a の j 番目 と p の d 番目の j 番目の 排 他 論理和 と 1 の 論理 積 を k とする	k = ( a [ j ] ^ p [ d ] [ j ] ) & 1	k = a [ j ] ^ p [ j ] [ 1 ] <eos>
